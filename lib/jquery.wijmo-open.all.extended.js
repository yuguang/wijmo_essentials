/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function(z,y){var a,x,t,s,w,c,j,r,k,v,p,e,b,q,f,h,m,n,u,l,g,i,o,d;a=function(b){return new a.prototype.init(b)};if(typeof require!=="undefined"&&typeof exports!=="undefined"&&typeof module!=="undefined")module.exports=a;else z.Globalize=a;a.cultures={};a.prototype={constructor:a,init:function(b){this.cultures=a.cultures;this.cultureSelector=b;return this}};a.prototype.init.prototype=a.prototype;a.cultures["default"]={name:"en",englishName:"English",nativeName:"English",isRTL:false,language:"en",numberFormat:{pattern:["-n"],decimals:2,",":",",".":".",groupSizes:[3],"+":"+","-":"-",NaN:"NaN",negativeInfinity:"-Infinity",positiveInfinity:"Infinity",percent:{pattern:["-n %","n %"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"%"},currency:{pattern:["($n)","$n"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"$"}},calendars:{standard:{name:"Gregorian_USEnglish","/":"/",":":":",firstDay:0,days:{names:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],namesAbbr:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],namesShort:["Su","Mo","Tu","We","Th","Fr","Sa"]},months:{names:["January","February","March","April","May","June","July","August","September","October","November","December",""],namesAbbr:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec",""]},AM:["AM","am","AM"],PM:["PM","pm","PM"],eras:[{name:"A.D.",start:null,offset:0}],twoDigitYearMax:2029,patterns:{d:"M/d/yyyy",D:"dddd, MMMM dd, yyyy",t:"h:mm tt",T:"h:mm:ss tt",f:"dddd, MMMM dd, yyyy h:mm tt",F:"dddd, MMMM dd, yyyy h:mm:ss tt",M:"MMMM dd",Y:"yyyy MMMM",S:"yyyy'-'MM'-'dd'T'HH':'mm':'ss"}}},messages:{}};a.cultures["default"].calendar=a.cultures["default"].calendars.standard;a.cultures.en=a.cultures["default"];a.cultureSelector="en";x=/^0x[a-f0-9]+$/i;t=/^[+-]?infinity$/i;s=/^[+-]?\d*\.?\d*(e[+-]?\d+)?$/;w=/^\s+|\s+$/g;c=function(a,c){if(a.indexOf)return a.indexOf(c);for(var b=0,d=a.length;b<d;b++)if(a[b]===c)return b;return-1};j=function(b,a){return b.substr(b.length-a.length)===a};r=function(i){var g,d,c,b,f,h,a=arguments[0]||{},e=1,j=arguments.length,i=false;if(typeof a==="boolean"){i=a;a=arguments[1]||{};e=2}if(typeof a!=="object"&&!v(a))a={};for(;e<j;e++)if((g=arguments[e])!=null)for(d in g){c=a[d];b=g[d];if(a===b)continue;if(i&&b&&(p(b)||(f=k(b)))){if(f){f=false;h=c&&k(c)?c:[]}else h=c&&p(c)?c:{};a[d]=r(i,h,b)}else if(b!==y)a[d]=b}return a};k=Array.isArray||function(a){return Object.prototype.toString.call(a)==="[object Array]"};v=function(a){return Object.prototype.toString.call(a)==="[object Function]"};p=function(a){return Object.prototype.toString.call(a)==="[object Object]"};e=function(b,a){return b.indexOf(a)===0};b=function(a){return(a+"").replace(w,"")};q=function(a){return isNaN(a)?NaN:a|0};f=function(a,c,d){for(var b=a.length;b<c;b+=1)a=d?"0"+a:a+"0";return a};h=function(e,b){for(var d=0,a=false,c=0,g=e.length;c<g;c++){var f=e.charAt(c);switch(f){case"'":if(a)b.push("'");else d++;a=false;break;case"\\":a&&b.push("\\");a=!a;break;default:b.push(f);a=false}}return d};m=function(e,a){a=a||"F";var b,d=e.patterns,c=a.length;if(c===1){b=d[a];if(!b)throw"Invalid date format string '"+a+"'.";a=b}else if(c===2&&a.charAt(0)==="%")a=a.charAt(1);return a};n=function(b,f,r){var c=r.calendar,s=c.convert;if(!f||!f.length||f==="i"){var a;if(r&&r.name.length)if(s)a=n(b,c.patterns.F,r);else{var z=new Date(b.getTime()),H=g(b,c.eras);z.setFullYear(i(b,c,H));a=z.toLocaleString()}else a=b.toString();return a}var A=c.eras,y=f==="s";f=m(c,f);a=[];var j,G=["0","00","000"],p,w,B=/([^d]|^)(d|dd)([^d]|$)/g,x=0,v=l(),o;function e(d,a){var b,c=d+"";if(a>1&&c.length<a){b=G[a-2]+c;return b.substr(b.length-a,a)}else b=c;return b}function D(){if(p||w)return p;p=B.test(f);w=true;return p}function u(a,b){if(o)return o[b];switch(b){case 0:return a.getFullYear();case 1:return a.getMonth();case 2:return a.getDate()}}if(!y&&s)o=s.fromGregorian(b);for(;;){var E=v.lastIndex,q=v.exec(f),C=f.slice(E,q?q.index:f.length);x+=h(C,a);if(!q)break;if(x%2){a.push(q[0]);continue}var t=q[0],d=t.length;switch(t){case"ddd":case"dddd":var F=d===3?c.days.namesAbbr:c.days.names;a.push(F[b.getDay()]);break;case"d":case"dd":p=true;a.push(e(u(b,2),d));break;case"MMM":case"MMMM":var k=u(b,1);a.push(c.monthsGenitive&&D()?c.monthsGenitive[d===3?"namesAbbr":"names"][k]:c.months[d===3?"namesAbbr":"names"][k]);break;case"M":case"MM":a.push(e(u(b,1)+1,d));break;case"y":case"yy":case"yyyy":k=o?o[0]:i(b,c,g(b,A),y);if(d<4)k=k%100;a.push(e(k,d));break;case"h":case"hh":j=b.getHours()%12;if(j===0)j=12;a.push(e(j,d));break;case"H":case"HH":a.push(e(b.getHours(),d));break;case"m":case"mm":a.push(e(b.getMinutes(),d));break;case"s":case"ss":a.push(e(b.getSeconds(),d));break;case"t":case"tt":k=b.getHours()<12?c.AM?c.AM[0]:" ":c.PM?c.PM[0]:" ";a.push(d===1?k.charAt(0):k);break;case"f":case"ff":case"fff":a.push(e(b.getMilliseconds(),3).substr(0,d));break;case"z":case"zz":j=b.getTimezoneOffset()/60;a.push((j<=0?"+":"-")+e(Math.floor(Math.abs(j)),d));break;case"zzz":j=b.getTimezoneOffset()/60;a.push((j<=0?"+":"-")+e(Math.floor(Math.abs(j)),2)+":"+e(Math.abs(b.getTimezoneOffset()%60),2));break;case"g":case"gg":c.eras&&a.push(c.eras[g(b,A)].name);break;case"/":a.push(c["/"]);break;default:throw"Invalid date format pattern '"+t+"'.";}}return a.join("")};(function(){var a;a=function(j,h,l){var m=l.groupSizes,i=m[0],k=1,p=Math.pow(10,h),n=Math.round(j*p)/p;if(!isFinite(n))n=j;j=n;var b=j+"",a="",e=b.split(/e/i),c=e.length>1?parseInt(e[1],10):0;b=e[0];e=b.split(".");b=e[0];a=e.length>1?e[1]:"";var q;if(c>0){a=f(a,c,false);b+=a.slice(0,c);a=a.substr(c)}else if(c<0){c=-c;b=f(b,c+1);a=b.slice(-c,b.length)+a;b=b.slice(0,-c)}if(h>0)a=l["."]+(a.length>h?a.slice(0,h):f(a,h));else a="";var d=b.length-1,o=l[","],g="";while(d>=0){if(i===0||i>d)return b.slice(0,d+1)+(g.length?o+g+a:a);g=b.slice(d-i+1,d+1)+(g.length?o+g:"");d-=i;if(k<m.length){i=m[k];k++}}return b.slice(0,d+1)+o+g+a};u=function(d,e,j){if(!isFinite(d))return d===Infinity?j.numberFormat.positiveInfinity:d===-Infinity?j.numberFormat.negativeInfinity:j.numberFormat.NaN;if(!e||e==="i")return j.name.length?d.toLocaleString():d.toString();e=e||"D";var i=j.numberFormat,b=Math.abs(d),g=-1,k;if(e.length>1)g=parseInt(e.slice(1),10);var m=e.charAt(0).toUpperCase(),c;switch(m){case"D":k="n";b=q(b);if(g!==-1)b=f(""+b,g,true);if(d<0)b="-"+b;break;case"N":c=i;case"C":c=c||i.currency;case"P":c=c||i.percent;k=d<0?c.pattern[0]:c.pattern[1]||"n";if(g===-1)g=c.decimals;b=a(b*(m==="P"?100:1),g,c);break;default:throw"Bad number format specifier: "+m;}for(var n=/n|\$|-|%/g,h="";;){var o=n.lastIndex,l=n.exec(k);h+=k.slice(o,l?l.index:k.length);if(!l)break;switch(l[0]){case"n":h+=b;break;case"$":h+=i.currency.symbol;break;case"-":if(/[1-9]/.test(b))h+=i["-"];break;case"%":h+=i.percent.symbol}}return h}})();l=function(){return/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g};g=function(e,c){if(!c)return 0;for(var b,d=e.getTime(),a=0,f=c.length;a<f;a++){b=c[a].start;if(b===null||d>=b)return a}return 0};i=function(d,b,e,c){var a=d.getFullYear();if(!c&&b.eras)a-=b.eras[e].offset;return a};(function(){var p,n,k,j,a,f,d;p=function(d,b){if(b<100){var e=new Date,f=g(e),c=i(e,d,f),a=d.twoDigitYearMax;a=typeof a==="string"?(new Date).getFullYear()%100+parseInt(a,10):a;b+=c-c%100;if(b>a)b-=100}return b};n=function(h,b,i){var e,g=h.days,a=h._upperDays;if(!a)h._upperDays=a=[d(g.names),d(g.namesAbbr),d(g.namesShort)];b=f(b);if(i){e=c(a[1],b);if(e===-1)e=c(a[2],b)}else e=c(a[0],b);return e};k=function(a,e,k){var j=a.months,i=a.monthsGenitive||a.months,b=a._upperMonths,g=a._upperMonthsGen;if(!b){a._upperMonths=b=[d(j.names),d(j.namesAbbr)];a._upperMonthsGen=g=[d(i.names),d(i.namesAbbr)]}e=f(e);var h=c(k?b[1]:b[0],e);if(h<0)h=c(k?g[1]:g[0],e);return h};j=function(d,g){var e=d._parseRegExp;if(!e)d._parseRegExp=e={};else{var o=e[g];if(o)return o}var f=m(d,g).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g,"\\\\$1"),b=["^"],p=[],i=0,n=0,k=l(),c;while((c=k.exec(f))!==null){var s=f.slice(i,c.index);i=k.lastIndex;n+=h(s,b);if(n%2){b.push(c[0]);continue}var j=c[0],t=j.length,a;switch(j){case"dddd":case"ddd":case"MMMM":case"MMM":case"gg":case"g":a="(\\D+)";break;case"tt":case"t":a="(\\D*)";break;case"yyyy":case"fff":case"ff":case"f":a="(\\d{"+t+"})";break;case"dd":case"d":case"MM":case"M":case"yy":case"y":case"HH":case"H":case"hh":case"h":case"mm":case"m":case"ss":case"s":a="(\\d\\d?)";break;case"zzz":a="([+-]?\\d\\d?:\\d{2})";break;case"zz":case"z":a="([+-]?\\d\\d?)";break;case"/":a="(\\"+d["/"]+")";break;default:throw"Invalid date format pattern '"+j+"'.";}a&&b.push(a);p.push(c[0])}h(f.slice(i),b);b.push("$");var r=b.join("").replace(/\s+/g,"\\s+"),q={regExp:r,groups:p};return e[g]=q};a=function(a,c,b){return a<c||a>b};f=function(a){return a.split("\u00a0").join(" ").toUpperCase()};d=function(c){for(var b=[],a=0,d=c.length;a<d;a++)b[a]=f(c[a]);return b};o=function(A,M,L){A=b(A);var c=L.calendar,H=j(c,M),K=new RegExp(H.regExp).exec(A);if(K===null)return null;for(var J=H.groups,C=null,m=null,i=null,l=null,u=null,h=0,o,D=0,E=0,B=0,q=null,z=false,w=0,N=J.length;w<N;w++){var d=K[w+1];if(d){var I=J[w],r=I.length,g=parseInt(d,10);switch(I){case"dd":case"d":l=g;if(a(l,1,31))return null;break;case"MMM":case"MMMM":i=k(c,d,r===3);if(a(i,0,11))return null;break;case"M":case"MM":i=g-1;if(a(i,0,11))return null;break;case"y":case"yy":case"yyyy":m=r<4?p(c,g):g;if(a(m,0,9999))return null;break;case"h":case"hh":h=g;if(h===12)h=0;if(a(h,0,11))return null;break;case"H":case"HH":h=g;if(a(h,0,23))return null;break;case"m":case"mm":D=g;if(a(D,0,59))return null;break;case"s":case"ss":E=g;if(a(E,0,59))return null;break;case"tt":case"t":z=c.PM&&(d===c.PM[0]||d===c.PM[1]||d===c.PM[2]);if(!z&&(!c.AM||d!==c.AM[0]&&d!==c.AM[1]&&d!==c.AM[2]))return null;break;case"f":case"ff":case"fff":B=g*Math.pow(10,3-r);if(a(B,0,999))return null;break;case"ddd":case"dddd":u=n(c,d,r===3);if(a(u,0,6))return null;break;case"zzz":var y=d.split(/:/);if(y.length!==2)return null;o=parseInt(y[0],10);if(a(o,-12,13))return null;var x=parseInt(y[1],10);if(a(x,0,59))return null;q=o*60+(e(d,"-")?-x:x);break;case"z":case"zz":o=g;if(a(o,-12,13))return null;q=o*60;break;case"g":case"gg":var t=d;if(!t||!c.eras)return null;t=b(t.toLowerCase());for(var v=0,O=c.eras.length;v<O;v++)if(t===c.eras[v].name.toLowerCase()){C=v;break}if(C===null)return null}}}var f=new Date,G,s=c.convert;G=s?s.fromGregorian(f)[0]:f.getFullYear();if(m===null)m=G;else if(c.eras)m+=c.eras[C||0].offset;if(i===null)i=0;if(l===null)l=1;if(s){f=s.toGregorian(m,i,l);if(f===null)return null}else{f.setFullYear(m,i,l);if(f.getDate()!==l)return null;if(u!==null&&f.getDay()!==u)return null}if(z&&h<12)h+=12;f.setHours(h,D,E,B);if(q!==null){var F=f.getMinutes()-(q+f.getTimezoneOffset());f.setHours(f.getHours()+parseInt(F/60,10),F%60)}return f}})();d=function(a,f,g){var b=f["-"],c=f["+"],d;switch(g){case"n -":b=" "+b;c=" "+c;case"n-":if(j(a,b))d=["-",a.substr(0,a.length-b.length)];else if(j(a,c))d=["+",a.substr(0,a.length-c.length)];break;case"- n":b+=" ";c+=" ";case"-n":if(e(a,b))d=["-",a.substr(b.length)];else if(e(a,c))d=["+",a.substr(c.length)];break;case"(n)":if(e(a,"(")&&j(a,")"))d=["-",a.substr(1,a.length-2)]}return d||["",a]};a.prototype.findClosestCulture=function(b){return a.findClosestCulture.call(this,b)};a.prototype.format=function(d,c,b){return a.format.call(this,d,c,b)};a.prototype.localize=function(c,b){return a.localize.call(this,c,b)};a.prototype.parseInt=function(d,c,b){return a.parseInt.call(this,d,c,b)};a.prototype.parseFloat=function(d,c,b){return a.parseFloat.call(this,d,c,b)};a.prototype.culture=function(b){return a.culture.call(this,b)};a.addCultureInfo=function(a,c,e){var b={},d=false;if(typeof a!=="string"){e=a;a=this.culture().name;b=this.cultures[a]}else if(typeof c!=="string"){e=c;d=this.cultures[a]==null;b=this.cultures[a]||this.cultures["default"]}else{d=true;b=this.cultures[c]}this.cultures[a]=r(true,{},b,e);if(d)this.cultures[a].calendar=this.cultures[a].calendars.standard};a.findClosestCulture=function(a){var e;if(!a)return this.cultures[this.cultureSelector]||this.cultures["default"];if(typeof a==="string")a=a.split(",");if(k(a)){for(var d,h=this.cultures,n=a,i=n.length,g=[],c=0;c<i;c++){a=b(n[c]);var f,j=a.split(";");d=b(j[0]);if(j.length===1)f=1;else{a=b(j[1]);if(a.indexOf("q=")===0){a=a.substr(2);f=parseFloat(a);f=isNaN(f)?0:f}else f=1}g.push({lang:d,pri:f})}g.sort(function(a,b){return a.pri<b.pri?1:-1});for(c=0;c<i;c++){d=g[c].lang;e=h[d];if(e)return e}for(c=0;c<i;c++){d=g[c].lang;do{var m=d.lastIndexOf("-");if(m===-1)break;d=d.substr(0,m);e=h[d];if(e)return e}while(1)}for(c=0;c<i;c++){d=g[c].lang;for(var o in h){var l=h[o];if(l.language==d)return l}}}else if(typeof a==="object")return a;return e||null};a.format=function(a,b,c){culture=this.findClosestCulture(c);if(a instanceof Date)a=n(a,b,culture);else if(typeof a==="number")a=u(a,b,culture);return a};a.localize=function(a,b){return this.findClosestCulture(b).messages[a]||this.cultures["default"].messages[a]};a.parseDate=function(g,a,b){b=this.findClosestCulture(b);var c,h,d;if(a){if(typeof a==="string")a=[a];if(a.length)for(var e=0,i=a.length;e<i;e++){var f=a[e];if(f){c=o(g,f,b);if(c)break}}}else{d=b.calendar.patterns;for(h in d){c=o(g,d[h],b);if(c)break}}return c||null};a.parseInt=function(d,c,b){return q(a.parseFloat(d,c,b))};a.parseFloat=function(a,n,u){if(typeof n!=="number"){u=n;n=10}var k=this.findClosestCulture(u),o=NaN,c=k.numberFormat;if(a.indexOf(k.numberFormat.currency.symbol)>-1){a=a.replace(k.numberFormat.currency.symbol,"");a=a.replace(k.numberFormat.currency["."],k.numberFormat["."])}a=b(a);if(t.test(a))o=parseFloat(a);else if(!n&&x.test(a))o=parseInt(a,16);else{var e=d(a,c,c.pattern[0]),g=e[0],h=e[1];if(g===""&&c.pattern[0]!=="(n)"){e=d(a,c,"(n)");g=e[0];h=e[1]}if(g===""&&c.pattern[0]!=="-n"){e=d(a,c,"-n");g=e[0];h=e[1]}g=g||"+";var l,i,j=h.indexOf("e");if(j<0)j=h.indexOf("E");if(j<0){i=h;l=null}else{i=h.substr(0,j);l=h.substr(j+1)}var f,m,y=c["."],q=i.indexOf(y);if(q<0){f=i;m=null}else{f=i.substr(0,q);m=i.substr(q+y.length)}var r=c[","];f=f.split(r).join("");var v=r.replace(/\u00A0/g," ");if(r!==v)f=f.split(v).join("");var p=g+f;if(m!==null)p+="."+m;if(l!==null){var w=d(l,c,"-n");p+="e"+(w[0]||"+")+w[1]}if(s.test(p))o=parseFloat(p)}return o};a.culture=function(a){if(typeof a!=="undefined")this.cultureSelector=a;return this.findClosestCulture(a)||this.culture["default"]}})(this);
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version 3.0.0
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    $.fn.bgiframe = function (s) {
        s = $.extend({
            top: 'auto', // auto == borderTopWidth
            left: 'auto', // auto == borderLeftWidth
            width: 'auto', // auto == offsetWidth
            height: 'auto', // auto == offsetHeight
            opacity: true,
            src: 'javascript:false;',
            conditional: /MSIE 6.0/.test(navigator.userAgent) // expresion or function. return false to prevent iframe insertion
        }, s);

        // wrap conditional in a function if it isn't already
        if (!$.isFunction(s.conditional)) {
            var condition = s.conditional;
            s.conditional = function () { return condition; };
        }

        var $iframe = $('<iframe class="bgiframe"frameborder="0"tabindex="-1"src="' + s.src + '"' +
                           'style="display:block;position:absolute;z-index:-1;"/>');

        return this.each(function () {
            var $this = $(this);
            if (s.conditional(this) === false) { return; }
            var existing = $this.children('iframe.bgiframe');
            var $el = existing.length === 0 ? $iframe.clone() : existing;
            $el.css({
                'top': s.top == 'auto' ?
                    ((parseInt($this.css('borderTopWidth'), 10) || 0) * -1) + 'px' : prop(s.top),
                'left': s.left == 'auto' ?
                    ((parseInt($this.css('borderLeftWidth'), 10) || 0) * -1) + 'px' : prop(s.left),
                'width': s.width == 'auto' ? (this.offsetWidth + 'px') : prop(s.width),
                'height': s.height == 'auto' ? (this.offsetHeight + 'px') : prop(s.height),
                'opacity': s.opacity === true ? 0 : undefined
            });

            if (existing.length === 0) {
                $this.prepend($el);
            }
        });
    };

    // old alias
    $.fn.bgIframe = $.fn.bgiframe;

    function prop(n) {
        return n && n.constructor === Number ? n + 'px' : n;
    }

}));;
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */
(function(a){function d(b){var c=b||window.event,d=[].slice.call(arguments,1),e=0,f=!0,g=0,h=0;return b=a.event.fix(c),b.type="mousewheel",c.wheelDelta&&(e=c.wheelDelta/120),c.detail&&(e=-c.detail/3),h=e,c.axis!==undefined&&c.axis===c.HORIZONTAL_AXIS&&(h=0,g=-1*e),c.wheelDeltaY!==undefined&&(h=c.wheelDeltaY/120),c.wheelDeltaX!==undefined&&(g=-1*c.wheelDeltaX/120),d.unshift(b,e,g,h),(a.event.dispatch||a.event.handle).apply(this,d)}var b=["DOMMouseScroll","mousewheel"];if(a.event.fixHooks)for(var c=b.length;c;)a.event.fixHooks[b[--c]]=a.event.mouseHooks;a.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=b.length;a;)this.addEventListener(b[--a],d,!1);else this.onmousewheel=d},teardown:function(){if(this.removeEventListener)for(var a=b.length;a;)this.removeEventListener(b[--a],d,!1);else this.onmousewheel=null}},a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery)
;
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};;
// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.0.1 - JavaScript Vector Library                           │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
(function (a) { var b = "0.4.0", c = "hasOwnProperty", d = /[\.\/]/, e = "*", f = function () { }, g = function (a, b) { return a - b }, h, i, j = { n: {} }, k = function (a, b) { var c = j, d = i, e = Array.prototype.slice.call(arguments, 2), f = k.listeners(a), l = 0, m = !1, n, o = [], p = {}, q = [], r = []; h = a, i = 0; for (var s = 0, t = f.length; s < t; s++) "zIndex" in f[s] && (o.push(f[s].zIndex), f[s].zIndex < 0 && (p[f[s].zIndex] = f[s])); o.sort(g); while (o[l] < 0) { n = p[o[l++]], q.push(n.apply(b, e)); if (i) { i = d; return q } } for (s = 0; s < t; s++) { n = f[s]; if ("zIndex" in n) if (n.zIndex == o[l]) { q.push(n.apply(b, e)); if (i) { i = d; return q } do { l++, n = p[o[l]], n && q.push(n.apply(b, e)); if (i) { i = d; return q } } while (n) } else p[n.zIndex] = n; else { q.push(n.apply(b, e)); if (i) { i = d; return q } } } i = d; return q.length ? q : null }; k.listeners = function (a) { var b = a.split(d), c = j, f, g, h, i, k, l, m, n, o = [c], p = []; for (i = 0, k = b.length; i < k; i++) { n = []; for (l = 0, m = o.length; l < m; l++) { c = o[l].n, g = [c[b[i]], c[e]], h = 2; while (h--) f = g[h], f && (n.push(f), p = p.concat(f.f || [])) } o = n } return p }, k.on = function (a, b) { var c = a.split(d), e = j; for (var g = 0, h = c.length; g < h; g++) e = e.n, !e[c[g]] && (e[c[g]] = { n: {} }), e = e[c[g]]; e.f = e.f || []; for (g = 0, h = e.f.length; g < h; g++) if (e.f[g] == b) return f; e.f.push(b); return function (a) { +a == +a && (b.zIndex = +a) } }, k.stop = function () { i = 1 }, k.nt = function (a) { if (a) return (new RegExp("(?:\\.|\\/|^)" + a + "(?:\\.|\\/|$)")).test(h); return h }, k.unbind = function (a, b) { var f = a.split(d), g, h, i, k, l, m, n, o = [j]; for (k = 0, l = f.length; k < l; k++) for (m = 0; m < o.length; m += i.length - 2) { i = [m, 1], g = o[m].n; if (f[k] != e) g[f[k]] && i.push(g[f[k]]); else for (h in g) g[c](h) && i.push(g[h]); o.splice.apply(o, i) } for (k = 0, l = o.length; k < l; k++) { g = o[k]; while (g.n) { if (b) { if (g.f) { for (m = 0, n = g.f.length; m < n; m++) if (g.f[m] == b) { g.f.splice(m, 1); break } !g.f.length && delete g.f } for (h in g.n) if (g.n[c](h) && g.n[h].f) { var p = g.n[h].f; for (m = 0, n = p.length; m < n; m++) if (p[m] == b) { p.splice(m, 1); break } !p.length && delete g.n[h].f } } else { delete g.f; for (h in g.n) g.n[c](h) && g.n[h].f && delete g.n[h].f } g = g.n } } }, k.once = function (a, b) { var c = function () { b.apply(this, arguments), k.unbind(a, c) }; return k.on(a, c) }, k.version = b, k.toString = function () { return "You are running Eve " + b }, typeof module != "undefined" && module.exports ? module.exports = k : a.eve = k })(this), function () { function cr(b, d, e, f, h, i) { e = Q(e); var j, k, l, m = [], o, p, q, t = b.ms, u = {}, v = {}, w = {}; if (f) for (y = 0, z = cl.length; y < z; y++) { var x = cl[y]; if (x.el.id == d.id && x.anim == b) { x.percent != e ? (cl.splice(y, 1), l = 1) : k = x, d.attr(x.totalOrigin); break } } else f = +v; for (var y = 0, z = b.percents.length; y < z; y++) { if (b.percents[y] == e || b.percents[y] > f * b.top) { e = b.percents[y], p = b.percents[y - 1] || 0, t = t / b.top * (e - p), o = b.percents[y + 1], j = b.anim[e]; break } f && d.attr(b.anim[b.percents[y]]) } if (!!j) { if (!k) { for (var A in j) if (j[g](A)) if (U[g](A) || d.paper.customAttributes[g](A)) { u[A] = d.attr(A), u[A] == null && (u[A] = T[A]), v[A] = j[A]; switch (U[A]) { case C: w[A] = (v[A] - u[A]) / t; break; case "colour": u[A] = a.getRGB(u[A]); var B = a.getRGB(v[A]); w[A] = { r: (B.r - u[A].r) / t, g: (B.g - u[A].g) / t, b: (B.b - u[A].b) / t }; break; case "path": var D = bG(u[A], v[A]), E = D[1]; u[A] = D[0], w[A] = []; for (y = 0, z = u[A].length; y < z; y++) { w[A][y] = [0]; for (var F = 1, G = u[A][y].length; F < G; F++) w[A][y][F] = (E[y][F] - u[A][y][F]) / t } break; case "transform": var H = d._, I = bP(H[A], v[A]); if (I) { u[A] = I.from, v[A] = I.to, w[A] = [], w[A].real = !0; for (y = 0, z = u[A].length; y < z; y++) { w[A][y] = [u[A][y][0]]; for (F = 1, G = u[A][y].length; F < G; F++) w[A][y][F] = (v[A][y][F] - u[A][y][F]) / t } } else { var J = d.matrix || new bQ, K = { _: { transform: H.transform }, getBBox: function () { return d.getBBox(1) } }; u[A] = [J.a, J.b, J.c, J.d, J.e, J.f], bN(K, v[A]), v[A] = K._.transform, w[A] = [(K.matrix.a - J.a) / t, (K.matrix.b - J.b) / t, (K.matrix.c - J.c) / t, (K.matrix.d - J.d) / t, (K.matrix.e - J.e) / t, (K.matrix.e - J.f) / t] } break; case "csv": var L = r(j[A])[s](c), M = r(u[A])[s](c); if (A == "clip-rect") { u[A] = M, w[A] = [], y = M.length; while (y--) w[A][y] = (L[y] - u[A][y]) / t } v[A] = L; break; default: L = [][n](j[A]), M = [][n](u[A]), w[A] = [], y = d.paper.customAttributes[A].length; while (y--) w[A][y] = ((L[y] || 0) - (M[y] || 0)) / t } } var O = j.easing, P = a.easing_formulas[O]; if (!P) { P = r(O).match(N); if (P && P.length == 5) { var R = P; P = function (a) { return cp(a, +R[1], +R[2], +R[3], +R[4], t) } } else P = be } q = j.start || b.start || +(new Date), x = { anim: b, percent: e, timestamp: q, start: q + (b.del || 0), status: 0, initstatus: f || 0, stop: !1, ms: t, easing: P, from: u, diff: w, to: v, el: d, callback: j.callback, prev: p, next: o, repeat: i || b.times, origin: d.attr(), totalOrigin: h }, cl.push(x); if (f && !k && !l) { x.stop = !0, x.start = new Date - t * f; if (cl.length == 1) return cn() } l && (x.start = new Date - x.ms * f), cl.length == 1 && cm(cn) } else k.initstatus = f, k.start = new Date - k.ms * f; eve("anim.start." + d.id, d, b) } } function cq(a, b) { var c = [], d = {}; this.ms = b, this.times = 1; if (a) { for (var e in a) a[g](e) && (d[Q(e)] = a[e], c.push(Q(e))); c.sort(bc) } this.anim = d, this.top = c[c.length - 1], this.percents = c } function cp(a, b, c, d, e, f) { function o(a, b) { var c, d, e, f, j, k; for (e = a, k = 0; k < 8; k++) { f = m(e) - a; if (z(f) < b) return e; j = (3 * i * e + 2 * h) * e + g; if (z(j) < 1e-6) break; e = e - f / j } c = 0, d = 1, e = a; if (e < c) return c; if (e > d) return d; while (c < d) { f = m(e); if (z(f - a) < b) return e; a > f ? c = e : d = e, e = (d - c) / 2 + c } return e } function n(a, b) { var c = o(a, b); return ((l * c + k) * c + j) * c } function m(a) { return ((i * a + h) * a + g) * a } var g = 3 * b, h = 3 * (d - b) - g, i = 1 - g - h, j = 3 * c, k = 3 * (e - c) - j, l = 1 - j - k; return n(a, 1 / (200 * f)) } function cd() { return this.x + q + this.y + q + this.width + " × " + this.height } function cc() { return this.x + q + this.y } function bQ(a, b, c, d, e, f) { a != null ? (this.a = +a, this.b = +b, this.c = +c, this.d = +d, this.e = +e, this.f = +f) : (this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0) } function bw(a) { var b = []; for (var c = 0, d = a.length; d - 2 > c; c += 2) { var e = [{ x: +a[c], y: +a[c + 1] }, { x: +a[c], y: +a[c + 1] }, { x: +a[c + 2], y: +a[c + 3] }, { x: +a[c + 4], y: +a[c + 5]}]; d - 4 == c ? (e[0] = { x: +a[c - 2], y: +a[c - 1] }, e[3] = e[2]) : c && (e[0] = { x: +a[c - 2], y: +a[c - 1] }), b.push(["C", (-e[0].x + 6 * e[1].x + e[2].x) / 6, (-e[0].y + 6 * e[1].y + e[2].y) / 6, (e[1].x + 6 * e[2].x - e[3].x) / 6, (e[1].y + 6 * e[2].y - e[3].y) / 6, e[2].x, e[2].y]) } return b } function bv() { return this.hex } function bt(a, b, c) { function d() { var e = Array.prototype.slice.call(arguments, 0), f = e.join("␀"), h = d.cache = d.cache || {}, i = d.count = d.count || []; if (h[g](f)) { bs(i, f); return c ? c(h[f]) : h[f] } i.length >= 1e3 && delete h[i.shift()], i.push(f), h[f] = a[m](b, e); return c ? c(h[f]) : h[f] } return d } function bs(a, b) { for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return a.push(a.splice(c, 1)[0]) } function a(c) { if (a.is(c, "function")) return b ? c() : eve.on("DOMload", c); if (a.is(c, E)) return a._engine.create[m](a, c.splice(0, 3 + a.is(c[0], C))).add(c); var d = Array.prototype.slice.call(arguments, 0); if (a.is(d[d.length - 1], "function")) { var e = d.pop(); return b ? e.call(a._engine.create[m](a, d)) : eve.on("DOMload", function () { e.call(a._engine.create[m](a, d)) }) } return a._engine.create[m](a, arguments) } a.version = "2.0.1", a.eve = eve; var b, c = /[, ]+/, d = { circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1 }, e = /\{(\d+)\}/g, f = "prototype", g = "hasOwnProperty", h = { doc: document, win: window }, i = { was: Object.prototype[g].call(h.win, "Raphael"), is: h.win.Raphael }, j = function () { this.ca = this.customAttributes = {} }, k, l = "appendChild", m = "apply", n = "concat", o = "createTouch" in h.doc, p = "", q = " ", r = String, s = "split", t = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[s](q), u = { mousedown: "touchstart", mousemove: "touchmove", mouseup: "touchend" }, v = r.prototype.toLowerCase, w = Math, x = w.max, y = w.min, z = w.abs, A = w.pow, B = w.PI, C = "number", D = "string", E = "array", F = "toString", G = "fill", H = Object.prototype.toString, I = {}, J = "push", K = a._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i, L = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i, M = { NaN: 1, Infinity: 1, "-Infinity": 1 }, N = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, O = w.round, P = "setAttribute", Q = parseFloat, R = parseInt, S = r.prototype.toUpperCase, T = a._availableAttrs = { "arrow-end": "none", "arrow-start": "none", blur: 0, "clip-rect": "0 0 1e9 1e9", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "http://raphaeljs.com/", "letter-spacing": 0, opacity: 1, path: "M0,0", r: 0, rx: 0, ry: 0, src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", title: "Raphael", transform: "", width: 0, x: 0, y: 0 }, U = a._availableAnimAttrs = { blur: C, "clip-rect": "csv", cx: C, cy: C, fill: "colour", "fill-opacity": C, "font-size": C, height: C, opacity: C, path: "path", r: C, rx: C, ry: C, stroke: "colour", "stroke-opacity": C, "stroke-width": C, transform: "transform", width: C, x: C, y: C }, V = /\s*,\s*/, W = { hs: 1, rg: 1 }, X = /,?([achlmqrstvxz]),?/gi, Y = /([achlmrqstvz])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?\s*,?\s*)+)/ig, Z = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?\s*,?\s*)+)/ig, $ = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s*,?\s*/ig, _ = a._radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/, ba = {}, bb = function (a, b) { return a.key - b.key }, bc = function (a, b) { return Q(a) - Q(b) }, bd = function () { }, be = function (a) { return a }, bf = a._rectPath = function (a, b, c, d, e) { if (e) return [["M", a + e, b], ["l", c - e * 2, 0], ["a", e, e, 0, 0, 1, e, e], ["l", 0, d - e * 2], ["a", e, e, 0, 0, 1, -e, e], ["l", e * 2 - c, 0], ["a", e, e, 0, 0, 1, -e, -e], ["l", 0, e * 2 - d], ["a", e, e, 0, 0, 1, e, -e], ["z"]]; return [["M", a, b], ["l", c, 0], ["l", 0, d], ["l", -c, 0], ["z"]] }, bg = function (a, b, c, d) { d == null && (d = c); return [["M", a, b], ["m", 0, -d], ["a", c, d, 0, 1, 1, 0, 2 * d], ["a", c, d, 0, 1, 1, 0, -2 * d], ["z"]] }, bh = a._getPath = { path: function (a) { return a.attr("path") }, circle: function (a) { var b = a.attrs; return bg(b.cx, b.cy, b.r) }, ellipse: function (a) { var b = a.attrs; return bg(b.cx, b.cy, b.rx, b.ry) }, rect: function (a) { var b = a.attrs; return bf(b.x, b.y, b.width, b.height, b.r) }, image: function (a) { var b = a.attrs; return bf(b.x, b.y, b.width, b.height) }, text: function (a) { var b = a._getBBox(); return bf(b.x, b.y, b.width, b.height) } }, bi = a.mapPath = function (a, b) { if (!b) return a; var c, d, e, f, g, h, i; a = bG(a); for (e = 0, g = a.length; e < g; e++) { i = a[e]; for (f = 1, h = i.length; f < h; f += 2) c = b.x(i[f], i[f + 1]), d = b.y(i[f], i[f + 1]), i[f] = c, i[f + 1] = d } return a }; a._g = h, a.type = h.win.SVGAngle || h.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML"; if (a.type == "VML") { var bj = h.doc.createElement("div"), bk; bj.innerHTML = '<v:shape adj="1"/>', bk = bj.firstChild, bk.style.behavior = "url(#default#VML)"; if (!bk || typeof bk.adj != "object") return a.type = p; bj = null } a.svg = !(a.vml = a.type == "VML"), a._Paper = j, a.fn = k = j.prototype = a.prototype, a._id = 0, a._oid = 0, a.is = function (a, b) { b = v.call(b); if (b == "finite") return !M[g](+a); if (b == "array") return a instanceof Array; return b == "null" && a === null || b == typeof a && a !== null || b == "object" && a === Object(a) || b == "array" && Array.isArray && Array.isArray(a) || H.call(a).slice(8, -1).toLowerCase() == b }, a.angle = function (b, c, d, e, f, g) { if (f == null) { var h = b - d, i = c - e; if (!h && !i) return 0; return (180 + w.atan2(-i, -h) * 180 / B + 360) % 360 } return a.angle(b, c, f, g) - a.angle(d, e, f, g) }, a.rad = function (a) { return a % 360 * B / 180 }, a.deg = function (a) { return a * 180 / B % 360 }, a.snapTo = function (b, c, d) { d = a.is(d, "finite") ? d : 10; if (a.is(b, E)) { var e = b.length; while (e--) if (z(b[e] - c) <= d) return b[e] } else { b = +b; var f = c % b; if (f < d) return c - f; if (f > b - d) return c - f + b } return c }; var bl = a.createUUID = function (a, b) { return function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(a, b).toUpperCase() } } (/[xy]/g, function (a) { var b = w.random() * 16 | 0, c = a == "x" ? b : b & 3 | 8; return c.toString(16) }); a.setWindow = function (b) { eve("setWindow", a, h.win, b), h.win = b, h.doc = h.win.document, a._engine.initWin && a._engine.initWin(h.win) }; var bm = function (b) { if (a.vml) { var c = /^\s+|\s+$/g, d; try { var e = new ActiveXObject("htmlfile"); e.write("<body>"), e.close(), d = e.body } catch (f) { d = createPopup().document.body } var g = d.createTextRange(); bm = bt(function (a) { try { d.style.color = r(a).replace(c, p); var b = g.queryCommandValue("ForeColor"); b = (b & 255) << 16 | b & 65280 | (b & 16711680) >>> 16; return "#" + ("000000" + b.toString(16)).slice(-6) } catch (e) { return "none" } }) } else { var i = h.doc.createElement("i"); i.title = "Raphaël Colour Picker", i.style.display = "none", h.doc.body.appendChild(i), bm = bt(function (a) { i.style.color = a; return h.doc.defaultView.getComputedStyle(i, p).getPropertyValue("color") }) } return bm(b) }, bn = function () { return "hsb(" + [this.h, this.s, this.b] + ")" }, bo = function () { return "hsl(" + [this.h, this.s, this.l] + ")" }, bp = function () { return this.hex }, bq = function (b, c, d) { c == null && a.is(b, "object") && "r" in b && "g" in b && "b" in b && (d = b.b, c = b.g, b = b.r); if (c == null && a.is(b, D)) { var e = a.getRGB(b); b = e.r, c = e.g, d = e.b } if (b > 1 || c > 1 || d > 1) b /= 255, c /= 255, d /= 255; return [b, c, d] }, br = function (b, c, d, e) { b *= 255, c *= 255, d *= 255; var f = { r: b, g: c, b: d, hex: a.rgb(b, c, d), toString: bp }; a.is(e, "finite") && (f.opacity = e); return f }; a.color = function (b) { var c; a.is(b, "object") && "h" in b && "s" in b && "b" in b ? (c = a.hsb2rgb(b), b.r = c.r, b.g = c.g, b.b = c.b, b.hex = c.hex) : a.is(b, "object") && "h" in b && "s" in b && "l" in b ? (c = a.hsl2rgb(b), b.r = c.r, b.g = c.g, b.b = c.b, b.hex = c.hex) : (a.is(b, "string") && (b = a.getRGB(b)), a.is(b, "object") && "r" in b && "g" in b && "b" in b ? (c = a.rgb2hsl(b), b.h = c.h, b.s = c.s, b.l = c.l, c = a.rgb2hsb(b), b.v = c.b) : (b = { hex: "none" }, b.r = b.g = b.b = b.h = b.s = b.v = b.l = -1)), b.toString = bp; return b }, a.hsb2rgb = function (a, b, c, d) { this.is(a, "object") && "h" in a && "s" in a && "b" in a && (c = a.b, b = a.s, a = a.h, d = a.o), a *= 360; var e, f, g, h, i; a = a % 360 / 60, i = c * b, h = i * (1 - z(a % 2 - 1)), e = f = g = c - i, a = ~ ~a, e += [i, h, 0, 0, h, i][a], f += [h, i, i, h, 0, 0][a], g += [0, 0, h, i, i, h][a]; return br(e, f, g, d) }, a.hsl2rgb = function (a, b, c, d) { this.is(a, "object") && "h" in a && "s" in a && "l" in a && (c = a.l, b = a.s, a = a.h); if (a > 1 || b > 1 || c > 1) a /= 360, b /= 100, c /= 100; a *= 360; var e, f, g, h, i; a = a % 360 / 60, i = 2 * b * (c < .5 ? c : 1 - c), h = i * (1 - z(a % 2 - 1)), e = f = g = c - i / 2, a = ~ ~a, e += [i, h, 0, 0, h, i][a], f += [h, i, i, h, 0, 0][a], g += [0, 0, h, i, i, h][a]; return br(e, f, g, d) }, a.rgb2hsb = function (a, b, c) { c = bq(a, b, c), a = c[0], b = c[1], c = c[2]; var d, e, f, g; f = x(a, b, c), g = f - y(a, b, c), d = g == 0 ? null : f == a ? (b - c) / g : f == b ? (c - a) / g + 2 : (a - b) / g + 4, d = (d + 360) % 6 * 60 / 360, e = g == 0 ? 0 : g / f; return { h: d, s: e, b: f, toString: bn} }, a.rgb2hsl = function (a, b, c) { c = bq(a, b, c), a = c[0], b = c[1], c = c[2]; var d, e, f, g, h, i; g = x(a, b, c), h = y(a, b, c), i = g - h, d = i == 0 ? null : g == a ? (b - c) / i : g == b ? (c - a) / i + 2 : (a - b) / i + 4, d = (d + 360) % 6 * 60 / 360, f = (g + h) / 2, e = i == 0 ? 0 : f < .5 ? i / (2 * f) : i / (2 - 2 * f); return { h: d, s: e, l: f, toString: bo} }, a._path2string = function () { return this.join(",").replace(X, "$1") }; var bu = a._preload = function (a, b) { var c = h.doc.createElement("img"); c.style.cssText = "position:absolute;left:-9999em;top:-9999em", c.onload = function () { b.call(this), this.onload = null, h.doc.body.removeChild(this) }, c.onerror = function () { h.doc.body.removeChild(this) }, h.doc.body.appendChild(c), c.src = a }; a.getRGB = bt(function (b) { if (!b || !!((b = r(b)).indexOf("-") + 1)) return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: bv }; if (b == "none") return { r: -1, g: -1, b: -1, hex: "none", toString: bv }; !W[g](b.toLowerCase().substring(0, 2)) && b.charAt() != "#" && (b = bm(b)); var c, d, e, f, h, i, j, k = b.match(L); if (k) { k[2] && (f = R(k[2].substring(5), 16), e = R(k[2].substring(3, 5), 16), d = R(k[2].substring(1, 3), 16)), k[3] && (f = R((i = k[3].charAt(3)) + i, 16), e = R((i = k[3].charAt(2)) + i, 16), d = R((i = k[3].charAt(1)) + i, 16)), k[4] && (j = k[4][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), k[1].toLowerCase().slice(0, 4) == "rgba" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100)); if (k[5]) { j = k[5][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), (j[0].slice(-3) == "deg" || j[0].slice(-1) == "°") && (d /= 360), k[1].toLowerCase().slice(0, 4) == "hsba" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100); return a.hsb2rgb(d, e, f, h) } if (k[6]) { j = k[6][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), (j[0].slice(-3) == "deg" || j[0].slice(-1) == "°") && (d /= 360), k[1].toLowerCase().slice(0, 4) == "hsla" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100); return a.hsl2rgb(d, e, f, h) } k = { r: d, g: e, b: f, toString: bv }, k.hex = "#" + (16777216 | f | e << 8 | d << 16).toString(16).slice(1), a.is(h, "finite") && (k.opacity = h); return k } return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: bv} }, a), a.hsb = bt(function (b, c, d) { return a.hsb2rgb(b, c, d).hex }), a.hsl = bt(function (b, c, d) { return a.hsl2rgb(b, c, d).hex }), a.rgb = bt(function (a, b, c) { return "#" + (16777216 | c | b << 8 | a << 16).toString(16).slice(1) }), a.getColor = function (a) { var b = this.getColor.start = this.getColor.start || { h: 0, s: 1, b: a || .75 }, c = this.hsb2rgb(b.h, b.s, b.b); b.h += .075, b.h > 1 && (b.h = 0, b.s -= .2, b.s <= 0 && (this.getColor.start = { h: 0, s: 1, b: b.b })); return c.hex }, a.getColor.reset = function () { delete this.start }, a.parsePathString = bt(function (b) { if (!b) return null; var c = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 }, d = []; a.is(b, E) && a.is(b[0], E) && (d = by(b)), d.length || r(b).replace(Y, function (a, b, e) { var f = [], g = b.toLowerCase(); e.replace($, function (a, b) { b && f.push(+b) }), g == "m" && f.length > 2 && (d.push([b][n](f.splice(0, 2))), g = "l", b = b == "m" ? "l" : "L"); if (g == "r") d.push([b][n](f)); else while (f.length >= c[g]) { d.push([b][n](f.splice(0, c[g]))); if (!c[g]) break } }), d.toString = a._path2string; return d }), a.parseTransformString = bt(function (b) { if (!b) return null; var c = { r: 3, s: 4, t: 2, m: 6 }, d = []; a.is(b, E) && a.is(b[0], E) && (d = by(b)), d.length || r(b).replace(Z, function (a, b, c) { var e = [], f = v.call(b); c.replace($, function (a, b) { b && e.push(+b) }), d.push([b][n](e)) }), d.toString = a._path2string; return d }), a.findDotsAtSegment = function (a, b, c, d, e, f, g, h, i) { var j = 1 - i, k = A(j, 3), l = A(j, 2), m = i * i, n = m * i, o = k * a + l * 3 * i * c + j * 3 * i * i * e + n * g, p = k * b + l * 3 * i * d + j * 3 * i * i * f + n * h, q = a + 2 * i * (c - a) + m * (e - 2 * c + a), r = b + 2 * i * (d - b) + m * (f - 2 * d + b), s = c + 2 * i * (e - c) + m * (g - 2 * e + c), t = d + 2 * i * (f - d) + m * (h - 2 * f + d), u = j * a + i * c, v = j * b + i * d, x = j * e + i * g, y = j * f + i * h, z = 90 - w.atan2(q - s, r - t) * 180 / B; (q > s || r < t) && (z += 180); return { x: o, y: p, m: { x: q, y: r }, n: { x: s, y: t }, start: { x: u, y: v }, end: { x: x, y: y }, alpha: z} }, a._removedFactory = function (a) { return function () { throw new Error("Raphaël: you are calling to method “" + a + "” of removed object") } }; var bx = bt(function (a) { if (!a) return { x: 0, y: 0, width: 0, height: 0 }; a = bG(a); var b = 0, c = 0, d = [], e = [], f; for (var g = 0, h = a.length; g < h; g++) { f = a[g]; if (f[0] == "M") b = f[1], c = f[2], d.push(b), e.push(c); else { var i = bF(b, c, f[1], f[2], f[3], f[4], f[5], f[6]); d = d[n](i.min.x, i.max.x), e = e[n](i.min.y, i.max.y), b = f[5], c = f[6] } } var j = y[m](0, d), k = y[m](0, e); return { x: j, y: k, width: x[m](0, d) - j, height: x[m](0, e) - k} }, null, function (a) { return { x: a.x, y: a.y, width: a.width, height: a.height} }), by = function (b) { var c = []; if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); for (var d = 0, e = b.length; d < e; d++) { c[d] = []; for (var f = 0, g = b[d].length; f < g; f++) c[d][f] = b[d][f] } c.toString = a._path2string; return c }, bz = a._pathToRelative = bt(function (b) { if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); var c = [], d = 0, e = 0, f = 0, g = 0, h = 0; b[0][0] == "M" && (d = b[0][1], e = b[0][2], f = d, g = e, h++, c.push(["M", d, e])); for (var i = h, j = b.length; i < j; i++) { var k = c[i] = [], l = b[i]; if (l[0] != v.call(l[0])) { k[0] = v.call(l[0]); switch (k[0]) { case "a": k[1] = l[1], k[2] = l[2], k[3] = l[3], k[4] = l[4], k[5] = l[5], k[6] = +(l[6] - d).toFixed(3), k[7] = +(l[7] - e).toFixed(3); break; case "v": k[1] = +(l[1] - e).toFixed(3); break; case "m": f = l[1], g = l[2]; default: for (var m = 1, n = l.length; m < n; m++) k[m] = +(l[m] - (m % 2 ? d : e)).toFixed(3) } } else { k = c[i] = [], l[0] == "m" && (f = l[1] + d, g = l[2] + e); for (var o = 0, p = l.length; o < p; o++) c[i][o] = l[o] } var q = c[i].length; switch (c[i][0]) { case "z": d = f, e = g; break; case "h": d += +c[i][q - 1]; break; case "v": e += +c[i][q - 1]; break; default: d += +c[i][q - 2], e += +c[i][q - 1] } } c.toString = a._path2string; return c }, 0, by), bA = a._pathToAbsolute = bt(function (b) { if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); if (!b || !b.length) return [["M", 0, 0]]; var c = [], d = 0, e = 0, f = 0, g = 0, h = 0; b[0][0] == "M" && (d = +b[0][1], e = +b[0][2], f = d, g = e, h++, c[0] = ["M", d, e]); for (var i, j, k = h, l = b.length; k < l; k++) { c.push(i = []), j = b[k]; if (j[0] != S.call(j[0])) { i[0] = S.call(j[0]); switch (i[0]) { case "A": i[1] = j[1], i[2] = j[2], i[3] = j[3], i[4] = j[4], i[5] = j[5], i[6] = +(j[6] + d), i[7] = +(j[7] + e); break; case "V": i[1] = +j[1] + e; break; case "H": i[1] = +j[1] + d; break; case "R": var m = [d, e][n](j.slice(1)); for (var o = 2, p = m.length; o < p; o++) m[o] = +m[o] + d, m[++o] = +m[o] + e; c.pop(), c = c[n](bw(m)); break; case "M": f = +j[1] + d, g = +j[2] + e; default: for (o = 1, p = j.length; o < p; o++) i[o] = +j[o] + (o % 2 ? d : e) } } else if (j[0] == "R") m = [d, e][n](j.slice(1)), c.pop(), c = c[n](bw(m)), i = ["R"][n](j.slice(-2)); else for (var q = 0, r = j.length; q < r; q++) i[q] = j[q]; switch (i[0]) { case "Z": d = f, e = g; break; case "H": d = i[1]; break; case "V": e = i[1]; break; case "M": f = i[i.length - 2], g = i[i.length - 1]; default: d = i[i.length - 2], e = i[i.length - 1] } } c.toString = a._path2string; return c }, null, by), bB = function (a, b, c, d) { return [a, b, c, d, c, d] }, bC = function (a, b, c, d, e, f) { var g = 1 / 3, h = 2 / 3; return [g * a + h * c, g * b + h * d, g * e + h * c, g * f + h * d, e, f] }, bD = function (a, b, c, d, e, f, g, h, i, j) { var k = B * 120 / 180, l = B / 180 * (+e || 0), m = [], o, p = bt(function (a, b, c) { var d = a * w.cos(c) - b * w.sin(c), e = a * w.sin(c) + b * w.cos(c); return { x: d, y: e} }); if (!j) { o = p(a, b, -l), a = o.x, b = o.y, o = p(h, i, -l), h = o.x, i = o.y; var q = w.cos(B / 180 * e), r = w.sin(B / 180 * e), t = (a - h) / 2, u = (b - i) / 2, v = t * t / (c * c) + u * u / (d * d); v > 1 && (v = w.sqrt(v), c = v * c, d = v * d); var x = c * c, y = d * d, A = (f == g ? -1 : 1) * w.sqrt(z((x * y - x * u * u - y * t * t) / (x * u * u + y * t * t))), C = A * c * u / d + (a + h) / 2, D = A * -d * t / c + (b + i) / 2, E = w.asin(((b - D) / d).toFixed(9)), F = w.asin(((i - D) / d).toFixed(9)); E = a < C ? B - E : E, F = h < C ? B - F : F, E < 0 && (E = B * 2 + E), F < 0 && (F = B * 2 + F), g && E > F && (E = E - B * 2), !g && F > E && (F = F - B * 2) } else E = j[0], F = j[1], C = j[2], D = j[3]; var G = F - E; if (z(G) > k) { var H = F, I = h, J = i; F = E + k * (g && F > E ? 1 : -1), h = C + c * w.cos(F), i = D + d * w.sin(F), m = bD(h, i, c, d, e, 0, g, I, J, [F, H, C, D]) } G = F - E; var K = w.cos(E), L = w.sin(E), M = w.cos(F), N = w.sin(F), O = w.tan(G / 4), P = 4 / 3 * c * O, Q = 4 / 3 * d * O, R = [a, b], S = [a + P * L, b - Q * K], T = [h + P * N, i - Q * M], U = [h, i]; S[0] = 2 * R[0] - S[0], S[1] = 2 * R[1] - S[1]; if (j) return [S, T, U][n](m); m = [S, T, U][n](m).join()[s](","); var V = []; for (var W = 0, X = m.length; W < X; W++) V[W] = W % 2 ? p(m[W - 1], m[W], l).y : p(m[W], m[W + 1], l).x; return V }, bE = function (a, b, c, d, e, f, g, h, i) { var j = 1 - i; return { x: A(j, 3) * a + A(j, 2) * 3 * i * c + j * 3 * i * i * e + A(i, 3) * g, y: A(j, 3) * b + A(j, 2) * 3 * i * d + j * 3 * i * i * f + A(i, 3) * h} }, bF = bt(function (a, b, c, d, e, f, g, h) { var i = e - 2 * c + a - (g - 2 * e + c), j = 2 * (c - a) - 2 * (e - c), k = a - c, l = (-j + w.sqrt(j * j - 4 * i * k)) / 2 / i, n = (-j - w.sqrt(j * j - 4 * i * k)) / 2 / i, o = [b, h], p = [a, g], q; z(l) > "1e12" && (l = .5), z(n) > "1e12" && (n = .5), l > 0 && l < 1 && (q = bE(a, b, c, d, e, f, g, h, l), p.push(q.x), o.push(q.y)), n > 0 && n < 1 && (q = bE(a, b, c, d, e, f, g, h, n), p.push(q.x), o.push(q.y)), i = f - 2 * d + b - (h - 2 * f + d), j = 2 * (d - b) - 2 * (f - d), k = b - d, l = (-j + w.sqrt(j * j - 4 * i * k)) / 2 / i, n = (-j - w.sqrt(j * j - 4 * i * k)) / 2 / i, z(l) > "1e12" && (l = .5), z(n) > "1e12" && (n = .5), l > 0 && l < 1 && (q = bE(a, b, c, d, e, f, g, h, l), p.push(q.x), o.push(q.y)), n > 0 && n < 1 && (q = bE(a, b, c, d, e, f, g, h, n), p.push(q.x), o.push(q.y)); return { min: { x: y[m](0, p), y: y[m](0, o) }, max: { x: x[m](0, p), y: x[m](0, o)}} }), bG = a._path2curve = bt(function (a, b) { var c = bA(a), d = b && bA(b), e = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, f = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, g = function (a, b) { var c, d; if (!a) return ["C", b.x, b.y, b.x, b.y, b.x, b.y]; !(a[0] in { T: 1, Q: 1 }) && (b.qx = b.qy = null); switch (a[0]) { case "M": b.X = a[1], b.Y = a[2]; break; case "A": a = ["C"][n](bD[m](0, [b.x, b.y][n](a.slice(1)))); break; case "S": c = b.x + (b.x - (b.bx || b.x)), d = b.y + (b.y - (b.by || b.y)), a = ["C", c, d][n](a.slice(1)); break; case "T": b.qx = b.x + (b.x - (b.qx || b.x)), b.qy = b.y + (b.y - (b.qy || b.y)), a = ["C"][n](bC(b.x, b.y, b.qx, b.qy, a[1], a[2])); break; case "Q": b.qx = a[1], b.qy = a[2], a = ["C"][n](bC(b.x, b.y, a[1], a[2], a[3], a[4])); break; case "L": a = ["C"][n](bB(b.x, b.y, a[1], a[2])); break; case "H": a = ["C"][n](bB(b.x, b.y, a[1], b.y)); break; case "V": a = ["C"][n](bB(b.x, b.y, b.x, a[1])); break; case "Z": a = ["C"][n](bB(b.x, b.y, b.X, b.Y)) } return a }, h = function (a, b) { if (a[b].length > 7) { a[b].shift(); var e = a[b]; while (e.length) a.splice(b++, 0, ["C"][n](e.splice(0, 6))); a.splice(b, 1), k = x(c.length, d && d.length || 0) } }, i = function (a, b, e, f, g) { a && b && a[g][0] == "M" && b[g][0] != "M" && (b.splice(g, 0, ["M", f.x, f.y]), e.bx = 0, e.by = 0, e.x = a[g][1], e.y = a[g][2], k = x(c.length, d && d.length || 0)) }; for (var j = 0, k = x(c.length, d && d.length || 0); j < k; j++) { c[j] = g(c[j], e), h(c, j), d && (d[j] = g(d[j], f)), d && h(d, j), i(c, d, e, f, j), i(d, c, f, e, j); var l = c[j], o = d && d[j], p = l.length, q = d && o.length; e.x = l[p - 2], e.y = l[p - 1], e.bx = Q(l[p - 4]) || e.x, e.by = Q(l[p - 3]) || e.y, f.bx = d && (Q(o[q - 4]) || f.x), f.by = d && (Q(o[q - 3]) || f.y), f.x = d && o[q - 2], f.y = d && o[q - 1] } return d ? [c, d] : c }, null, by), bH = a._parseDots = bt(function (b) { var c = []; for (var d = 0, e = b.length; d < e; d++) { var f = {}, g = b[d].match(/^([^:]*):?([\d\.]*)/); f.color = a.getRGB(g[1]); if (f.color.error) return null; f.color = f.color.hex, g[2] && (f.offset = g[2] + "%"), c.push(f) } for (d = 1, e = c.length - 1; d < e; d++) if (!c[d].offset) { var h = Q(c[d - 1].offset || 0), i = 0; for (var j = d + 1; j < e; j++) if (c[j].offset) { i = c[j].offset; break } i || (i = 100, j = e), i = Q(i); var k = (i - h) / (j - d + 1); for (; d < j; d++) h += k, c[d].offset = h + "%" } return c }), bI = a._tear = function (a, b) { a == b.top && (b.top = a.prev), a == b.bottom && (b.bottom = a.next), a.next && (a.next.prev = a.prev), a.prev && (a.prev.next = a.next) }, bJ = a._tofront = function (a, b) { b.top !== a && (bI(a, b), a.next = null, a.prev = b.top, b.top.next = a, b.top = a) }, bK = a._toback = function (a, b) { b.bottom !== a && (bI(a, b), a.next = b.bottom, a.prev = null, b.bottom.prev = a, b.bottom = a) }, bL = a._insertafter = function (a, b, c) { bI(a, c), b == c.top && (c.top = a), b.next && (b.next.prev = a), a.next = b.next, a.prev = b, b.next = a }, bM = a._insertbefore = function (a, b, c) { bI(a, c), b == c.bottom && (c.bottom = a), b.prev && (b.prev.next = a), a.prev = b.prev, b.prev = a, a.next = b }, bN = a._extractTransform = function (b, c) { if (c == null) return b._.transform; c = r(c).replace(/\.{3}|\u2026/g, b._.transform || p); var d = a.parseTransformString(c), e = 0, f = 0, g = 0, h = 1, i = 1, j = b._, k = new bQ; j.transform = d || []; if (d) for (var l = 0, m = d.length; l < m; l++) { var n = d[l], o = n.length, q = r(n[0]).toLowerCase(), s = n[0] != q, t = s ? k.invert() : 0, u, v, w, x, y; q == "t" && o == 3 ? s ? (u = t.x(0, 0), v = t.y(0, 0), w = t.x(n[1], n[2]), x = t.y(n[1], n[2]), k.translate(w - u, x - v)) : k.translate(n[1], n[2]) : q == "r" ? o == 2 ? (y = y || b.getBBox(1), k.rotate(n[1], y.x + y.width / 2, y.y + y.height / 2), e += n[1]) : o == 4 && (s ? (w = t.x(n[2], n[3]), x = t.y(n[2], n[3]), k.rotate(n[1], w, x)) : k.rotate(n[1], n[2], n[3]), e += n[1]) : q == "s" ? o == 2 || o == 3 ? (y = y || b.getBBox(1), k.scale(n[1], n[o - 1], y.x + y.width / 2, y.y + y.height / 2), h *= n[1], i *= n[o - 1]) : o == 5 && (s ? (w = t.x(n[3], n[4]), x = t.y(n[3], n[4]), k.scale(n[1], n[2], w, x)) : k.scale(n[1], n[2], n[3], n[4]), h *= n[1], i *= n[2]) : q == "m" && o == 7 && k.add(n[1], n[2], n[3], n[4], n[5], n[6]), j.dirtyT = 1, b.matrix = k } b.matrix = k, j.sx = h, j.sy = i, j.deg = e, j.dx = f = k.e, j.dy = g = k.f, h == 1 && i == 1 && !e && j.bbox ? (j.bbox.x += +f, j.bbox.y += +g) : j.dirtyT = 1 }, bO = function (a) { var b = a[0]; switch (b.toLowerCase()) { case "t": return [b, 0, 0]; case "m": return [b, 1, 0, 0, 1, 0, 0]; case "r": return a.length == 4 ? [b, 0, a[2], a[3]] : [b, 0]; case "s": return a.length == 5 ? [b, 1, 1, a[3], a[4]] : a.length == 3 ? [b, 1, 1] : [b, 1] } }, bP = a._equaliseTransform = function (b, c) { c = r(c).replace(/\.{3}|\u2026/g, b), b = a.parseTransformString(b) || [], c = a.parseTransformString(c) || []; var d = x(b.length, c.length), e = [], f = [], g = 0, h, i, j, k; for (; g < d; g++) { j = b[g] || bO(c[g]), k = c[g] || bO(j); if (j[0] != k[0] || j[0].toLowerCase() == "r" && (j[2] != k[2] || j[3] != k[3]) || j[0].toLowerCase() == "s" && (j[3] != k[3] || j[4] != k[4])) return; e[g] = [], f[g] = []; for (h = 0, i = x(j.length, k.length); h < i; h++) h in j && (e[g][h] = j[h]), h in k && (f[g][h] = k[h]) } return { from: e, to: f} }; a._getContainer = function (b, c, d, e) { var f; f = e == null && !a.is(b, "object") ? h.doc.getElementById(b) : b; if (f != null) { if (f.tagName) return c == null ? { container: f, width: f.style.pixelWidth || f.offsetWidth, height: f.style.pixelHeight || f.offsetHeight} : { container: f, width: c, height: d }; return { container: 1, x: b, y: c, width: d, height: e} } }, a.pathToRelative = bz, a._engine = {}, a.path2curve = bG, a.matrix = function (a, b, c, d, e, f) { return new bQ(a, b, c, d, e, f) }, function (b) { function d(a) { var b = w.sqrt(c(a)); a[0] && (a[0] /= b), a[1] && (a[1] /= b) } function c(a) { return a[0] * a[0] + a[1] * a[1] } b.add = function (a, b, c, d, e, f) { var g = [[], [], []], h = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]], i = [[a, c, e], [b, d, f], [0, 0, 1]], j, k, l, m; a && a instanceof bQ && (i = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]]); for (j = 0; j < 3; j++) for (k = 0; k < 3; k++) { m = 0; for (l = 0; l < 3; l++) m += h[j][l] * i[l][k]; g[j][k] = m } this.a = g[0][0], this.b = g[1][0], this.c = g[0][1], this.d = g[1][1], this.e = g[0][2], this.f = g[1][2] }, b.invert = function () { var a = this, b = a.a * a.d - a.b * a.c; return new bQ(a.d / b, -a.b / b, -a.c / b, a.a / b, (a.c * a.f - a.d * a.e) / b, (a.b * a.e - a.a * a.f) / b) }, b.clone = function () { return new bQ(this.a, this.b, this.c, this.d, this.e, this.f) }, b.translate = function (a, b) { this.add(1, 0, 0, 1, a, b) }, b.scale = function (a, b, c, d) { b == null && (b = a), (c || d) && this.add(1, 0, 0, 1, c, d), this.add(a, 0, 0, b, 0, 0), (c || d) && this.add(1, 0, 0, 1, -c, -d) }, b.rotate = function (b, c, d) { b = a.rad(b), c = c || 0, d = d || 0; var e = +w.cos(b).toFixed(9), f = +w.sin(b).toFixed(9); this.add(e, f, -f, e, c, d), this.add(1, 0, 0, 1, -c, -d) }, b.x = function (a, b) { return a * this.a + b * this.c + this.e }, b.y = function (a, b) { return a * this.b + b * this.d + this.f }, b.get = function (a) { return +this[r.fromCharCode(97 + a)].toFixed(4) }, b.toString = function () { return a.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join() }, b.toFilter = function () { return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')" }, b.offset = function () { return [this.e.toFixed(4), this.f.toFixed(4)] }, b.split = function () { var b = {}; b.dx = this.e, b.dy = this.f; var e = [[this.a, this.c], [this.b, this.d]]; b.scalex = w.sqrt(c(e[0])), d(e[0]), b.shear = e[0][0] * e[1][0] + e[0][1] * e[1][1], e[1] = [e[1][0] - e[0][0] * b.shear, e[1][1] - e[0][1] * b.shear], b.scaley = w.sqrt(c(e[1])), d(e[1]), b.shear /= b.scaley; var f = -e[0][1], g = e[1][1]; g < 0 ? (b.rotate = a.deg(w.acos(g)), f < 0 && (b.rotate = 360 - b.rotate)) : b.rotate = a.deg(w.asin(f)), b.isSimple = ! +b.shear.toFixed(9) && (b.scalex.toFixed(9) == b.scaley.toFixed(9) || !b.rotate), b.isSuperSimple = ! +b.shear.toFixed(9) && b.scalex.toFixed(9) == b.scaley.toFixed(9) && !b.rotate, b.noRotation = ! +b.shear.toFixed(9) && !b.rotate; return b }, b.toTransformString = function (a) { var b = a || this[s](); if (b.isSimple) { b.scalex = +b.scalex.toFixed(4), b.scaley = +b.scaley.toFixed(4), b.rotate = +b.rotate.toFixed(4); return (b.dx && b.dy ? "t" + [b.dx, b.dy] : p) + (b.scalex != 1 || b.scaley != 1 ? "s" + [b.scalex, b.scaley, 0, 0] : p) + (b.rotate ? "r" + [b.rotate, 0, 0] : p) } return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)] } } (bQ.prototype); var bR = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/); navigator.vendor == "Apple Computer, Inc." && (bR && bR[1] < 4 || navigator.platform.slice(0, 2) == "iP") || navigator.vendor == "Google Inc." && bR && bR[1] < 8 ? k.safari = function () { var a = this.rect(-99, -99, this.width + 99, this.height + 99).attr({ stroke: "none" }); setTimeout(function () { a.remove() }) } : k.safari = bd; var bS = function () { this.returnValue = !1 }, bT = function () { return this.originalEvent.preventDefault() }, bU = function () { this.cancelBubble = !0 }, bV = function () { return this.originalEvent.stopPropagation() }, bW = function () { if (h.doc.addEventListener) return function (a, b, c, d) { var e = o && u[b] ? u[b] : b, f = function (e) { var f = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, i = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, j = e.clientX + i, k = e.clientY + f; if (o && u[g](b)) for (var l = 0, m = e.targetTouches && e.targetTouches.length; l < m; l++) if (e.targetTouches[l].target == a) { var n = e; e = e.targetTouches[l], e.originalEvent = n, e.preventDefault = bT, e.stopPropagation = bV; break } return c.call(d, e, j, k) }; a.addEventListener(e, f, !1); return function () { a.removeEventListener(e, f, !1); return !0 } }; if (h.doc.attachEvent) return function (a, b, c, d) { var e = function (a) { a = a || h.win.event; var b = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, e = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, f = a.clientX + e, g = a.clientY + b; a.preventDefault = a.preventDefault || bS, a.stopPropagation = a.stopPropagation || bU; return c.call(d, a, f, g) }; a.attachEvent("on" + b, e); var f = function () { a.detachEvent("on" + b, e); return !0 }; return f } } (), bX = [], bY = function (a) { var b = a.clientX, c = a.clientY, d = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, e = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, f, g = bX.length; while (g--) { f = bX[g]; if (o) { var i = a.touches.length, j; while (i--) { j = a.touches[i]; if (j.identifier == f.el._drag.id) { b = j.clientX, c = j.clientY, (a.originalEvent ? a.originalEvent : a).preventDefault(); break } } } else a.preventDefault(); var k = f.el.node, l, m = k.nextSibling, n = k.parentNode, p = k.style.display; h.win.opera && n.removeChild(k), k.style.display = "none", l = f.el.paper.getElementByPoint(b, c), k.style.display = p, h.win.opera && (m ? n.insertBefore(k, m) : n.appendChild(k)), l && eve("drag.over." + f.el.id, f.el, l), b += e, c += d, eve("drag.move." + f.el.id, f.move_scope || f.el, b - f.el._drag.x, c - f.el._drag.y, b, c, a) } }, bZ = function (b) { a.unmousemove(bY).unmouseup(bZ); var c = bX.length, d; while (c--) d = bX[c], d.el._drag = {}, eve("drag.end." + d.el.id, d.end_scope || d.start_scope || d.move_scope || d.el, b); bX = [] }, b$ = a.el = {}; for (var b_ = t.length; b_--; ) (function (b) { a[b] = b$[b] = function (c, d) { a.is(c, "function") && (this.events = this.events || [], this.events.push({ name: b, f: c, unbind: bW(this.shape || this.node || h.doc, b, c, d || this) })); return this }, a["un" + b] = b$["un" + b] = function (a) { var c = this.events, d = c.length; while (d--) if (c[d].name == b && c[d].f == a) { c[d].unbind(), c.splice(d, 1), !c.length && delete this.events; return this } return this } })(t[b_]); b$.data = function (b, c) { var d = ba[this.id] = ba[this.id] || {}; if (arguments.length == 1) { if (a.is(b, "object")) { for (var e in b) b[g](e) && this.data(e, b[e]); return this } eve("data.get." + this.id, this, d[b], b); return d[b] } d[b] = c, eve("data.set." + this.id, this, c, b); return this }, b$.removeData = function (a) { a == null ? ba[this.id] = {} : ba[this.id] && delete ba[this.id][a]; return this }, b$.hover = function (a, b, c, d) { return this.mouseover(a, c).mouseout(b, d || c) }, b$.unhover = function (a, b) { return this.unmouseover(a).unmouseout(b) }; var ca = []; b$.drag = function (b, c, d, e, f, g) { function i(i) { (i.originalEvent || i).preventDefault(); var j = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, k = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft; this._drag.x = i.clientX + k, this._drag.y = i.clientY + j, this._drag.id = i.identifier, !bX.length && a.mousemove(bY).mouseup(bZ), bX.push({ el: this, move_scope: e, start_scope: f, end_scope: g }), c && eve.on("drag.start." + this.id, c), b && eve.on("drag.move." + this.id, b), d && eve.on("drag.end." + this.id, d), eve("drag.start." + this.id, f || e || this, i.clientX + k, i.clientY + j, i) } this._drag = {}, ca.push({ el: this, start: i }), this.mousedown(i); return this }, b$.onDragOver = function (a) { a ? eve.on("drag.over." + this.id, a) : eve.unbind("drag.over." + this.id) }, b$.undrag = function () { var b = ca.length; while (b--) ca[b].el == this && (this.unmousedown(ca[b].start), ca.splice(b, 1), eve.unbind("drag.*." + this.id)); !ca.length && a.unmousemove(bY).unmouseup(bZ) }, k.circle = function (b, c, d) { var e = a._engine.circle(this, b || 0, c || 0, d || 0); this.__set__ && this.__set__.push(e); return e }, k.rect = function (b, c, d, e, f) { var g = a._engine.rect(this, b || 0, c || 0, d || 0, e || 0, f || 0); this.__set__ && this.__set__.push(g); return g }, k.ellipse = function (b, c, d, e) { var f = a._engine.ellipse(this, b || 0, c || 0, d || 0, e || 0); this.__set__ && this.__set__.push(f); return f }, k.path = function (b) { b && !a.is(b, D) && !a.is(b[0], E) && (b += p); var c = a._engine.path(a.format[m](a, arguments), this); this.__set__ && this.__set__.push(c); return c }, k.image = function (b, c, d, e, f) { var g = a._engine.image(this, b || "about:blank", c || 0, d || 0, e || 0, f || 0); this.__set__ && this.__set__.push(g); return g }, k.text = function (b, c, d) { var e = a._engine.text(this, b || 0, c || 0, r(d)); this.__set__ && this.__set__.push(e); return e }, k.set = function (b) { !a.is(b, "array") && (b = Array.prototype.splice.call(arguments, 0, arguments.length)); var c = new cs(b); this.__set__ && this.__set__.push(c); return c }, k.setStart = function (a) { this.__set__ = a || this.set() }, k.setFinish = function (a) { var b = this.__set__; delete this.__set__; return b }, k.setSize = function (b, c) { return a._engine.setSize.call(this, b, c) }, k.setViewBox = function (b, c, d, e, f) { return a._engine.setViewBox.call(this, b, c, d, e, f) }, k.top = k.bottom = null, k.raphael = a; var cb = function (a) { var b = a.getBoundingClientRect(), c = a.ownerDocument, d = c.body, e = c.documentElement, f = e.clientTop || d.clientTop || 0, g = e.clientLeft || d.clientLeft || 0, i = b.top + (h.win.pageYOffset || e.scrollTop || d.scrollTop) - f, j = b.left + (h.win.pageXOffset || e.scrollLeft || d.scrollLeft) - g; return { y: i, x: j} }; k.getElementByPoint = function (a, b) { var c = this, d = c.canvas, e = h.doc.elementFromPoint(a, b); if (h.win.opera && e.tagName == "svg") { var f = cb(d), g = d.createSVGRect(); g.x = a - f.x, g.y = b - f.y, g.width = g.height = 1; var i = d.getIntersectionList(g, null); i.length && (e = i[i.length - 1]) } if (!e) return null; while (e.parentNode && e != d.parentNode && !e.raphael) e = e.parentNode; e == c.canvas.parentNode && (e = d), e = e && e.raphael ? c.getById(e.raphaelid) : null; return e }, k.getById = function (a) { var b = this.bottom; while (b) { if (b.id == a) return b; b = b.next } return null }, k.forEach = function (a, b) { var c = this.bottom; while (c) { if (a.call(b, c) === !1) return this; c = c.next } return this }, b$.getBBox = function (a) { if (this.removed) return {}; var b = this._; if (a) { if (b.dirty || !b.bboxwt) this.realPath = bh[this.type](this), b.bboxwt = bx(this.realPath), b.bboxwt.toString = cd, b.dirty = 0; return b.bboxwt } if (b.dirty || b.dirtyT || !b.bbox) { if (b.dirty || !this.realPath) b.bboxwt = 0, this.realPath = bh[this.type](this); b.bbox = bx(bi(this.realPath, this.matrix)), b.bbox.toString = cd, b.dirty = b.dirtyT = 0 } return b.bbox }, b$.clone = function () { if (this.removed) return null; var a = this.paper[this.type]().attr(this.attr()); this.__set__ && this.__set__.push(a); return a }, b$.glow = function (a) { if (this.type == "text") return null; a = a || {}; var b = { width: (a.width || 10) + (+this.attr("stroke-width") || 1), fill: a.fill || !1, opacity: a.opacity || .5, offsetx: a.offsetx || 0, offsety: a.offsety || 0, color: a.color || "#000" }, c = b.width / 2, d = this.paper, e = d.set(), f = this.realPath || bh[this.type](this); f = this.matrix ? bi(f, this.matrix) : f; for (var g = 1; g < c + 1; g++) e.push(d.path(f).attr({ stroke: b.color, fill: b.fill ? b.color : "none", "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-width": +(b.width / c * g).toFixed(3), opacity: +(b.opacity / c).toFixed(3) })); return e.insertBefore(this).translate(b.offsetx, b.offsety) }; var ce = {}, cf = function (b, c, d, e, f, g, h, i, j) { var k = 0, l = 100, m = [b, c, d, e, f, g, h, i].join(), n = ce[m], o, p; !n && (ce[m] = n = { data: [] }), n.timer && clearTimeout(n.timer), n.timer = setTimeout(function () { delete ce[m] }, 2e3); if (j != null && !n.precision) { var q = cf(b, c, d, e, f, g, h, i); n.precision = ~ ~q * 10, n.data = [] } l = n.precision || l; for (var r = 0; r < l + 1; r++) { n.data[r * l] ? p = n.data[r * l] : (p = a.findDotsAtSegment(b, c, d, e, f, g, h, i, r / l), n.data[r * l] = p), r && (k += A(A(o.x - p.x, 2) + A(o.y - p.y, 2), .5)); if (j != null && k >= j) return p; o = p } if (j == null) return k }, cg = function (b, c) { return function (d, e, f) { d = bG(d); var g, h, i, j, k = "", l = {}, m, n = 0; for (var o = 0, p = d.length; o < p; o++) { i = d[o]; if (i[0] == "M") g = +i[1], h = +i[2]; else { j = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6]); if (n + j > e) { if (c && !l.start) { m = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6], e - n), k += ["C" + m.start.x, m.start.y, m.m.x, m.m.y, m.x, m.y]; if (f) return k; l.start = k, k = ["M" + m.x, m.y + "C" + m.n.x, m.n.y, m.end.x, m.end.y, i[5], i[6]].join(), n += j, g = +i[5], h = +i[6]; continue } if (!b && !c) { m = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6], e - n); return { x: m.x, y: m.y, alpha: m.alpha} } } n += j, g = +i[5], h = +i[6] } k += i.shift() + i } l.end = k, m = b ? n : c ? l : a.findDotsAtSegment(g, h, i[0], i[1], i[2], i[3], i[4], i[5], 1), m.alpha && (m = { x: m.x, y: m.y, alpha: m.alpha }); return m } }, ch = cg(1), ci = cg(), cj = cg(0, 1); a.getTotalLength = ch, a.getPointAtLength = ci, a.getSubpath = function (a, b, c) { if (this.getTotalLength(a) - c < 1e-6) return cj(a, b).end; var d = cj(a, c, 1); return b ? cj(d, b).end : d }, b$.getTotalLength = function () { if (this.type == "path") { if (this.node.getTotalLength) return this.node.getTotalLength(); return ch(this.attrs.path) } }, b$.getPointAtLength = function (a) { if (this.type == "path") return ci(this.attrs.path, a) }, b$.getSubpath = function (b, c) { if (this.type == "path") return a.getSubpath(this.attrs.path, b, c) }; var ck = a.easing_formulas = { linear: function (a) { return a }, "<": function (a) { return A(a, 1.7) }, ">": function (a) { return A(a, .48) }, "<>": function (a) { var b = .48 - a / 1.04, c = w.sqrt(.1734 + b * b), d = c - b, e = A(z(d), 1 / 3) * (d < 0 ? -1 : 1), f = -c - b, g = A(z(f), 1 / 3) * (f < 0 ? -1 : 1), h = e + g + .5; return (1 - h) * 3 * h * h + h * h * h }, backIn: function (a) { var b = 1.70158; return a * a * ((b + 1) * a - b) }, backOut: function (a) { a = a - 1; var b = 1.70158; return a * a * ((b + 1) * a + b) + 1 }, elastic: function (a) { if (a == !!a) return a; return A(2, -10 * a) * w.sin((a - .075) * 2 * B / .3) + 1 }, bounce: function (a) { var b = 7.5625, c = 2.75, d; a < 1 / c ? d = b * a * a : a < 2 / c ? (a -= 1.5 / c, d = b * a * a + .75) : a < 2.5 / c ? (a -= 2.25 / c, d = b * a * a + .9375) : (a -= 2.625 / c, d = b * a * a + .984375); return d } }; ck.easeIn = ck["ease-in"] = ck["<"], ck.easeOut = ck["ease-out"] = ck[">"], ck.easeInOut = ck["ease-in-out"] = ck["<>"], ck["back-in"] = ck.backIn, ck["back-out"] = ck.backOut; var cl = [], cm = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { setTimeout(a, 16) }, cn = function () { var b = +(new Date), c = 0; for (; c < cl.length; c++) { var d = cl[c]; if (d.el.removed || d.paused) continue; var e = b - d.start, f = d.ms, h = d.easing, i = d.from, j = d.diff, k = d.to, l = d.t, m = d.el, o = {}, p, r = {}, s; d.initstatus ? (e = (d.initstatus * d.anim.top - d.prev) / (d.percent - d.prev) * f, d.status = d.initstatus, delete d.initstatus, d.stop && cl.splice(c--, 1)) : d.status = (d.prev + (d.percent - d.prev) * (e / f)) / d.anim.top; if (e < 0) continue; if (e < f) { var t = h(e / f); for (var u in i) if (i[g](u)) { switch (U[u]) { case C: p = +i[u] + t * f * j[u]; break; case "colour": p = "rgb(" + [co(O(i[u].r + t * f * j[u].r)), co(O(i[u].g + t * f * j[u].g)), co(O(i[u].b + t * f * j[u].b))].join(",") + ")"; break; case "path": p = []; for (var v = 0, w = i[u].length; v < w; v++) { p[v] = [i[u][v][0]]; for (var x = 1, y = i[u][v].length; x < y; x++) p[v][x] = +i[u][v][x] + t * f * j[u][v][x]; p[v] = p[v].join(q) } p = p.join(q); break; case "transform": if (j[u].real) { p = []; for (v = 0, w = i[u].length; v < w; v++) { p[v] = [i[u][v][0]]; for (x = 1, y = i[u][v].length; x < y; x++) p[v][x] = i[u][v][x] + t * f * j[u][v][x] } } else { var z = function (a) { return +i[u][a] + t * f * j[u][a] }; p = [["m", z(0), z(1), z(2), z(3), z(4), z(5)]] } break; case "csv": if (u == "clip-rect") { p = [], v = 4; while (v--) p[v] = +i[u][v] + t * f * j[u][v] } break; default: var A = [][n](i[u]); p = [], v = m.paper.customAttributes[u].length; while (v--) p[v] = +A[v] + t * f * j[u][v] } o[u] = p } m.attr(o), function (a, b, c) { setTimeout(function () { eve("anim.frame." + a, b, c) }) } (m.id, m, d.anim) } else { (function (b, c, d) { setTimeout(function () { eve("anim.frame." + c.id, c, d), eve("anim.finish." + c.id, c, d), a.is(b, "function") && b.call(c) }) })(d.callback, m, d.anim), m.attr(k), cl.splice(c--, 1); if (d.repeat > 1 && !d.next) { for (s in k) k[g](s) && (r[s] = d.totalOrigin[s]); d.el.attr(r), cr(d.anim, d.el, d.anim.percents[0], null, d.totalOrigin, d.repeat - 1) } d.next && !d.stop && cr(d.anim, d.el, d.next, null, d.totalOrigin, d.repeat) } } a.svg && m && m.paper && m.paper.safari(), cl.length && cm(cn) }, co = function (a) { return a > 255 ? 255 : a < 0 ? 0 : a }; b$.animateWith = function (b, c, d, e, f, g) { var h = d ? a.animation(d, e, f, g) : c, i = b.status(c); return this.animate(h).status(h, i * c.ms / h.ms) }, b$.onAnimation = function (a) { a ? eve.on("anim.frame." + this.id, a) : eve.unbind("anim.frame." + this.id); return this }, cq.prototype.delay = function (a) { var b = new cq(this.anim, this.ms); b.times = this.times, b.del = +a || 0; return b }, cq.prototype.repeat = function (a) { var b = new cq(this.anim, this.ms); b.del = this.del, b.times = w.floor(x(a, 0)) || 1; return b }, a.animation = function (b, c, d, e) { if (b instanceof cq) return b; if (a.is(d, "function") || !d) e = e || d || null, d = null; b = Object(b), c = +c || 0; var f = {}, h, i; for (i in b) b[g](i) && Q(i) != i && Q(i) + "%" != i && (h = !0, f[i] = b[i]); if (!h) return new cq(b, c); d && (f.easing = d), e && (f.callback = e); return new cq({ 100: f }, c) }, b$.animate = function (b, c, d, e) { var f = this; if (f.removed) { e && e.call(f); return f } var g = b instanceof cq ? b : a.animation(b, c, d, e); cr(g, f, g.percents[0], null, f.attr()); return f }, b$.setTime = function (a, b) { a && b != null && this.status(a, y(b, a.ms) / a.ms); return this }, b$.status = function (a, b) { var c = [], d = 0, e, f; if (b != null) { cr(a, this, -1, y(b, 1)); return this } e = cl.length; for (; d < e; d++) { f = cl[d]; if (f.el.id == this.id && (!a || f.anim == a)) { if (a) return f.status; c.push({ anim: f.anim, status: f.status }) } } if (a) return 0; return c }, b$.pause = function (a) { for (var b = 0; b < cl.length; b++) cl[b].el.id == this.id && (!a || cl[b].anim == a) && eve("anim.pause." + this.id, this, cl[b].anim) !== !1 && (cl[b].paused = !0); return this }, b$.resume = function (a) { for (var b = 0; b < cl.length; b++) if (cl[b].el.id == this.id && (!a || cl[b].anim == a)) { var c = cl[b]; eve("anim.resume." + this.id, this, c.anim) !== !1 && (delete c.paused, this.status(c.anim, c.status)) } return this }, b$.stop = function (a) { for (var b = 0; b < cl.length; b++) cl[b].el.id == this.id && (!a || cl[b].anim == a) && eve("anim.stop." + this.id, this, cl[b].anim) !== !1 && cl.splice(b--, 1); return this }, b$.toString = function () { return "Raphaël’s object" }; var cs = function (a) { this.items = [], this.length = 0, this.type = "set"; if (a) for (var b = 0, c = a.length; b < c; b++) a[b] && (a[b].constructor == b$.constructor || a[b].constructor == cs) && (this[this.items.length] = this.items[this.items.length] = a[b], this.length++) }, ct = cs.prototype; ct.push = function () { var a, b; for (var c = 0, d = arguments.length; c < d; c++) a = arguments[c], a && (a.constructor == b$.constructor || a.constructor == cs) && (b = this.items.length, this[b] = this.items[b] = a, this.length++); return this }, ct.pop = function () { this.length && delete this[this.length--]; return this.items.pop() }, ct.forEach = function (a, b) { for (var c = 0, d = this.items.length; c < d; c++) if (a.call(b, this.items[c], c) === !1) return this; return this }; for (var cu in b$) b$[g](cu) && (ct[cu] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a][m](c, b) }) } } (cu)); ct.attr = function (b, c) { if (b && a.is(b, E) && a.is(b[0], "object")) for (var d = 0, e = b.length; d < e; d++) this.items[d].attr(b[d]); else for (var f = 0, g = this.items.length; f < g; f++) this.items[f].attr(b, c); return this }, ct.clear = function () { while (this.length) this.pop() }, ct.splice = function (a, b, c) { a = a < 0 ? x(this.length + a, 0) : a, b = x(0, y(this.length - a, b)); var d = [], e = [], f = [], g; for (g = 2; g < arguments.length; g++) f.push(arguments[g]); for (g = 0; g < b; g++) e.push(this[a + g]); for (; g < this.length - a; g++) d.push(this[a + g]); var h = f.length; for (g = 0; g < h + d.length; g++) this.items[a + g] = this[a + g] = g < h ? f[g] : d[g - h]; g = this.items.length = this.length -= b - h; while (this[g]) delete this[g++]; return new cs(e) }, ct.exclude = function (a) { for (var b = 0, c = this.length; b < c; b++) if (this[b] == a) { this.splice(b, 1); return !0 } }, ct.animate = function (b, c, d, e) { (a.is(d, "function") || !d) && (e = d || null); var f = this.items.length, g = f, h, i = this, j; if (!f) return this; e && (j = function () { ! --f && e.call(i) }), d = a.is(d, D) ? d : j; var k = a.animation(b, c, d, j); h = this.items[--g].animate(k); while (g--) this.items[g] && !this.items[g].removed && this.items[g].animateWith(h, k); return this }, ct.insertAfter = function (a) { var b = this.items.length; while (b--) this.items[b].insertAfter(a); return this }, ct.getBBox = function () { var a = [], b = [], c = [], d = []; for (var e = this.items.length; e--; ) if (!this.items[e].removed) { var f = this.items[e].getBBox(); a.push(f.x), b.push(f.y), c.push(f.x + f.width), d.push(f.y + f.height) } a = y[m](0, a), b = y[m](0, b); return { x: a, y: b, width: x[m](0, c) - a, height: x[m](0, d) - b} }, ct.clone = function (a) { a = new cs; for (var b = 0, c = this.items.length; b < c; b++) a.push(this.items[b].clone()); return a }, ct.toString = function () { return "Raphaël‘s set" }, a.registerFont = function (a) { if (!a.face) return a; this.fonts = this.fonts || {}; var b = { w: a.w, face: {}, glyphs: {} }, c = a.face["font-family"]; for (var d in a.face) a.face[g](d) && (b.face[d] = a.face[d]); this.fonts[c] ? this.fonts[c].push(b) : this.fonts[c] = [b]; if (!a.svg) { b.face["units-per-em"] = R(a.face["units-per-em"], 10); for (var e in a.glyphs) if (a.glyphs[g](e)) { var f = a.glyphs[e]; b.glyphs[e] = { w: f.w, k: {}, d: f.d && "M" + f.d.replace(/[mlcxtrv]/g, function (a) { return { l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[a] || "M" }) + "z" }; if (f.k) for (var h in f.k) f[g](h) && (b.glyphs[e].k[h] = f.k[h]) } } return a }, k.getFont = function (b, c, d, e) { e = e || "normal", d = d || "normal", c = +c || { normal: 400, bold: 700, lighter: 300, bolder: 800}[c] || 400; if (!!a.fonts) { var f = a.fonts[b]; if (!f) { var h = new RegExp("(^|\\s)" + b.replace(/[^\w\d\s+!~.:_-]/g, p) + "(\\s|$)", "i"); for (var i in a.fonts) if (a.fonts[g](i) && h.test(i)) { f = a.fonts[i]; break } } var j; if (f) for (var k = 0, l = f.length; k < l; k++) { j = f[k]; if (j.face["font-weight"] == c && (j.face["font-style"] == d || !j.face["font-style"]) && j.face["font-stretch"] == e) break } return j } }, k.print = function (b, d, e, f, g, h, i) { h = h || "middle", i = x(y(i || 0, 1), -1); var j = this.set(), k = r(e)[s](p), l = 0, m = p, n; a.is(f, e) && (f = this.getFont(f)); if (f) { n = (g || 16) / f.face["units-per-em"]; var o = f.face.bbox[s](c), q = +o[0], t = +o[1] + (h == "baseline" ? o[3] - o[1] + +f.face.descent : (o[3] - o[1]) / 2); for (var u = 0, v = k.length; u < v; u++) { var w = u && f.glyphs[k[u - 1]] || {}, z = f.glyphs[k[u]]; l += u ? (w.w || f.w) + (w.k && w.k[k[u]] || 0) + f.w * i : 0, z && z.d && j.push(this.path(z.d).attr({ fill: "#000", stroke: "none", transform: [["t", l * n, 0]] })) } j.transform(["...s", n, n, q, t, "t", (b - q) / n, (d - t) / n]) } return j }, k.add = function (b) { if (a.is(b, "array")) { var c = this.set(), e = 0, f = b.length, h; for (; e < f; e++) h = b[e] || {}, d[g](h.type) && c.push(this[h.type]().attr(h)) } return c }, a.format = function (b, c) { var d = a.is(c, E) ? [0][n](c) : arguments; b && a.is(b, D) && d.length - 1 && (b = b.replace(e, function (a, b) { return d[++b] == null ? p : d[b] })); return b || p }, a.fullfill = function () { var a = /\{([^\}]+)\}/g, b = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, c = function (a, c, d) { var e = d; c.replace(b, function (a, b, c, d, f) { b = b || d, e && (b in e && (e = e[b]), typeof e == "function" && f && (e = e())) }), e = (e == null || e == d ? a : e) + ""; return e }; return function (b, d) { return String(b).replace(a, function (a, b) { return c(a, b, d) }) } } (), a.ninja = function () { i.was ? h.win.Raphael = i.is : delete Raphael; return a }, a.st = ct, function (b, c, d) { function e() { /in/.test(b.readyState) ? setTimeout(e, 9) : a.eve("DOMload") } b.readyState == null && b.addEventListener && (b.addEventListener(c, d = function () { b.removeEventListener(c, d, !1), b.readyState = "complete" }, !1), b.readyState = "loading"), e() } (document, "DOMContentLoaded"), i.was ? h.win.Raphael = a : Raphael = a, eve.on("DOMload", function () { b = !0 }) } (), window.Raphael.svg && function (a) { var b = "hasOwnProperty", c = String, d = parseFloat, e = parseInt, f = Math, g = f.max, h = f.abs, i = f.pow, j = /[, ]+/, k = a.eve, l = "", m = " ", n = "http://www.w3.org/1999/xlink", o = { block: "M5,0 0,2.5 5,5z", classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z", diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z", open: "M6,1 1,3.5 6,6", oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z" }, p = {}; a.toString = function () { return "Your browser supports SVG.\nYou are running Raphaël " + this.version }; var q = function (d, e) { if (e) { typeof d == "string" && (d = q(d)); for (var f in e) e[b](f) && (f.substring(0, 6) == "xlink:" ? d.setAttributeNS(n, f.substring(6), c(e[f])) : d.setAttribute(f, c(e[f]))) } else d = a._g.doc.createElementNS("http://www.w3.org/2000/svg", d), d.style && (d.style.webkitTapHighlightColor = "rgba(0,0,0,0)"); return d }, r = function (b, e) { var j = "linear", k = b.id + e, m = .5, n = .5, o = b.node, p = b.paper, r = o.style, s = a._g.doc.getElementById(k); if (!s) { e = c(e).replace(a._radial_gradient, function (a, b, c) { j = "radial"; if (b && c) { m = d(b), n = d(c); var e = (n > .5) * 2 - 1; i(m - .5, 2) + i(n - .5, 2) > .25 && (n = f.sqrt(.25 - i(m - .5, 2)) * e + .5) && n != .5 && (n = n.toFixed(5) - 1e-5 * e) } return l }), e = e.split(/\s*\-\s*/); if (j == "linear") { var t = e.shift(); t = -d(t); if (isNaN(t)) return null; var u = [0, 0, f.cos(a.rad(t)), f.sin(a.rad(t))], v = 1 / (g(h(u[2]), h(u[3])) || 1); u[2] *= v, u[3] *= v, u[2] < 0 && (u[0] = -u[2], u[2] = 0), u[3] < 0 && (u[1] = -u[3], u[3] = 0) } var w = a._parseDots(e); if (!w) return null; k = k.replace(/[\(\)\s,\xb0#]/g, "_"), b.gradient && k != b.gradient.id && (p.defs.removeChild(b.gradient), delete b.gradient); if (!b.gradient) { s = q(j + "Gradient", { id: k }), b.gradient = s, q(s, j == "radial" ? { fx: m, fy: n} : { x1: u[0], y1: u[1], x2: u[2], y2: u[3], gradientTransform: b.matrix.invert() }), p.defs.appendChild(s); for (var x = 0, y = w.length; x < y; x++) s.appendChild(q("stop", { offset: w[x].offset ? w[x].offset : x ? "100%" : "0%", "stop-color": w[x].color || "#fff" })) } } q(o, { fill: "url(#" + k + ")", opacity: 1, "fill-opacity": 1 }), r.fill = l, r.opacity = 1, r.fillOpacity = 1; return 1 }, s = function (a) { var b = a.getBBox(1); q(a.pattern, { patternTransform: a.matrix.invert() + " translate(" + b.x + "," + b.y + ")" }) }, t = function (d, e, f) { if (d.type == "path") { var g = c(e).toLowerCase().split("-"), h = d.paper, i = f ? "end" : "start", j = d.node, k = d.attrs, l = k["stroke-width"], n = g.length, r = "classic", s, t, u, v, w, x = 3, y = 3, z = 5; while (n--) switch (g[n]) { case "block": case "classic": case "oval": case "diamond": case "open": case "none": r = g[n]; break; case "wide": y = 5; break; case "narrow": y = 2; break; case "long": x = 5; break; case "short": x = 2 } r == "open" ? (x += 2, y += 2, z += 2, u = 1, v = f ? 4 : 1, w = { fill: "none", stroke: k.stroke }) : (v = u = x / 2, w = { fill: k.stroke, stroke: "none" }), d._.arrows ? f ? (d._.arrows.endPath && p[d._.arrows.endPath]--, d._.arrows.endMarker && p[d._.arrows.endMarker]--) : (d._.arrows.startPath && p[d._.arrows.startPath]--, d._.arrows.startMarker && p[d._.arrows.startMarker]--) : d._.arrows = {}; if (r != "none") { var A = "raphael-marker-" + r, B = "raphael-marker-" + i + r + x + y; a._g.doc.getElementById(A) ? p[A]++ : (h.defs.appendChild(q(q("path"), { "stroke-linecap": "round", d: o[r], id: A })), p[A] = 1); var C = a._g.doc.getElementById(B), D; C ? (p[B]++, D = C.getElementsByTagName("use")[0]) : (C = q(q("marker"), { id: B, markerHeight: y, markerWidth: x, orient: "auto", refX: v, refY: y / 2 }), D = q(q("use"), { "xlink:href": "#" + A, transform: (f ? " rotate(180 " + x / 2 + " " + y / 2 + ") " : m) + "scale(" + x / z + "," + y / z + ")", "stroke-width": 1 / ((x / z + y / z) / 2) }), C.appendChild(D), h.defs.appendChild(C), p[B] = 1), q(D, w); var E = u * (r != "diamond" && r != "oval"); f ? (s = d._.arrows.startdx * l || 0, t = a.getTotalLength(k.path) - E * l) : (s = E * l, t = a.getTotalLength(k.path) - (d._.arrows.enddx * l || 0)), w = {}, w["marker-" + i] = "url(#" + B + ")"; if (t || s) w.d = Raphael.getSubpath(k.path, s, t); q(j, w), d._.arrows[i + "Path"] = A, d._.arrows[i + "Marker"] = B, d._.arrows[i + "dx"] = E, d._.arrows[i + "Type"] = r, d._.arrows[i + "String"] = e } else f ? (s = d._.arrows.startdx * l || 0, t = a.getTotalLength(k.path) - s) : (s = 0, t = a.getTotalLength(k.path) - (d._.arrows.enddx * l || 0)), d._.arrows[i + "Path"] && q(j, { d: Raphael.getSubpath(k.path, s, t) }), delete d._.arrows[i + "Path"], delete d._.arrows[i + "Marker"], delete d._.arrows[i + "dx"], delete d._.arrows[i + "Type"], delete d._.arrows[i + "String"]; for (w in p) if (p[b](w) && !p[w]) { var F = a._g.doc.getElementById(w); F && F.parentNode.removeChild(F) } } }, u = { "": [0], none: [0], "-": [3, 1], ".": [1, 1], "-.": [3, 1, 1, 1], "-..": [3, 1, 1, 1, 1, 1], ". ": [1, 3], "- ": [4, 3], "--": [8, 3], "- .": [4, 3, 1, 3], "--.": [8, 3, 1, 3], "--..": [8, 3, 1, 3, 1, 3] }, v = function (a, b, d) { b = u[c(b).toLowerCase()]; if (b) { var e = a.attrs["stroke-width"] || "1", f = { round: e, square: e, butt: 0}[a.attrs["stroke-linecap"] || d["stroke-linecap"]] || 0, g = [], h = b.length; while (h--) g[h] = b[h] * e + (h % 2 ? 1 : -1) * f; q(a.node, { "stroke-dasharray": g.join(",") }) } }, w = function (d, f) { var i = d.node, k = d.attrs, m = i.style.visibility; i.style.visibility = "hidden"; for (var o in f) if (f[b](o)) { if (!a._availableAttrs[b](o)) continue; var p = f[o]; k[o] = p; switch (o) { case "blur": d.blur(p); break; case "href": case "title": case "target": var u = i.parentNode; if (u.tagName.toLowerCase() != "a") { var w = q("a"); u.insertBefore(w, i), w.appendChild(i), u = w } o == "target" && p == "blank" ? u.setAttributeNS(n, "show", "new") : u.setAttributeNS(n, o, p); break; case "cursor": i.style.cursor = p; break; case "transform": d.transform(p); break; case "arrow-start": t(d, p); break; case "arrow-end": t(d, p, 1); break; case "clip-rect": var x = c(p).split(j); if (x.length == 4) { d.clip && d.clip.parentNode.parentNode.removeChild(d.clip.parentNode); var z = q("clipPath"), A = q("rect"); z.id = a.createUUID(), q(A, { x: x[0], y: x[1], width: x[2], height: x[3] }), z.appendChild(A), d.paper.defs.appendChild(z), q(i, { "clip-path": "url(#" + z.id + ")" }), d.clip = A } if (!p) { var B = i.getAttribute("clip-path"); if (B) { var C = a._g.doc.getElementById(B.replace(/(^url\(#|\)$)/g, l)); C && C.parentNode.removeChild(C), q(i, { "clip-path": l }), delete d.clip } } break; case "path": d.type == "path" && (q(i, { d: p ? k.path = a._pathToAbsolute(p) : "M0,0" }), d._.dirty = 1, d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1))); break; case "width": i.setAttribute(o, p), d._.dirty = 1; if (k.fx) o = "x", p = k.x; else break; case "x": k.fx && (p = -k.x - (k.width || 0)); case "rx": if (o == "rx" && d.type == "rect") break; case "cx": i.setAttribute(o, p), d.pattern && s(d), d._.dirty = 1; break; case "height": i.setAttribute(o, p), d._.dirty = 1; if (k.fy) o = "y", p = k.y; else break; case "y": k.fy && (p = -k.y - (k.height || 0)); case "ry": if (o == "ry" && d.type == "rect") break; case "cy": i.setAttribute(o, p), d.pattern && s(d), d._.dirty = 1; break; case "r": d.type == "rect" ? q(i, { rx: p, ry: p }) : i.setAttribute(o, p), d._.dirty = 1; break; case "src": d.type == "image" && i.setAttributeNS(n, "href", p); break; case "stroke-width": if (d._.sx != 1 || d._.sy != 1) p /= g(h(d._.sx), h(d._.sy)) || 1; d.paper._vbSize && (p *= d.paper._vbSize), i.setAttribute(o, p), k["stroke-dasharray"] && v(d, k["stroke-dasharray"], f), d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1)); break; case "stroke-dasharray": v(d, p, f); break; case "fill": var D = c(p).match(a._ISURL); if (D) { z = q("pattern"); var F = q("image"); z.id = a.createUUID(), q(z, { x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1 }), q(F, { x: 0, y: 0, "xlink:href": D[1] }), z.appendChild(F), function (b) { a._preload(D[1], function () { var a = this.offsetWidth, c = this.offsetHeight; q(b, { width: a, height: c }), q(F, { width: a, height: c }), d.paper.safari() }) } (z), d.paper.defs.appendChild(z), i.style.fill = "url(#" + z.id + ")", q(i, { fill: "url(#" + z.id + ")" }), d.pattern = z, d.pattern && s(d); break } var G = a.getRGB(p); if (!G.error) delete f.gradient, delete k.gradient, !a.is(k.opacity, "undefined") && a.is(f.opacity, "undefined") && q(i, { opacity: k.opacity }), !a.is(k["fill-opacity"], "undefined") && a.is(f["fill-opacity"], "undefined") && q(i, { "fill-opacity": k["fill-opacity"] }); else if ((d.type == "circle" || d.type == "ellipse" || c(p).charAt() != "r") && r(d, p)) { if ("opacity" in k || "fill-opacity" in k) { var H = a._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, l)); if (H) { var I = H.getElementsByTagName("stop"); q(I[I.length - 1], { "stop-opacity": ("opacity" in k ? k.opacity : 1) * ("fill-opacity" in k ? k["fill-opacity"] : 1) }) } } k.gradient = p, k.fill = "none"; break } G[b]("opacity") && q(i, { "fill-opacity": G.opacity > 1 ? G.opacity / 100 : G.opacity }); case "stroke": G = a.getRGB(p), i.setAttribute(o, G.hex), o == "stroke" && G[b]("opacity") && q(i, { "stroke-opacity": G.opacity > 1 ? G.opacity / 100 : G.opacity }), o == "stroke" && d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1)); break; case "gradient": (d.type == "circle" || d.type == "ellipse" || c(p).charAt() != "r") && r(d, p); break; case "opacity": k.gradient && !k[b]("stroke-opacity") && q(i, { "stroke-opacity": p > 1 ? p / 100 : p }); case "fill-opacity": if (k.gradient) { H = a._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, l)), H && (I = H.getElementsByTagName("stop"), q(I[I.length - 1], { "stop-opacity": p })); break }; default: o == "font-size" && (p = e(p, 10) + "px"); var J = o.replace(/(\-.)/g, function (a) { return a.substring(1).toUpperCase() }); i.style[J] = p, d._.dirty = 1, i.setAttribute(o, p) } } y(d, f), i.style.visibility = m }, x = 1.2, y = function (d, f) { if (d.type == "text" && !!(f[b]("text") || f[b]("font") || f[b]("font-size") || f[b]("x") || f[b]("y"))) { var g = d.attrs, h = d.node, i = h.firstChild ? e(a._g.doc.defaultView.getComputedStyle(h.firstChild, l).getPropertyValue("font-size"), 10) : 10; if (f[b]("text")) { g.text = f.text; while (h.firstChild) h.removeChild(h.firstChild); var j = c(f.text).split("\n"), k = [], m; for (var n = 0, o = j.length; n < o; n++) m = q("tspan"), n && q(m, { dy: i * x, x: g.x }), m.appendChild(a._g.doc.createTextNode(j[n])), h.appendChild(m), k[n] = m } else { k = h.getElementsByTagName("tspan"); for (n = 0, o = k.length; n < o; n++) n ? q(k[n], { dy: i * x, x: g.x }) : q(k[0], { dy: 0 }) } q(h, { x: g.x, y: g.y }), d._.dirty = 1; var p = d._getBBox(), r = g.y - (p.y + p.height / 2); r && a.is(r, "finite") && q(k[0], { dy: r }) } }, z = function (b, c) { var d = 0, e = 0; this[0] = this.node = b, b.raphael = !0, this.id = a._oid++, b.raphaelid = this.id, this.matrix = a.matrix(), this.realPath = null, this.paper = c, this.attrs = this.attrs || {}, this._ = { transform: [], sx: 1, sy: 1, deg: 0, dx: 0, dy: 0, dirty: 1 }, !c.bottom && (c.bottom = this), this.prev = c.top, c.top && (c.top.next = this), c.top = this, this.next = null }, A = a.el; z.prototype = A, A.constructor = z, a._engine.path = function (a, b) { var c = q("path"); b.canvas && b.canvas.appendChild(c); var d = new z(c, b); d.type = "path", w(d, { fill: "none", stroke: "#000", path: a }); return d }, A.rotate = function (a, b, e) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1]), e = d(a[2])), a = d(a[0]), e == null && (b = e); if (b == null || e == null) { var f = this.getBBox(1); b = f.x + f.width / 2, e = f.y + f.height / 2 } this.transform(this._.transform.concat([["r", a, b, e]])); return this }, A.scale = function (a, b, e, f) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1]), e = d(a[2]), f = d(a[3])), a = d(a[0]), b == null && (b = a), f == null && (e = f); if (e == null || f == null) var g = this.getBBox(1); e = e == null ? g.x + g.width / 2 : e, f = f == null ? g.y + g.height / 2 : f, this.transform(this._.transform.concat([["s", a, b, e, f]])); return this }, A.translate = function (a, b) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1])), a = d(a[0]) || 0, b = +b || 0, this.transform(this._.transform.concat([["t", a, b]])); return this }, A.transform = function (c) { var d = this._; if (c == null) return d.transform; a._extractTransform(this, c), this.clip && q(this.clip, { transform: this.matrix.invert() }), this.pattern && s(this), this.node && q(this.node, { transform: this.matrix }); if (d.sx != 1 || d.sy != 1) { var e = this.attrs[b]("stroke-width") ? this.attrs["stroke-width"] : 1; this.attr({ "stroke-width": e }) } return this }, A.hide = function () { !this.removed && this.paper.safari(this.node.style.display = "none"); return this }, A.show = function () { !this.removed && this.paper.safari(this.node.style.display = ""); return this }, A.remove = function () { if (!this.removed) { var b = this.paper; b.__set__ && b.__set__.exclude(this), k.unbind("*.*." + this.id), this.gradient && b.defs.removeChild(this.gradient), a._tear(this, b), this.node.parentNode.removeChild(this.node); for (var c in this) this[c] = typeof this[c] == "function" ? a._removedFactory(c) : null; this.removed = !0 } }, A._getBBox = function () { if (this.node.style.display == "none") { this.show(); var a = !0 } var b = {}; try { b = this.node.getBBox() } catch (c) { } finally { b = b || {} } a && this.hide(); return b }, A.attr = function (c, d) { if (this.removed) return this; if (c == null) { var e = {}; for (var f in this.attrs) this.attrs[b](f) && (e[f] = this.attrs[f]); e.gradient && e.fill == "none" && (e.fill = e.gradient) && delete e.gradient, e.transform = this._.transform; return e } if (d == null && a.is(c, "string")) { if (c == "fill" && this.attrs.fill == "none" && this.attrs.gradient) return this.attrs.gradient; if (c == "transform") return this._.transform; var g = c.split(j), h = {}; for (var i = 0, l = g.length; i < l; i++) c = g[i], c in this.attrs ? h[c] = this.attrs[c] : a.is(this.paper.customAttributes[c], "function") ? h[c] = this.paper.customAttributes[c].def : h[c] = a._availableAttrs[c]; return l - 1 ? h : h[g[0]] } if (d == null && a.is(c, "array")) { h = {}; for (i = 0, l = c.length; i < l; i++) h[c[i]] = this.attr(c[i]); return h } if (d != null) { var m = {}; m[c] = d } else c != null && a.is(c, "object") && (m = c); for (var n in m) k("attr." + n + "." + this.id, this, m[n]); for (n in this.paper.customAttributes) if (this.paper.customAttributes[b](n) && m[b](n) && a.is(this.paper.customAttributes[n], "function")) { var o = this.paper.customAttributes[n].apply(this, [].concat(m[n])); this.attrs[n] = m[n]; for (var p in o) o[b](p) && (m[p] = o[p]) } w(this, m); return this }, A.toFront = function () { if (this.removed) return this; this.node.parentNode.tagName.toLowerCase() == "a" ? this.node.parentNode.parentNode.appendChild(this.node.parentNode) : this.node.parentNode.appendChild(this.node); var b = this.paper; b.top != this && a._tofront(this, b); return this }, A.toBack = function () { if (this.removed) return this; var b = this.node.parentNode; b.tagName.toLowerCase() == "a" ? b.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild) : b.firstChild != this.node && b.insertBefore(this.node, this.node.parentNode.firstChild), a._toback(this, this.paper); var c = this.paper; return this }, A.insertAfter = function (b) { if (this.removed) return this; var c = b.node || b[b.length - 1].node; c.nextSibling ? c.parentNode.insertBefore(this.node, c.nextSibling) : c.parentNode.appendChild(this.node), a._insertafter(this, b, this.paper); return this }, A.insertBefore = function (b) { if (this.removed) return this; var c = b.node || b[0].node; c.parentNode.insertBefore(this.node, c), a._insertbefore(this, b, this.paper); return this }, A.blur = function (b) { var c = this; if (+b !== 0) { var d = q("filter"), e = q("feGaussianBlur"); c.attrs.blur = b, d.id = a.createUUID(), q(e, { stdDeviation: +b || 1.5 }), d.appendChild(e), c.paper.defs.appendChild(d), c._blur = d, q(c.node, { filter: "url(#" + d.id + ")" }) } else c._blur && (c._blur.parentNode.removeChild(c._blur), delete c._blur, delete c.attrs.blur), c.node.removeAttribute("filter") }, a._engine.circle = function (a, b, c, d) { var e = q("circle"); a.canvas && a.canvas.appendChild(e); var f = new z(e, a); f.attrs = { cx: b, cy: c, r: d, fill: "none", stroke: "#000" }, f.type = "circle", q(e, f.attrs); return f }, a._engine.rect = function (a, b, c, d, e, f) { var g = q("rect"); a.canvas && a.canvas.appendChild(g); var h = new z(g, a); h.attrs = { x: b, y: c, width: d, height: e, r: f || 0, rx: f || 0, ry: f || 0, fill: "none", stroke: "#000" }, h.type = "rect", q(g, h.attrs); return h }, a._engine.ellipse = function (a, b, c, d, e) { var f = q("ellipse"); a.canvas && a.canvas.appendChild(f); var g = new z(f, a); g.attrs = { cx: b, cy: c, rx: d, ry: e, fill: "none", stroke: "#000" }, g.type = "ellipse", q(f, g.attrs); return g }, a._engine.image = function (a, b, c, d, e, f) { var g = q("image"); q(g, { x: c, y: d, width: e, height: f, preserveAspectRatio: "none" }), g.setAttributeNS(n, "href", b), a.canvas && a.canvas.appendChild(g); var h = new z(g, a); h.attrs = { x: c, y: d, width: e, height: f, src: b }, h.type = "image"; return h }, a._engine.text = function (b, c, d, e) { var f = q("text"); b.canvas && b.canvas.appendChild(f); var g = new z(f, b); g.attrs = { x: c, y: d, "text-anchor": "middle", text: e, font: a._availableAttrs.font, stroke: "none", fill: "#000" }, g.type = "text", w(g, g.attrs); return g }, a._engine.setSize = function (a, b) { this.width = a || this.width, this.height = b || this.height, this.canvas.setAttribute("width", this.width), this.canvas.setAttribute("height", this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox); return this }, a._engine.create = function () { var b = a._getContainer.apply(0, arguments), c = b && b.container, d = b.x, e = b.y, f = b.width, g = b.height; if (!c) throw new Error("SVG container not found."); var h = q("svg"), i = "overflow:hidden;", j; d = d || 0, e = e || 0, f = f || 512, g = g || 342, q(h, { height: g, version: 1.1, width: f, xmlns: "http://www.w3.org/2000/svg" }), c == 1 ? (h.style.cssText = i + "position:absolute;left:" + d + "px;top:" + e + "px", a._g.doc.body.appendChild(h), j = 1) : (h.style.cssText = i + "position:relative", c.firstChild ? c.insertBefore(h, c.firstChild) : c.appendChild(h)), c = new a._Paper, c.width = f, c.height = g, c.canvas = h, c.clear(), c._left = c._top = 0, j && (c.renderfix = function () { }), c.renderfix(); return c }, a._engine.setViewBox = function (a, b, c, d, e) { k("setViewBox", this, this._viewBox, [a, b, c, d, e]); var f = g(c / this.width, d / this.height), h = this.top, i = e ? "meet" : "xMinYMin", j, l; a == null ? (this._vbSize && (f = 1), delete this._vbSize, j = "0 0 " + this.width + m + this.height) : (this._vbSize = f, j = a + m + b + m + c + m + d), q(this.canvas, { viewBox: j, preserveAspectRatio: i }); while (f && h) l = "stroke-width" in h.attrs ? h.attrs["stroke-width"] : 1, h.attr({ "stroke-width": l }), h._.dirty = 1, h._.dirtyT = 1, h = h.prev; this._viewBox = [a, b, c, d, !!e]; return this }, a.prototype.renderfix = function () { var a = this.canvas, b = a.style, c; try { c = a.getScreenCTM() || a.createSVGMatrix() } catch (d) { c = a.createSVGMatrix() } var e = -c.e % 1, f = -c.f % 1; if (e || f) e && (this._left = (this._left + e) % 1, b.left = this._left + "px"), f && (this._top = (this._top + f) % 1, b.top = this._top + "px") }, a.prototype.clear = function () { a.eve("clear", this); var b = this.canvas; while (b.firstChild) b.removeChild(b.firstChild); this.bottom = this.top = null, (this.desc = q("desc")).appendChild(a._g.doc.createTextNode("Created with Raphaël " + a.version)), b.appendChild(this.desc), b.appendChild(this.defs = q("defs")) }, a.prototype.remove = function () { k("remove", this), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null }; var B = a.st; for (var C in A) A[b](C) && !B[b](C) && (B[C] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (C)) } (window.Raphael), window.Raphael.vml && function (a) { var b = "hasOwnProperty", c = String, d = parseFloat, e = Math, f = e.round, g = e.max, h = e.min, i = e.abs, j = "fill", k = /[, ]+/, l = a.eve, m = " progid:DXImageTransform.Microsoft", n = " ", o = "", p = { M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x" }, q = /([clmz]),?([^clmz]*)/gi, r = / progid:\S+Blur\([^\)]+\)/g, s = /-?[^,\s-]+/g, t = "position:absolute;left:0;top:0;width:1px;height:1px", u = 21600, v = { path: 1, rect: 1, image: 1 }, w = { circle: 1, ellipse: 1 }, x = function (b) { var d = /[ahqstv]/ig, e = a._pathToAbsolute; c(b).match(d) && (e = a._path2curve), d = /[clmz]/g; if (e == a._pathToAbsolute && !c(b).match(d)) { var g = c(b).replace(q, function (a, b, c) { var d = [], e = b.toLowerCase() == "m", g = p[b]; c.replace(s, function (a) { e && d.length == 2 && (g += d + p[b == "m" ? "l" : "L"], d = []), d.push(f(a * u)) }); return g + d }); return g } var h = e(b), i, j; g = []; for (var k = 0, l = h.length; k < l; k++) { i = h[k], j = h[k][0].toLowerCase(), j == "z" && (j = "x"); for (var m = 1, r = i.length; m < r; m++) j += f(i[m] * u) + (m != r - 1 ? "," : o); g.push(j) } return g.join(n) }, y = function (b, c, d) { var e = a.matrix(); e.rotate(-b, .5, .5); return { dx: e.x(c, d), dy: e.y(c, d)} }, z = function (a, b, c, d, e, f) { var g = a._, h = a.matrix, k = g.fillpos, l = a.node, m = l.style, o = 1, p = "", q, r = u / b, s = u / c; m.visibility = "hidden"; if (!!b && !!c) { l.coordsize = i(r) + n + i(s), m.rotation = f * (b * c < 0 ? -1 : 1); if (f) { var t = y(f, d, e); d = t.dx, e = t.dy } b < 0 && (p += "x"), c < 0 && (p += " y") && (o = -1), m.flip = p, l.coordorigin = d * -r + n + e * -s; if (k || g.fillsize) { var v = l.getElementsByTagName(j); v = v && v[0], l.removeChild(v), k && (t = y(f, h.x(k[0], k[1]), h.y(k[0], k[1])), v.position = t.dx * o + n + t.dy * o), g.fillsize && (v.size = g.fillsize[0] * i(b) + n + g.fillsize[1] * i(c)), l.appendChild(v) } m.visibility = "visible" } }; a.toString = function () { return "Your browser doesn’t support SVG. Falling down to VML.\nYou are running Raphaël " + this.version }; var A = function (a, b, d) { var e = c(b).toLowerCase().split("-"), f = d ? "end" : "start", g = e.length, h = "classic", i = "medium", j = "medium"; while (g--) switch (e[g]) { case "block": case "classic": case "oval": case "diamond": case "open": case "none": h = e[g]; break; case "wide": case "narrow": j = e[g]; break; case "long": case "short": i = e[g] } var k = a.node.getElementsByTagName("stroke")[0]; k[f + "arrow"] = h, k[f + "arrowlength"] = i, k[f + "arrowwidth"] = j }, B = function (e, i) { e.attrs = e.attrs || {}; var l = e.node, m = e.attrs, p = l.style, q, r = v[e.type] && (i.x != m.x || i.y != m.y || i.width != m.width || i.height != m.height || i.cx != m.cx || i.cy != m.cy || i.rx != m.rx || i.ry != m.ry || i.r != m.r), s = w[e.type] && (m.cx != i.cx || m.cy != i.cy || m.r != i.r || m.rx != i.rx || m.ry != i.ry), t = e; for (var y in i) i[b](y) && (m[y] = i[y]); r && (m.path = a._getPath[e.type](e), e._.dirty = 1), i.href && (l.href = i.href), i.title && (l.title = i.title), i.target && (l.target = i.target), i.cursor && (p.cursor = i.cursor), "blur" in i && e.blur(i.blur); if (i.path && e.type == "path" || r) l.path = x(~c(m.path).toLowerCase().indexOf("r") ? a._pathToAbsolute(m.path) : m.path), e.type == "image" && (e._.fillpos = [m.x, m.y], e._.fillsize = [m.width, m.height], z(e, 1, 1, 0, 0, 0)); "transform" in i && e.transform(i.transform); if (s) { var B = +m.cx, D = +m.cy, E = +m.rx || +m.r || 0, G = +m.ry || +m.r || 0; l.path = a.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", f((B - E) * u), f((D - G) * u), f((B + E) * u), f((D + G) * u), f(B * u)) } if ("clip-rect" in i) { var H = c(i["clip-rect"]).split(k); if (H.length == 4) { H[2] = +H[2] + +H[0], H[3] = +H[3] + +H[1]; var I = l.clipRect || a._g.doc.createElement("div"), J = I.style; J.clip = a.format("rect({1}px {2}px {3}px {0}px)", H), l.clipRect || (J.position = "absolute", J.top = 0, J.left = 0, J.width = e.paper.width + "px", J.height = e.paper.height + "px", l.parentNode.insertBefore(I, l), I.appendChild(l), l.clipRect = I) } i["clip-rect"] || l.clipRect && (l.clipRect.style.clip = "auto") } if (e.textpath) { var K = e.textpath.style; i.font && (K.font = i.font), i["font-family"] && (K.fontFamily = '"' + i["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, o) + '"'), i["font-size"] && (K.fontSize = i["font-size"]), i["font-weight"] && (K.fontWeight = i["font-weight"]), i["font-style"] && (K.fontStyle = i["font-style"]) } "arrow-start" in i && A(t, i["arrow-start"]), "arrow-end" in i && A(t, i["arrow-end"], 1); if (i.opacity != null || i["stroke-width"] != null || i.fill != null || i.src != null || i.stroke != null || i["stroke-width"] != null || i["stroke-opacity"] != null || i["fill-opacity"] != null || i["stroke-dasharray"] != null || i["stroke-miterlimit"] != null || i["stroke-linejoin"] != null || i["stroke-linecap"] != null) { var L = l.getElementsByTagName(j), M = !1; L = L && L[0], !L && (M = L = F(j)), e.type == "image" && i.src && (L.src = i.src), i.fill && (L.on = !0); if (L.on == null || i.fill == "none" || i.fill === null) L.on = !1; if (L.on && i.fill) { var N = c(i.fill).match(a._ISURL); if (N) { L.parentNode == l && l.removeChild(L), L.rotate = !0, L.src = N[1], L.type = "tile"; var O = e.getBBox(1); L.position = O.x + n + O.y, e._.fillpos = [O.x, O.y], a._preload(N[1], function () { e._.fillsize = [this.offsetWidth, this.offsetHeight] }) } else L.color = a.getRGB(i.fill).hex, L.src = o, L.type = "solid", a.getRGB(i.fill).error && (t.type in { circle: 1, ellipse: 1} || c(i.fill).charAt() != "r") && C(t, i.fill, L) && (m.fill = "none", m.gradient = i.fill, L.rotate = !1) } if ("fill-opacity" in i || "opacity" in i) { var P = ((+m["fill-opacity"] + 1 || 2) - 1) * ((+m.opacity + 1 || 2) - 1) * ((+a.getRGB(i.fill).o + 1 || 2) - 1); P = h(g(P, 0), 1), L.opacity = P, L.src && (L.color = "none") } l.appendChild(L); var Q = l.getElementsByTagName("stroke") && l.getElementsByTagName("stroke")[0], T = !1; !Q && (T = Q = F("stroke")); if (i.stroke && i.stroke != "none" || i["stroke-width"] || i["stroke-opacity"] != null || i["stroke-dasharray"] || i["stroke-miterlimit"] || i["stroke-linejoin"] || i["stroke-linecap"]) Q.on = !0; (i.stroke == "none" || i.stroke === null || Q.on == null || i.stroke == 0 || i["stroke-width"] == 0) && (Q.on = !1); var U = a.getRGB(i.stroke); Q.on && i.stroke && (Q.color = U.hex), P = ((+m["stroke-opacity"] + 1 || 2) - 1) * ((+m.opacity + 1 || 2) - 1) * ((+U.o + 1 || 2) - 1); var V = (d(i["stroke-width"]) || 1) * .75; P = h(g(P, 0), 1), i["stroke-width"] == null && (V = m["stroke-width"]), i["stroke-width"] && (Q.weight = V), V && V < 1 && (P *= V) && (Q.weight = 1), Q.opacity = P, i["stroke-linejoin"] && (Q.joinstyle = i["stroke-linejoin"] || "miter"), Q.miterlimit = i["stroke-miterlimit"] || 8, i["stroke-linecap"] && (Q.endcap = i["stroke-linecap"] == "butt" ? "flat" : i["stroke-linecap"] == "square" ? "square" : "round"); if (i["stroke-dasharray"]) { var W = { "-": "shortdash", ".": "shortdot", "-.": "shortdashdot", "-..": "shortdashdotdot", ". ": "dot", "- ": "dash", "--": "longdash", "- .": "dashdot", "--.": "longdashdot", "--..": "longdashdotdot" }; Q.dashstyle = W[b](i["stroke-dasharray"]) ? W[i["stroke-dasharray"]] : o } T && l.appendChild(Q) } if (t.type == "text") { t.paper.canvas.style.display = o; var X = t.paper.span, Y = 100, Z = m.font && m.font.match(/\d+(?:\.\d*)?(?=px)/); p = X.style, m.font && (p.font = m.font), m["font-family"] && (p.fontFamily = m["font-family"]), m["font-weight"] && (p.fontWeight = m["font-weight"]), m["font-style"] && (p.fontStyle = m["font-style"]), Z = d(m["font-size"] || Z && Z[0]) || 10, p.fontSize = Z * Y + "px", t.textpath.string && (X.innerHTML = c(t.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>")); var $ = X.getBoundingClientRect(); t.W = m.w = ($.right - $.left) / Y, t.H = m.h = ($.bottom - $.top) / Y, t.X = m.x, t.Y = m.y + t.H / 2, ("x" in i || "y" in i) && (t.path.v = a.format("m{0},{1}l{2},{1}", f(m.x * u), f(m.y * u), f(m.x * u) + 1)); var _ = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"]; for (var ba = 0, bb = _.length; ba < bb; ba++) if (_[ba] in i) { t._.dirty = 1; break } switch (m["text-anchor"]) { case "start": t.textpath.style["v-text-align"] = "left", t.bbx = t.W / 2; break; case "end": t.textpath.style["v-text-align"] = "right", t.bbx = -t.W / 2; break; default: t.textpath.style["v-text-align"] = "center", t.bbx = 0 } t.textpath.style["v-text-kern"] = !0 } }, C = function (b, f, g) { b.attrs = b.attrs || {}; var h = b.attrs, i = Math.pow, j, k, l = "linear", m = ".5 .5"; b.attrs.gradient = f, f = c(f).replace(a._radial_gradient, function (a, b, c) { l = "radial", b && c && (b = d(b), c = d(c), i(b - .5, 2) + i(c - .5, 2) > .25 && (c = e.sqrt(.25 - i(b - .5, 2)) * ((c > .5) * 2 - 1) + .5), m = b + n + c); return o }), f = f.split(/\s*\-\s*/); if (l == "linear") { var p = f.shift(); p = -d(p); if (isNaN(p)) return null } var q = a._parseDots(f); if (!q) return null; b = b.shape || b.node; if (q.length) { b.removeChild(g), g.on = !0, g.method = "none", g.color = q[0].color, g.color2 = q[q.length - 1].color; var r = []; for (var s = 0, t = q.length; s < t; s++) q[s].offset && r.push(q[s].offset + n + q[s].color); g.colors = r.length ? r.join() : "0% " + g.color, l == "radial" ? (g.type = "gradientTitle", g.focus = "100%", g.focussize = "0 0", g.focusposition = m, g.angle = 0) : (g.type = "gradient", g.angle = (270 - p) % 360), b.appendChild(g) } return 1 }, D = function (b, c) { this[0] = this.node = b, b.raphael = !0, this.id = a._oid++, b.raphaelid = this.id, this.X = 0, this.Y = 0, this.attrs = {}, this.paper = c, this.matrix = a.matrix(), this._ = { transform: [], sx: 1, sy: 1, dx: 0, dy: 0, deg: 0, dirty: 1, dirtyT: 1 }, !c.bottom && (c.bottom = this), this.prev = c.top, c.top && (c.top.next = this), c.top = this, this.next = null }, E = a.el; D.prototype = E, E.constructor = D, E.transform = function (b) { if (b == null) return this._.transform; var d = this.paper._viewBoxShift, e = d ? "s" + [d.scale, d.scale] + "-1-1t" + [d.dx, d.dy] : o, f; d && (f = b = c(b).replace(/\.{3}|\u2026/g, this._.transform || o)), a._extractTransform(this, e + b); var g = this.matrix.clone(), h = this.skew, i = this.node, j, k = ~c(this.attrs.fill).indexOf("-"), l = !c(this.attrs.fill).indexOf("url("); g.translate(-0.5, -0.5); if (l || k || this.type == "image") { h.matrix = "1 0 0 1", h.offset = "0 0", j = g.split(); if (k && j.noRotation || !j.isSimple) { i.style.filter = g.toFilter(); var m = this.getBBox(), p = this.getBBox(1), q = m.x - p.x, r = m.y - p.y; i.coordorigin = q * -u + n + r * -u, z(this, 1, 1, q, r, 0) } else i.style.filter = o, z(this, j.scalex, j.scaley, j.dx, j.dy, j.rotate) } else i.style.filter = o, h.matrix = c(g), h.offset = g.offset(); f && (this._.transform = f); return this }, E.rotate = function (a, b, e) { if (this.removed) return this; if (a != null) { a = c(a).split(k), a.length - 1 && (b = d(a[1]), e = d(a[2])), a = d(a[0]), e == null && (b = e); if (b == null || e == null) { var f = this.getBBox(1); b = f.x + f.width / 2, e = f.y + f.height / 2 } this._.dirtyT = 1, this.transform(this._.transform.concat([["r", a, b, e]])); return this } }, E.translate = function (a, b) { if (this.removed) return this; a = c(a).split(k), a.length - 1 && (b = d(a[1])), a = d(a[0]) || 0, b = +b || 0, this._.bbox && (this._.bbox.x += a, this._.bbox.y += b), this.transform(this._.transform.concat([["t", a, b]])); return this }, E.scale = function (a, b, e, f) { if (this.removed) return this; a = c(a).split(k), a.length - 1 && (b = d(a[1]), e = d(a[2]), f = d(a[3]), isNaN(e) && (e = null), isNaN(f) && (f = null)), a = d(a[0]), b == null && (b = a), f == null && (e = f); if (e == null || f == null) var g = this.getBBox(1); e = e == null ? g.x + g.width / 2 : e, f = f == null ? g.y + g.height / 2 : f, this.transform(this._.transform.concat([["s", a, b, e, f]])), this._.dirtyT = 1; return this }, E.hide = function () { !this.removed && (this.node.style.display = "none"); return this }, E.show = function () { !this.removed && (this.node.style.display = o); return this }, E._getBBox = function () { if (this.removed) return {}; return { x: this.X + (this.bbx || 0) - this.W / 2, y: this.Y - this.H, width: this.W, height: this.H} }, E.remove = function () { if (!this.removed) { this.paper.__set__ && this.paper.__set__.exclude(this), a.eve.unbind("*.*." + this.id), a._tear(this, this.paper), this.node.parentNode.removeChild(this.node), this.shape && this.shape.parentNode.removeChild(this.shape); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null; this.removed = !0 } }, E.attr = function (c, d) { if (this.removed) return this; if (c == null) { var e = {}; for (var f in this.attrs) this.attrs[b](f) && (e[f] = this.attrs[f]); e.gradient && e.fill == "none" && (e.fill = e.gradient) && delete e.gradient, e.transform = this._.transform; return e } if (d == null && a.is(c, "string")) { if (c == j && this.attrs.fill == "none" && this.attrs.gradient) return this.attrs.gradient; var g = c.split(k), h = {}; for (var i = 0, m = g.length; i < m; i++) c = g[i], c in this.attrs ? h[c] = this.attrs[c] : a.is(this.paper.customAttributes[c], "function") ? h[c] = this.paper.customAttributes[c].def : h[c] = a._availableAttrs[c]; return m - 1 ? h : h[g[0]] } if (this.attrs && d == null && a.is(c, "array")) { h = {}; for (i = 0, m = c.length; i < m; i++) h[c[i]] = this.attr(c[i]); return h } var n; d != null && (n = {}, n[c] = d), d == null && a.is(c, "object") && (n = c); for (var o in n) l("attr." + o + "." + this.id, this, n[o]); if (n) { for (o in this.paper.customAttributes) if (this.paper.customAttributes[b](o) && n[b](o) && a.is(this.paper.customAttributes[o], "function")) { var p = this.paper.customAttributes[o].apply(this, [].concat(n[o])); this.attrs[o] = n[o]; for (var q in p) p[b](q) && (n[q] = p[q]) } n.text && this.type == "text" && (this.textpath.string = n.text), B(this, n) } return this }, E.toFront = function () { !this.removed && this.node.parentNode.appendChild(this.node), this.paper && this.paper.top != this && a._tofront(this, this.paper); return this }, E.toBack = function () { if (this.removed) return this; this.node.parentNode.firstChild != this.node && (this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild), a._toback(this, this.paper)); return this }, E.insertAfter = function (b) { if (this.removed) return this; b.constructor == a.st.constructor && (b = b[b.length - 1]), b.node.nextSibling ? b.node.parentNode.insertBefore(this.node, b.node.nextSibling) : b.node.parentNode.appendChild(this.node), a._insertafter(this, b, this.paper); return this }, E.insertBefore = function (b) { if (this.removed) return this; b.constructor == a.st.constructor && (b = b[0]), b.node.parentNode.insertBefore(this.node, b.node), a._insertbefore(this, b, this.paper); return this }, E.blur = function (b) { var c = this.node.runtimeStyle, d = c.filter; d = d.replace(r, o), +b !== 0 ? (this.attrs.blur = b, c.filter = d + n + m + ".Blur(pixelradius=" + (+b || 1.5) + ")", c.margin = a.format("-{0}px 0 0 -{0}px", f(+b || 1.5))) : (c.filter = d, c.margin = 0, delete this.attrs.blur) }, a._engine.path = function (a, b) { var c = F("shape"); c.style.cssText = t, c.coordsize = u + n + u, c.coordorigin = b.coordorigin; var d = new D(c, b), e = { fill: "none", stroke: "#000" }; a && (e.path = a), d.type = "path", d.path = [], d.Path = o, B(d, e), b.canvas.appendChild(c); var f = F("skew"); f.on = !0, c.appendChild(f), d.skew = f, d.transform(o); return d }, a._engine.rect = function (b, c, d, e, f, g) { var h = a._rectPath(c, d, e, f, g), i = b.path(h), j = i.attrs; i.X = j.x = c, i.Y = j.y = d, i.W = j.width = e, i.H = j.height = f, j.r = g, j.path = h, i.type = "rect"; return i }, a._engine.ellipse = function (a, b, c, d, e) { var f = a.path(), g = f.attrs; f.X = b - d, f.Y = c - e, f.W = d * 2, f.H = e * 2, f.type = "ellipse", B(f, { cx: b, cy: c, rx: d, ry: e }); return f }, a._engine.circle = function (a, b, c, d) { var e = a.path(), f = e.attrs; e.X = b - d, e.Y = c - d, e.W = e.H = d * 2, e.type = "circle", B(e, { cx: b, cy: c, r: d }); return e }, a._engine.image = function (b, c, d, e, f, g) { var h = a._rectPath(d, e, f, g), i = b.path(h).attr({ stroke: "none" }), k = i.attrs, l = i.node, m = l.getElementsByTagName(j)[0]; k.src = c, i.X = k.x = d, i.Y = k.y = e, i.W = k.width = f, i.H = k.height = g, k.path = h, i.type = "image", m.parentNode == l && l.removeChild(m), m.rotate = !0, m.src = c, m.type = "tile", i._.fillpos = [d, e], i._.fillsize = [f, g], l.appendChild(m), z(i, 1, 1, 0, 0, 0); return i }, a._engine.text = function (b, d, e, g) { var h = F("shape"), i = F("path"), j = F("textpath"); d = d || 0, e = e || 0, g = g || "", i.v = a.format("m{0},{1}l{2},{1}", f(d * u), f(e * u), f(d * u) + 1), i.textpathok = !0, j.string = c(g), j.on = !0, h.style.cssText = t, h.coordsize = u + n + u, h.coordorigin = "0 0"; var k = new D(h, b), l = { fill: "#000", stroke: "none", font: a._availableAttrs.font, text: g }; k.shape = h, k.path = i, k.textpath = j, k.type = "text", k.attrs.text = c(g), k.attrs.x = d, k.attrs.y = e, k.attrs.w = 1, k.attrs.h = 1, B(k, l), h.appendChild(j), h.appendChild(i), b.canvas.appendChild(h); var m = F("skew"); m.on = !0, h.appendChild(m), k.skew = m, k.transform(o); return k }, a._engine.setSize = function (b, c) { var d = this.canvas.style; this.width = b, this.height = c, b == +b && (b += "px"), c == +c && (c += "px"), d.width = b, d.height = c, d.clip = "rect(0 " + b + " " + c + " 0)", this._viewBox && a._engine.setViewBox.apply(this, this._viewBox); return this }, a._engine.setViewBox = function (b, c, d, e, f) { a.eve("setViewBox", this, this._viewBox, [b, c, d, e, f]); var h = this.width, i = this.height, j = 1 / g(d / h, e / i), k, l; f && (k = i / e, l = h / d, d * k < h && (b -= (h - d * k) / 2 / k), e * l < i && (c -= (i - e * l) / 2 / l)), this._viewBox = [b, c, d, e, !!f], this._viewBoxShift = { dx: -b, dy: -c, scale: j }, this.forEach(function (a) { a.transform("...") }); return this }; var F; a._engine.initWin = function (a) { var b = a.document; b.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)"); try { !b.namespaces.rvml && b.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"), F = function (a) { return b.createElement("<rvml:" + a + ' class="rvml">') } } catch (c) { F = function (a) { return b.createElement("<" + a + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">') } } }, a._engine.initWin(a._g.win), a._engine.create = function () { var b = a._getContainer.apply(0, arguments), c = b.container, d = b.height, e, f = b.width, g = b.x, h = b.y; if (!c) throw new Error("VML container not found."); var i = new a._Paper, j = i.canvas = a._g.doc.createElement("div"), k = j.style; g = g || 0, h = h || 0, f = f || 512, d = d || 342, i.width = f, i.height = d, f == +f && (f += "px"), d == +d && (d += "px"), i.coordsize = u * 1e3 + n + u * 1e3, i.coordorigin = "0 0", i.span = a._g.doc.createElement("span"), i.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;", j.appendChild(i.span), k.cssText = a.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", f, d), c == 1 ? (a._g.doc.body.appendChild(j), k.left = g + "px", k.top = h + "px", k.position = "absolute") : c.firstChild ? c.insertBefore(j, c.firstChild) : c.appendChild(j), i.renderfix = function () { }; return i }, a.prototype.clear = function () { a.eve("clear", this), this.canvas.innerHTML = o, this.span = a._g.doc.createElement("span"), this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;", this.canvas.appendChild(this.span), this.bottom = this.top = null }, a.prototype.remove = function () { a.eve("remove", this), this.canvas.parentNode.removeChild(this.canvas); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null; return !0 }; var G = a.st; for (var H in E) E[b](H) && !G[b](H) && (G[H] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (H)) } (window.Raphael);
/*! jQuery UI - v1.9.2 - 2012-12-14
* http://jqueryui.com
* Includes: jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

jQuery.effects||function(e,t){var n=e.uiBackCompat!==!1,r="ui-effects-";e.effects={effect:{}},function(t,n){function p(e,t,n){var r=a[t.type]||{};return e==null?n||!t.def?null:t.def:(e=r.floor?~~e:parseFloat(e),isNaN(e)?t.def:r.mod?(e+r.mod)%r.mod:0>e?0:r.max<e?r.max:e)}function d(e){var n=o(),r=n._rgba=[];return e=e.toLowerCase(),h(s,function(t,i){var s,o=i.re.exec(e),a=o&&i.parse(o),f=i.space||"rgba";if(a)return s=n[f](a),n[u[f].cache]=s[u[f].cache],r=n._rgba=s._rgba,!1}),r.length?(r.join()==="0,0,0,0"&&t.extend(r,c.transparent),n):c[e]}function v(e,t,n){return n=(n+1)%1,n*6<1?e+(t-e)*n*6:n*2<1?t:n*3<2?e+(t-e)*(2/3-n)*6:e}var r="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),i=/^([\-+])=\s*(\d+\.?\d*)/,s=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1]*2.55,e[2]*2.55,e[3]*2.55,e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],o=t.Color=function(e,n,r,i){return new t.Color.fn.parse(e,n,r,i)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},a={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},f=o.support={},l=t("<p>")[0],c,h=t.each;l.style.cssText="background-color:rgba(1,1,1,.5)",f.rgba=l.style.backgroundColor.indexOf("rgba")>-1,h(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),o.fn=t.extend(o.prototype,{parse:function(r,i,s,a){if(r===n)return this._rgba=[null,null,null,null],this;if(r.jquery||r.nodeType)r=t(r).css(i),i=n;var f=this,l=t.type(r),v=this._rgba=[];i!==n&&(r=[r,i,s,a],l="array");if(l==="string")return this.parse(d(r)||c._default);if(l==="array")return h(u.rgba.props,function(e,t){v[t.idx]=p(r[t.idx],t)}),this;if(l==="object")return r instanceof o?h(u,function(e,t){r[t.cache]&&(f[t.cache]=r[t.cache].slice())}):h(u,function(t,n){var i=n.cache;h(n.props,function(e,t){if(!f[i]&&n.to){if(e==="alpha"||r[e]==null)return;f[i]=n.to(f._rgba)}f[i][t.idx]=p(r[e],t,!0)}),f[i]&&e.inArray(null,f[i].slice(0,3))<0&&(f[i][3]=1,n.from&&(f._rgba=n.from(f[i])))}),this},is:function(e){var t=o(e),n=!0,r=this;return h(u,function(e,i){var s,o=t[i.cache];return o&&(s=r[i.cache]||i.to&&i.to(r._rgba)||[],h(i.props,function(e,t){if(o[t.idx]!=null)return n=o[t.idx]===s[t.idx],n})),n}),n},_space:function(){var e=[],t=this;return h(u,function(n,r){t[r.cache]&&e.push(n)}),e.pop()},transition:function(e,t){var n=o(e),r=n._space(),i=u[r],s=this.alpha()===0?o("transparent"):this,f=s[i.cache]||i.to(s._rgba),l=f.slice();return n=n[i.cache],h(i.props,function(e,r){var i=r.idx,s=f[i],o=n[i],u=a[r.type]||{};if(o===null)return;s===null?l[i]=o:(u.mod&&(o-s>u.mod/2?s+=u.mod:s-o>u.mod/2&&(s-=u.mod)),l[i]=p((o-s)*t+s,r))}),this[r](l)},blend:function(e){if(this._rgba[3]===1)return this;var n=this._rgba.slice(),r=n.pop(),i=o(e)._rgba;return o(t.map(n,function(e,t){return(1-r)*i[t]+r*e}))},toRgbaString:function(){var e="rgba(",n=t.map(this._rgba,function(e,t){return e==null?t>2?1:0:e});return n[3]===1&&(n.pop(),e="rgb("),e+n.join()+")"},toHslaString:function(){var e="hsla(",n=t.map(this.hsla(),function(e,t){return e==null&&(e=t>2?1:0),t&&t<3&&(e=Math.round(e*100)+"%"),e});return n[3]===1&&(n.pop(),e="hsl("),e+n.join()+")"},toHexString:function(e){var n=this._rgba.slice(),r=n.pop();return e&&n.push(~~(r*255)),"#"+t.map(n,function(e){return e=(e||0).toString(16),e.length===1?"0"+e:e}).join("")},toString:function(){return this._rgba[3]===0?"transparent":this.toRgbaString()}}),o.fn.parse.prototype=o.fn,u.hsla.to=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/255,n=e[1]/255,r=e[2]/255,i=e[3],s=Math.max(t,n,r),o=Math.min(t,n,r),u=s-o,a=s+o,f=a*.5,l,c;return o===s?l=0:t===s?l=60*(n-r)/u+360:n===s?l=60*(r-t)/u+120:l=60*(t-n)/u+240,f===0||f===1?c=f:f<=.5?c=u/a:c=u/(2-a),[Math.round(l)%360,c,f,i==null?1:i]},u.hsla.from=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/360,n=e[1],r=e[2],i=e[3],s=r<=.5?r*(1+n):r+n-r*n,o=2*r-s;return[Math.round(v(o,s,t+1/3)*255),Math.round(v(o,s,t)*255),Math.round(v(o,s,t-1/3)*255),i]},h(u,function(e,r){var s=r.props,u=r.cache,a=r.to,f=r.from;o.fn[e]=function(e){a&&!this[u]&&(this[u]=a(this._rgba));if(e===n)return this[u].slice();var r,i=t.type(e),l=i==="array"||i==="object"?e:arguments,c=this[u].slice();return h(s,function(e,t){var n=l[i==="object"?e:t.idx];n==null&&(n=c[t.idx]),c[t.idx]=p(n,t)}),f?(r=o(f(c)),r[u]=c,r):o(c)},h(s,function(n,r){if(o.fn[n])return;o.fn[n]=function(s){var o=t.type(s),u=n==="alpha"?this._hsla?"hsla":"rgba":e,a=this[u](),f=a[r.idx],l;return o==="undefined"?f:(o==="function"&&(s=s.call(this,f),o=t.type(s)),s==null&&r.empty?this:(o==="string"&&(l=i.exec(s),l&&(s=f+parseFloat(l[2])*(l[1]==="+"?1:-1))),a[r.idx]=s,this[u](a)))}})}),h(r,function(e,n){t.cssHooks[n]={set:function(e,r){var i,s,u="";if(t.type(r)!=="string"||(i=d(r))){r=o(i||r);if(!f.rgba&&r._rgba[3]!==1){s=n==="backgroundColor"?e.parentNode:e;while((u===""||u==="transparent")&&s&&s.style)try{u=t.css(s,"backgroundColor"),s=s.parentNode}catch(a){}r=r.blend(u&&u!=="transparent"?u:"_default")}r=r.toRgbaString()}try{e.style[n]=r}catch(l){}}},t.fx.step[n]=function(e){e.colorInit||(e.start=o(e.elem,n),e.end=o(e.end),e.colorInit=!0),t.cssHooks[n].set(e.elem,e.start.transition(e.end,e.pos))}}),t.cssHooks.borderColor={expand:function(e){var t={};return h(["Top","Right","Bottom","Left"],function(n,r){t["border"+r+"Color"]=e}),t}},c=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(jQuery),function(){function i(){var t=this.ownerDocument.defaultView?this.ownerDocument.defaultView.getComputedStyle(this,null):this.currentStyle,n={},r,i;if(t&&t.length&&t[0]&&t[t[0]]){i=t.length;while(i--)r=t[i],typeof t[r]=="string"&&(n[e.camelCase(r)]=t[r])}else for(r in t)typeof t[r]=="string"&&(n[r]=t[r]);return n}function s(t,n){var i={},s,o;for(s in n)o=n[s],t[s]!==o&&!r[s]&&(e.fx.step[s]||!isNaN(parseFloat(o)))&&(i[s]=o);return i}var n=["add","remove","toggle"],r={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,n){e.fx.step[n]=function(e){if(e.end!=="none"&&!e.setAttr||e.pos===1&&!e.setAttr)jQuery.style(e.elem,n,e.end),e.setAttr=!0}}),e.effects.animateClass=function(t,r,o,u){var a=e.speed(r,o,u);return this.queue(function(){var r=e(this),o=r.attr("class")||"",u,f=a.children?r.find("*").andSelf():r;f=f.map(function(){var t=e(this);return{el:t,start:i.call(this)}}),u=function(){e.each(n,function(e,n){t[n]&&r[n+"Class"](t[n])})},u(),f=f.map(function(){return this.end=i.call(this.el[0]),this.diff=s(this.start,this.end),this}),r.attr("class",o),f=f.map(function(){var t=this,n=e.Deferred(),r=jQuery.extend({},a,{queue:!1,complete:function(){n.resolve(t)}});return this.el.animate(this.diff,r),n.promise()}),e.when.apply(e,f.get()).done(function(){u(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),a.complete.call(r[0])})})},e.fn.extend({_addClass:e.fn.addClass,addClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{add:t},n,r,i):this._addClass(t)},_removeClass:e.fn.removeClass,removeClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{remove:t},n,r,i):this._removeClass(t)},_toggleClass:e.fn.toggleClass,toggleClass:function(n,r,i,s,o){return typeof r=="boolean"||r===t?i?e.effects.animateClass.call(this,r?{add:n}:{remove:n},i,s,o):this._toggleClass(n,r):e.effects.animateClass.call(this,{toggle:n},r,i,s)},switchClass:function(t,n,r,i,s){return e.effects.animateClass.call(this,{add:n,remove:t},r,i,s)}})}(),function(){function i(t,n,r,i){e.isPlainObject(t)&&(n=t,t=t.effect),t={effect:t},n==null&&(n={}),e.isFunction(n)&&(i=n,r=null,n={});if(typeof n=="number"||e.fx.speeds[n])i=r,r=n,n={};return e.isFunction(r)&&(i=r,r=null),n&&e.extend(t,n),r=r||n.duration,t.duration=e.fx.off?0:typeof r=="number"?r:r in e.fx.speeds?e.fx.speeds[r]:e.fx.speeds._default,t.complete=i||n.complete,t}function s(t){return!t||typeof t=="number"||e.fx.speeds[t]?!0:typeof t=="string"&&!e.effects.effect[t]?n&&e.effects[t]?!1:!0:!1}e.extend(e.effects,{version:"1.9.2",save:function(e,t){for(var n=0;n<t.length;n++)t[n]!==null&&e.data(r+t[n],e[0].style[t[n]])},restore:function(e,n){var i,s;for(s=0;s<n.length;s++)n[s]!==null&&(i=e.data(r+n[s]),i===t&&(i=""),e.css(n[s],i))},setMode:function(e,t){return t==="toggle"&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var n,r;switch(e[0]){case"top":n=0;break;case"middle":n=.5;break;case"bottom":n=1;break;default:n=e[0]/t.height}switch(e[1]){case"left":r=0;break;case"center":r=.5;break;case"right":r=1;break;default:r=e[1]/t.width}return{x:r,y:n}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var n={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},r=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),i={width:t.width(),height:t.height()},s=document.activeElement;try{s.id}catch(o){s=document.body}return t.wrap(r),(t[0]===s||e.contains(t[0],s))&&e(s).focus(),r=t.parent(),t.css("position")==="static"?(r.css({position:"relative"}),t.css({position:"relative"})):(e.extend(n,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,r){n[r]=t.css(r),isNaN(parseInt(n[r],10))&&(n[r]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(i),r.css(n).show()},removeWrapper:function(t){var n=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===n||e.contains(t[0],n))&&e(n).focus()),t},setTransition:function(t,n,r,i){return i=i||{},e.each(n,function(e,n){var s=t.cssUnit(n);s[0]>0&&(i[n]=s[0]*r+s[1])}),i}}),e.fn.extend({effect:function(){function a(n){function u(){e.isFunction(i)&&i.call(r[0]),e.isFunction(n)&&n()}var r=e(this),i=t.complete,s=t.mode;(r.is(":hidden")?s==="hide":s==="show")?u():o.call(r[0],t,u)}var t=i.apply(this,arguments),r=t.mode,s=t.queue,o=e.effects.effect[t.effect],u=!o&&n&&e.effects[t.effect];return e.fx.off||!o&&!u?r?this[r](t.duration,t.complete):this.each(function(){t.complete&&t.complete.call(this)}):o?s===!1?this.each(a):this.queue(s||"fx",a):u.call(this,{options:t,duration:t.duration,callback:t.complete,mode:t.mode})},_show:e.fn.show,show:function(e){if(s(e))return this._show.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="show",this.effect.call(this,t)},_hide:e.fn.hide,hide:function(e){if(s(e))return this._hide.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="hide",this.effect.call(this,t)},__toggle:e.fn.toggle,toggle:function(t){if(s(t)||typeof t=="boolean"||e.isFunction(t))return this.__toggle.apply(this,arguments);var n=i.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)},cssUnit:function(t){var n=this.css(t),r=[];return e.each(["em","px","%","pt"],function(e,t){n.indexOf(t)>0&&(r=[parseFloat(n),t])}),r}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,n){t[n]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return e===0||e===1?e:-Math.pow(2,8*(e-1))*Math.sin(((e-1)*80-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){var t,n=4;while(e<((t=Math.pow(2,--n))-1)/11);return 1/Math.pow(4,3-n)-7.5625*Math.pow((t*3-2)/22-e,2)}}),e.each(t,function(t,n){e.easing["easeIn"+t]=n,e.easing["easeOut"+t]=function(e){return 1-n(1-e)},e.easing["easeInOut"+t]=function(e){return e<.5?n(e*2)/2:1-n(e*-2+2)/2}})}()}(jQuery);(function(e,t){var n=/up|down|vertical/,r=/up|left|vertical|horizontal/;e.effects.effect.blind=function(t,i){var s=e(this),o=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(s,t.mode||"hide"),a=t.direction||"up",f=n.test(a),l=f?"height":"width",c=f?"top":"left",h=r.test(a),p={},d=u==="show",v,m,g;s.parent().is(".ui-effects-wrapper")?e.effects.save(s.parent(),o):e.effects.save(s,o),s.show(),v=e.effects.createWrapper(s).css({overflow:"hidden"}),m=v[l](),g=parseFloat(v.css(c))||0,p[l]=d?m:0,h||(s.css(f?"bottom":"right",0).css(f?"top":"left","auto").css({position:"absolute"}),p[c]=d?g:m+g),d&&(v.css(l,0),h||v.css(c,g+m)),v.animate(p,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){u==="hide"&&s.hide(),e.effects.restore(s,o),e.effects.removeWrapper(s),i()}})}})(jQuery);(function(e,t){e.effects.effect.bounce=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=s==="hide",u=s==="show",a=t.direction||"up",f=t.distance,l=t.times||5,c=l*2+(u||o?1:0),h=t.duration/c,p=t.easing,d=a==="up"||a==="down"?"top":"left",v=a==="up"||a==="left",m,g,y,b=r.queue(),w=b.length;(u||o)&&i.push("opacity"),e.effects.save(r,i),r.show(),e.effects.createWrapper(r),f||(f=r[d==="top"?"outerHeight":"outerWidth"]()/3),u&&(y={opacity:1},y[d]=0,r.css("opacity",0).css(d,v?-f*2:f*2).animate(y,h,p)),o&&(f/=Math.pow(2,l-1)),y={},y[d]=0;for(m=0;m<l;m++)g={},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p).animate(y,h,p),f=o?f*2:f/2;o&&(g={opacity:0},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p)),r.queue(function(){o&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),w>1&&b.splice.apply(b,[1,0].concat(b.splice(w,c+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.clip=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"vertical",a=u==="vertical",f=a?"height":"width",l=a?"top":"left",c={},h,p,d;e.effects.save(r,i),r.show(),h=e.effects.createWrapper(r).css({overflow:"hidden"}),p=r[0].tagName==="IMG"?h:r,d=p[f](),o&&(p.css(f,0),p.css(l,d/2)),c[f]=o?d:0,c[l]=o?0:d/2,p.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o||r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.drop=function(t,n){var r=e(this),i=["position","top","bottom","left","right","opacity","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left"?"pos":"neg",l={opacity:o?1:0},c;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),c=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0)/2,o&&r.css("opacity",0).css(a,f==="pos"?-c:c),l[a]=(o?f==="pos"?"+=":"-=":f==="pos"?"-=":"+=")+c,r.animate(l,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.explode=function(t,n){function y(){c.push(this),c.length===r*i&&b()}function b(){s.css({visibility:"visible"}),e(c).remove(),u||s.hide(),n()}var r=t.pieces?Math.round(Math.sqrt(t.pieces)):3,i=r,s=e(this),o=e.effects.setMode(s,t.mode||"hide"),u=o==="show",a=s.show().css("visibility","hidden").offset(),f=Math.ceil(s.outerWidth()/i),l=Math.ceil(s.outerHeight()/r),c=[],h,p,d,v,m,g;for(h=0;h<r;h++){v=a.top+h*l,g=h-(r-1)/2;for(p=0;p<i;p++)d=a.left+p*f,m=p-(i-1)/2,s.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-p*f,top:-h*l}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:f,height:l,left:d+(u?m*f:0),top:v+(u?g*l:0),opacity:u?0:1}).animate({left:d+(u?0:m*f),top:v+(u?0:g*l),opacity:u?1:0},t.duration||500,t.easing,y)}}})(jQuery);(function(e,t){e.effects.effect.fade=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"toggle");r.animate({opacity:i},{queue:!1,duration:t.duration,easing:t.easing,complete:n})}})(jQuery);(function(e,t){e.effects.effect.fold=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=s==="hide",a=t.size||15,f=/([0-9]+)%/.exec(a),l=!!t.horizFirst,c=o!==l,h=c?["width","height"]:["height","width"],p=t.duration/2,d,v,m={},g={};e.effects.save(r,i),r.show(),d=e.effects.createWrapper(r).css({overflow:"hidden"}),v=c?[d.width(),d.height()]:[d.height(),d.width()],f&&(a=parseInt(f[1],10)/100*v[u?0:1]),o&&d.css(l?{height:0,width:a}:{height:a,width:0}),m[h[0]]=o?v[0]:a,g[h[1]]=o?v[1]:0,d.animate(m,p,t.easing).animate(g,p,t.easing,function(){u&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()})}})(jQuery);(function(e,t){e.effects.effect.highlight=function(t,n){var r=e(this),i=["backgroundImage","backgroundColor","opacity"],s=e.effects.setMode(r,t.mode||"show"),o={backgroundColor:r.css("backgroundColor")};s==="hide"&&(o.opacity=0),e.effects.save(r,i),r.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(o,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),n()}})}})(jQuery);(function(e,t){e.effects.effect.pulsate=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"show"),s=i==="show",o=i==="hide",u=s||i==="hide",a=(t.times||5)*2+(u?1:0),f=t.duration/a,l=0,c=r.queue(),h=c.length,p;if(s||!r.is(":visible"))r.css("opacity",0).show(),l=1;for(p=1;p<a;p++)r.animate({opacity:l},f,t.easing),l=1-l;r.animate({opacity:l},f,t.easing),r.queue(function(){o&&r.hide(),n()}),h>1&&c.splice.apply(c,[1,0].concat(c.splice(h,a+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.puff=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"hide"),s=i==="hide",o=parseInt(t.percent,10)||150,u=o/100,a={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:i,complete:n,percent:s?o:100,from:s?a:{height:a.height*u,width:a.width*u,outerHeight:a.outerHeight*u,outerWidth:a.outerWidth*u}}),r.effect(t)},e.effects.effect.scale=function(t,n){var r=e(this),i=e.extend(!0,{},t),s=e.effects.setMode(r,t.mode||"effect"),o=parseInt(t.percent,10)||(parseInt(t.percent,10)===0?0:s==="hide"?0:100),u=t.direction||"both",a=t.origin,f={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()},l={y:u!=="horizontal"?o/100:1,x:u!=="vertical"?o/100:1};i.effect="size",i.queue=!1,i.complete=n,s!=="effect"&&(i.origin=a||["middle","center"],i.restore=!0),i.from=t.from||(s==="show"?{height:0,width:0,outerHeight:0,outerWidth:0}:f),i.to={height:f.height*l.y,width:f.width*l.x,outerHeight:f.outerHeight*l.y,outerWidth:f.outerWidth*l.x},i.fade&&(s==="show"&&(i.from.opacity=0,i.to.opacity=1),s==="hide"&&(i.from.opacity=1,i.to.opacity=0)),r.effect(i)},e.effects.effect.size=function(t,n){var r,i,s,o=e(this),u=["position","top","bottom","left","right","width","height","overflow","opacity"],a=["position","top","bottom","left","right","overflow","opacity"],f=["width","height","overflow"],l=["fontSize"],c=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],h=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(o,t.mode||"effect"),d=t.restore||p!=="effect",v=t.scale||"both",m=t.origin||["middle","center"],g=o.css("position"),y=d?u:a,b={height:0,width:0,outerHeight:0,outerWidth:0};p==="show"&&o.show(),r={height:o.height(),width:o.width(),outerHeight:o.outerHeight(),outerWidth:o.outerWidth()},t.mode==="toggle"&&p==="show"?(o.from=t.to||b,o.to=t.from||r):(o.from=t.from||(p==="show"?b:r),o.to=t.to||(p==="hide"?b:r)),s={from:{y:o.from.height/r.height,x:o.from.width/r.width},to:{y:o.to.height/r.height,x:o.to.width/r.width}};if(v==="box"||v==="both")s.from.y!==s.to.y&&(y=y.concat(c),o.from=e.effects.setTransition(o,c,s.from.y,o.from),o.to=e.effects.setTransition(o,c,s.to.y,o.to)),s.from.x!==s.to.x&&(y=y.concat(h),o.from=e.effects.setTransition(o,h,s.from.x,o.from),o.to=e.effects.setTransition(o,h,s.to.x,o.to));(v==="content"||v==="both")&&s.from.y!==s.to.y&&(y=y.concat(l).concat(f),o.from=e.effects.setTransition(o,l,s.from.y,o.from),o.to=e.effects.setTransition(o,l,s.to.y,o.to)),e.effects.save(o,y),o.show(),e.effects.createWrapper(o),o.css("overflow","hidden").css(o.from),m&&(i=e.effects.getBaseline(m,r),o.from.top=(r.outerHeight-o.outerHeight())*i.y,o.from.left=(r.outerWidth-o.outerWidth())*i.x,o.to.top=(r.outerHeight-o.to.outerHeight)*i.y,o.to.left=(r.outerWidth-o.to.outerWidth)*i.x),o.css(o.from);if(v==="content"||v==="both")c=c.concat(["marginTop","marginBottom"]).concat(l),h=h.concat(["marginLeft","marginRight"]),f=u.concat(c).concat(h),o.find("*[width]").each(function(){var n=e(this),r={height:n.height(),width:n.width(),outerHeight:n.outerHeight(),outerWidth:n.outerWidth()};d&&e.effects.save(n,f),n.from={height:r.height*s.from.y,width:r.width*s.from.x,outerHeight:r.outerHeight*s.from.y,outerWidth:r.outerWidth*s.from.x},n.to={height:r.height*s.to.y,width:r.width*s.to.x,outerHeight:r.height*s.to.y,outerWidth:r.width*s.to.x},s.from.y!==s.to.y&&(n.from=e.effects.setTransition(n,c,s.from.y,n.from),n.to=e.effects.setTransition(n,c,s.to.y,n.to)),s.from.x!==s.to.x&&(n.from=e.effects.setTransition(n,h,s.from.x,n.from),n.to=e.effects.setTransition(n,h,s.to.x,n.to)),n.css(n.from),n.animate(n.to,t.duration,t.easing,function(){d&&e.effects.restore(n,f)})});o.animate(o.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o.to.opacity===0&&o.css("opacity",o.from.opacity),p==="hide"&&o.hide(),e.effects.restore(o,y),d||(g==="static"?o.css({position:"relative",top:o.to.top,left:o.to.left}):e.each(["top","left"],function(e,t){o.css(t,function(t,n){var r=parseInt(n,10),i=e?o.to.left:o.to.top;return n==="auto"?i+"px":r+i+"px"})})),e.effects.removeWrapper(o),n()}})}})(jQuery);(function(e,t){e.effects.effect.shake=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=t.direction||"left",u=t.distance||20,a=t.times||3,f=a*2+1,l=Math.round(t.duration/f),c=o==="up"||o==="down"?"top":"left",h=o==="up"||o==="left",p={},d={},v={},m,g=r.queue(),y=g.length;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),p[c]=(h?"-=":"+=")+u,d[c]=(h?"+=":"-=")+u*2,v[c]=(h?"-=":"+=")+u*2,r.animate(p,l,t.easing);for(m=1;m<a;m++)r.animate(d,l,t.easing).animate(v,l,t.easing);r.animate(d,l,t.easing).animate(p,l/2,t.easing).queue(function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),y>1&&g.splice.apply(g,[1,0].concat(g.splice(y,f+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.slide=function(t,n){var r=e(this),i=["position","top","bottom","left","right","width","height"],s=e.effects.setMode(r,t.mode||"show"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left",l,c={};e.effects.save(r,i),r.show(),l=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(r).css({overflow:"hidden"}),o&&r.css(a,f?isNaN(l)?"-"+l:-l:l),c[a]=(o?f?"+=":"-=":f?"-=":"+=")+l,r.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.transfer=function(t,n){var r=e(this),i=e(t.to),s=i.css("position")==="fixed",o=e("body"),u=s?o.scrollTop():0,a=s?o.scrollLeft():0,f=i.offset(),l={top:f.top-u,left:f.left-a,height:i.innerHeight(),width:i.innerWidth()},c=r.offset(),h=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(t.className).css({top:c.top-u,left:c.left-a,height:r.innerHeight(),width:r.innerWidth(),position:s?"fixed":"absolute"}).animate(l,t.duration,t.easing,function(){h.remove(),n()})}})(jQuery);/*
 *
 * Wijmo Library 3.20131.2
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/// <reference path="../Base/wijmo.d.ts"/>
/*
*
* Depends:
*  jquery.ui.core.js
*
*/
var wijmo;
(function (wijmo) {
    $.fn.extend({
        wijContent: function (url) {
            return this.each(function () {
                this.innerHTML = '<iframe frameborder="0" style="width: 100%; height: 100%;" src="' + url + '">"';
            });
        },
        wijAddVisibilityObserver: /* Visibility observer */
        function (h, namespace) {
            return this.each(function () {
                $(this).addClass("wijmo-wijobserver-visibility");
                $(this).bind("wijmovisibilitychanged" + (namespace ? ("." + namespace) : ""), h);
            });
        },
        wijRemoveVisibilityObserver: function (h) {
            return this.each(function () {
                $(this).removeClass("wijmo-wijobserver-visibility");
                if(!h) {
                    $(this).unbind("wijmovisibilitychanged");
                } else if(jQuery.isFunction(h)) {
                    $(this).unbind("wijmovisibilitychanged", h);
                } else {
                    $(this).unbind("wijmovisibilitychanged." + h);
                }
            });
        },
        wijTriggerVisibility: function () {
            return this.each(function () {
                var $el = $(this);
                if($el.hasClass("wijmo-wijobserver-visibility")) {
                    $el.trigger("wijmovisibilitychanged");
                }
                $el.find(".wijmo-wijobserver-visibility").trigger("wijmovisibilitychanged");
            });
        },
        leftBorderWidth: function () {
            var blw = parseFloat($(this).css("borderLeftWidth"));
            var pl = parseFloat($(this).css("padding-left"));
            var ml = 0;
            if($(this).css("margin-left") !== "auto") {
                ml = parseFloat($(this).css("margin-left"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        rightBorderWidth: function () {
            var brw = parseFloat($(this).css("borderRightWidth"));
            var pr = parseFloat($(this).css("padding-right"));
            var mr = 0;
            if($(this).css("margin-right") !== "auto") {
                mr = parseFloat($(this).css("margin-right"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        topBorderWidth: function () {
            var blw = parseFloat($(this).css("borderTopWidth"));
            var pl = parseFloat($(this).css("padding-top"));
            var ml = 0;
            if($(this).css("margin-top") !== "auto") {
                ml = parseFloat($(this).css("margin-top"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        bottomBorderWidth: function () {
            var brw = parseFloat($(this).css("borderBottomWidth"));
            var pr = parseFloat($(this).css("padding-bottom"));
            var mr = 0;
            if($(this).css("margin-bottom") !== "auto") {
                mr = parseFloat($(this).css("margin-bottom"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        borderSize: function () {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            var b = {
                width: bw,
                height: bh
            };
            return b;
        },
        setOutWidth: function (width) {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            $(this).width(width - bw);
            return this;
        },
        setOutHeight: function (height) {
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            $(this).height(height - bh);
            return this;
        },
        getWidget: function () {
            var widgetName = this.data("widgetName");
            if(widgetName && widgetName !== "") {
                return this.data(widgetName);
            }
            return null;
        },
        wijshow: function (animation, customAnimations, customAnimationOptions, showing, shown) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(showing && $.isFunction(showing)) {
                showing.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: shown
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.show(animated, $.extend(option, {
                            easing: easing
                        }), duration, shown);
                        return;
                    }
                }
            }
            this.show();
            if(shown && $.isFunction(shown)) {
                shown.call(this);
            }
        },
        wijhide: function (animation, customAnimations, customAnimationOptions, hiding, hidden) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(hiding && $.isFunction(hiding)) {
                hiding.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: hidden
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.hide(animated, $.extend(option, {
                            easing: easing
                        }), duration, hidden);
                        return;
                    }
                }
            }
            this.hide();
            if(hidden && $.isFunction(hidden)) {
                hidden.call(this);
            }
        }
    });
    function naNTest(num) {
        return isNaN(num) ? 0 : num;
    }
    //Saves a set of properties in a data storage
    $.save = function (element, set) {
        if($.effects) {
            return $.effects.save(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.data("ec.storage." + set[i], element[0].style[set[i]]);
            }
        }
    };
    // Restores a set of previously saved properties from a data storage
    $.restore = function (element, set) {
        if($.effects) {
            return $.effects.restore(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.css(set[i], element.data("ec.storage." + set[i]));
            }
        }
    };
    // Wraps the element around a wrapper that copies position properties
    $.createWrapper = function (element) {
        if($.effects) {
            return $.effects.createWrapper(element);
        }
        // if the element is already wrapped, return it
        if(element.parent().is('.ui-effects-wrapper')) {
            return element.parent();
        }
        // wrap the element
                var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
        }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
        }), active = document.activeElement;
        element.wrap(wrapper);
        // Fixes #7595 - Elements lose focus when wrapped.
        if(element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
        }
        wrapper = element.parent()//Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element
        ;
        // transfer positioning properties to the wrapper
        if(element.css('position') == 'static') {
            wrapper.css({
                position: 'relative'
            });
            element.css({
                position: 'relative'
            });
        } else {
            $.extend(props, {
                position: element.css('position'),
                zIndex: element.css('z-index')
            });
            $.each([
                'top', 
                'left', 
                'bottom', 
                'right'
            ], function (i, pos) {
                props[pos] = element.css(pos);
                if(isNaN(parseInt(props[pos], 10))) {
                    props[pos] = 'auto';
                }
            });
            element.css({
                position: 'relative',
                top: 0,
                left: 0,
                right: 'auto',
                bottom: 'auto'
            });
        }
        return wrapper.css(props).show();
    };
    $.removeWrapper = function (element) {
        if($.effects) {
            return $.effects.removeWrapper(element);
        }
        var parent, active = document.activeElement;
        if(element.parent().is('.ui-effects-wrapper')) {
            parent = element.parent().replaceWith(element);
            // Fixes #7595 - Elements lose focus when wrapped.
            if(element[0] === active || $.contains(element[0], active)) {
                $(active).focus();
            }
            return parent;
        }
        return element;
    };
    $.setMode = function (el, mode) {
        if($.effects) {
            return $.effects.setMode(el, mode);
        }
        if(mode === "toggle") {
            mode = el.is(":hidden") ? "show" : "hide";
        }
        return mode;
    };
    var wijCharValidator = function () {
    };
    $.extend(wijCharValidator.prototype, {
        _UTFPunctuationsString: ' ! \" # % & \' ( ) * , - . / : ; ? @ [ \\ ] { } \u00a1 \u00ab \u00ad \u00b7 \u00bb \u00bf \u037e \u0387 \u055a \u055b \u055c \u055d \u055e \u055f \u0589 \u058a \u05be \u05c0 \u05c3 \u05f3 \u05f4 \u060c \u061b \u061f \u066a \u066b \u066c \u066d \u06d4 \u0700 \u0701 \u0702 \u0703 \u0704 \u0705 \u0706 \u0707 \u0708 \u0709 \u070a \u070b \u070c \u070d \u0964 \u0965 \u0970 \u0df4 \u0e4f \u0e5a \u0e5b \u0f04 \u0f05 \u0f06 \u0f07 \u0f08 \u0f09 \u0f0a \u0f0b \u0f0c \u0f0d \u0f0e \u0f0f \u0f10 \u0f11 \u0f12 \u0f3a \u0f3b \u0f3c \u0f3d \u0f85 \u104a \u104b \u104c \u104d \u104e \u104f \u10fb \u1361 \u1362 \u1363 \u1364 \u1365 \u1366 \u1367 \u1368 \u166d \u166e \u169b \u169c \u16eb \u16ec \u16ed \u17d4 \u17d5 \u17d6 \u17d7 \u17d8 \u17d9 \u17da \u17dc \u1800 \u1801 \u1802 \u1803 \u1804 \u1805 \u1806 \u1807 \u1808 \u1809 \u180a \u2010 \u2011 \u2012 \u2013 \u2014 \u2015 \u2016 \u2017 \u2018 \u2019 \u201a \u201b \u201c \u201d \u201e \u201f \u2020 \u2021 \u2022 \u2023 \u2024 \u2025 \u2026 \u2027 \u2030 \u2031 \u2032 \u2033 \u2034 \u2035 \u2036 \u2037 \u2038 \u2039 \u203a \u203b \u203c \u203d \u203e \u2041 \u2042 \u2043 \u2045 \u2046 \u2048 \u2049 \u204a \u204b \u204c \u204d \u207d \u207e \u208d \u208e \u2329 \u232a \u3001 \u3002 \u3003 \u3008 \u3009 \u300a \u300b \u300c \u300d \u300e \u300f \u3010 \u3011 \u3014 \u3015 \u3016 \u3017 \u3018 \u3019 \u301a \u301b \u301c \u301d \u301e \u301f \u3030 \ufd3e \ufd3f \ufe30 \ufe31 \ufe32 \ufe35 \ufe36 \ufe37 \ufe38 \ufe39 \ufe3a \ufe3b \ufe3c \ufe3d \ufe3e \ufe3f \ufe40 \ufe41 \ufe42 \ufe43 \ufe44 \ufe49 \ufe4a \ufe4b \ufe4c \ufe50 \ufe51 \ufe52 \ufe54 \ufe55 \ufe56 \ufe57 \ufe58 \ufe59 \ufe5a \ufe5b \ufe5c \ufe5d \ufe5e \ufe5f \ufe60 \ufe61 \ufe63 \ufe68 \ufe6a \ufe6b \uff01 \uff02 \uff03 \uff05 \uff06 \uff07 \uff08 \uff09 \uff0a \uff0c \uff0d \uff0e \uff0f \uff1a \uff1b \uff1f \uff20 \uff3b \uff3c \uff3d \uff5b \uff5d \uff61 \uff62 \uff63 \uff64\';this.UTFWhitespacesString_=\'\t \u000b \u000c \u001f   \u00a0 \u1680 \u2000 \u2001 \u2002 \u2003 \u2004 \u2005 \u2006 \u2007 \u2008 \u2009 \u200a \u200b \u2028 \u202f \u3000',
        isDigit: function (c) {
            var code = c.charCodeAt(0);
            return (code >= 48 && code < 58);
        },
        isLetter: function (c) {
            return !!((c + '').match(new RegExp('[A-Za-z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u021f\u0222-\u0233\u0250-\u02ad\u02b0-\u02b8\u02bb-\u02c1\u02d0\u02d1\u02e0-\u02e4\u02ee\u037a\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03ce\u03d0-\u03d7\u03da-\u03f3\u0400-\u0481\u048c-\u04c4\u04c7\u04c8\u04cb\u04cc\u04d0-\u04f5\u04f8\u04f9\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u063a\u0640-\u064a\u0671-\u06d3\u06d5\u06e5\u06e6\u06fa-\u06fc\u0710\u0712-\u072c\u0780-\u07a5\u0905-\u0939\u093d\u0950\u0958-\u0961\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8b\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b36-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb5\u0bb7-\u0bb9\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cde\u0ce0\u0ce1\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d60\u0d61\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc\u0edd\u0f00\u0f40-\u0f47\u0f49-\u0f6a\u0f88-\u0f8b\u1000-\u1021\u1023-\u1027\u1029\u102a\u1050-\u1055\u10a0-\u10c5\u10d0-\u10f6\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1206\u1208-\u1246\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1286\u1288\u128a-\u128d\u1290-\u12ae\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12ce\u12d0-\u12d6\u12d8-\u12ee\u12f0-\u130e\u1310\u1312-\u1315\u1318-\u131e\u1320-\u1346\u1348-\u135a\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1780-\u17b3\u1820-\u1877\u1880-\u18a8\u1e00-\u1e9b\u1ea0-\u1ef9\u1f00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u207f\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2131\u2133-\u2139\u3005\u3006\u3031-\u3035\u3041-\u3094\u309d\u309e\u30a1-\u30fa\u30fc-\u30fe\u3105-\u312c\u3131-\u318e\u31a0-\u31b7\u3400-\u4db5\u4e00-\u9fa5\ua000-\ua48c\uac00-\ud7a3\uf900-\ufa2d\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe72\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')));
        },
        isLetterOrDigit: function (c) {
            return this.isLetter(c) || this.isDigit(c);
        },
        isDoubleByteNumber: function (c) {
            var code = c.charCodeAt(0);
            return code >= 65296 && code < 65306;
        },
        isSymbol: function (c) {
            var re = new RegExp('[$+<->^`|~\u00a2-\u00a9\u00ac\u00ae-\u00b1\u00b4\u00b6\u00b8\u00d7\u00f7\u02b9\u02ba\u02c2-\u02cf\u02d2-\u02df\u02e5-\u02ed\u0374\u0375\u0384\u0385\u0482\u06e9\u06fd\u06fe\u09f2\u09f3\u09fa\u0b70\u0e3f\u0f01-\u0f03\u0f13-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fcf\u17db\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u207a-\u207c\u208a-\u208c\u20a0-\u20af\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u2132\u213a\u2190-\u21f3\u2200-\u22f1\u2300-\u2328\u232b-\u237b\u237d-\u239a\u2400-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2595\u25a0-\u25f7\u2600-\u2613\u2619-\u2671\u2701-\u2704\u2706-\u2709\u270c-\u2727\u2729-\u274b\u274d\u274f-\u2752\u2756\u2758-\u275e\u2761-\u2767\u2794\u2798-\u27af\u27b1-\u27be\u2800-\u28ff\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u3200-\u321c\u322a-\u3243\u3260-\u327b\u327f\u328a-\u32b0\u32c0-\u32cb\u32d0-\u32fe\u3300-\u3376\u337b-\u33dd\u33e0-\u33fe\ua490-\ua4a1\ua4a4-\ua4b3\ua4b5-\ua4c0\ua4c2-\ua4c4\ua4c6\ufb29\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]');
            return re.test(c + '');
        },
        isPunctuation: function (c) {
            return this._UTFPunctuationsString.indexOf(c) >= 0;
        },
        isPrintableChar: function (c) {
            if((!this.isLetterOrDigit(c) && !this.isPunctuation(c)) && !this.isSymbol(c) && !this.isDoubleByteNumber(c)) {
                return (c === ' ');
            }
            return true;
        },
        isAscii: function (c) {
            return (c >= '!') && (c <= '~');
        },
        isAsciiLetter: function (c) {
            return ((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'));
        },
        isUpper: function (c) {
            return c.toUpperCase() === c;
        },
        isLower: function (c) {
            return c.toLowerCase() === c;
        },
        isAlphanumeric: function (c) {
            return !this.isLetter(c) ? this.isDigit(c) : true;
        },
        isAciiAlphanumeric: function (c) {
            if(((c < '0') || (c > '9')) && ((c < 'A') || (c > 'Z'))) {
                if(c >= 'a') {
                    return (c <= 'z');
                }
                return false;
            }
            return true;
        },
        setChar: function (input, ch, pos) {
            if(pos >= input.length || pos < 0) {
                return input;
            }
            return '' || input.substr(0, pos) + ch + input.substr(pos + 1);
        }
    });
    var c__escapeArr1 = [
        '\n', 
        '\r', 
        '"', 
        '@', 
        '+', 
        '\'', 
        '<', 
        '>', 
        '%', 
        '{', 
        '}'
    ], c__escapeArr2 = [
        "!ESC!NN!", 
        "!ESC!RR!", 
        "!ESC!01!", 
        "!ESC!02!", 
        "!ESC!03!", 
        "!ESC!04!", 
        "!ESC!05!", 
        "!ESC!06!", 
        "!ESC!07!", 
        "!ESC!08!", 
        "!ESC!09!"
    ], c__escapeArr3 = [
        "(\n)", 
        "(\r)", 
        "(\")", 
        "(@)", 
        "(\\+)", 
        "(')", 
        "(\\<)", 
        "(\\>)", 
        "(%)", 
        "(\\{)", 
        "(\\})"
    ];
    if(!$.wij) {
        $.extend({
            wij: {
                charValidator: new wijCharValidator(),
                encodeString: function (s) {
                    for(var i = 0; i < c__escapeArr1.length; i++) {
                        var r = /c__escapeArr3[i]/g;
                        s = s.replace(r, c__escapeArr2[i]);
                    }
                    return s;
                },
                decodeString: function (s) {
                    if(s === "") {
                        return;
                    }
                    for(var i = 0; i < c__escapeArr2.length; i++) {
                        var r = /c__escapeArr2[i]/g;
                        s = s.replace(r, c__escapeArr1[i]);
                    }
                    return s;
                }
            }
        });
    }
    ;
    //copy from jQuery-migrate.js in case of jQuery 1.9 removing $.browser api.
    if(!jQuery.uaMatch) {
        jQuery.uaMatch = function (ua) {
            ua = ua.toLowerCase();
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
    }
    // Don't clobber any existing jQuery.browser in case it's different
    if(!jQuery.browser) {
        var matched = jQuery.uaMatch(navigator.userAgent), browser = {
            version: "0",
            msie: false,
            opera: false,
            safari: false,
            mozilla: false,
            webkit: false,
            chrome: false
        };
        if(matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
        // Chrome is Webkit, but Webkit is also Safari.
        if(browser.chrome) {
            browser.webkit = true;
        } else if(browser.webkit) {
            browser.safari = true;
        }
        jQuery.browser = browser;
    }
    //Fix an known jQuery issue #8710,
    //http://bugs.jqueryui.com/ticket/8710
    //if ($.ui && $.ui.position && $.ui.position.flipfit) {
    //    $.ui.position.flip.top =function (position:any, data:any) {
    //        var within = data.within,
    //            withinOffset = within.offset.top + within.scrollTop,
    //            outerHeight = within.height,
    //            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
    //            collisionPosTop = position.top - data.collisionPosition.marginTop,
    //            overTop = collisionPosTop - offsetTop,
    //            overBottom = collisionPosTop + data.collisionHeight - outerHeight - within.offset.top,
    //            top = data.my[1] === "top",
    //            myOffset = top ?
    //                -data.elemHeight :
    //                data.my[1] === "bottom" ?
    //                    data.elemHeight :
    //                    0,
    //            atOffset = data.at[1] === "top" ?
    //                data.targetHeight :
    //                data.at[1] === "bottom" ?
    //                    -data.targetHeight :
    //                    0,
    //            offset = -2 * data.offset[1],
    //            newOverTop,
    //            newOverBottom;
    //        if (overTop < 0) {
    //            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
    //            if (newOverBottom < 0 || newOverBottom < Math.abs(overTop)) {
    //                position.top += myOffset + atOffset + offset;
    //            }
    //        }
    //        else if (overBottom > 0) {
    //            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
    //            if (newOverTop > 0 || Math.abs(newOverTop) < overBottom) {
    //                position.top += myOffset + atOffset + offset;
    //            }
    //        }
    //    };
    //}
    })(wijmo || (wijmo = {}));
function __wijReadOptionEvents(eventsArr, widgetInstance) {
    // handle option events
    for(var k = 0; k < eventsArr.length; k++) {
        if(widgetInstance.options[eventsArr[k]] !== null) {
            widgetInstance.element.bind(eventsArr[k], widgetInstance.options[eventsArr[k]]);
        }
    }
    //handle option event names separated by space, like: "afterexpand aftercollapse"
    for(var k in widgetInstance.options) {
        if(k.indexOf(" ") !== -1) {
            // possible multiple events separated by space:
            var arr = k.split(" ");
            for(var j = 0; j < arr.length; j++) {
                if(arr[j].length > 0) {
                    widgetInstance.element.bind(arr[j], widgetInstance.options[k]);
                }
            }
        }
    }
}
;
function wijmoASPNetParseOptionsReviewer(o, k) {
    var a, v = o[k], d;
    if(v) {
        switch(typeof v) {
            case "string":
                a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?):(\d{3})Z$/.exec(v);
                if(a) {
                    d = new Date(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6], +a[7]);
                    d.setFullYear(+a[1]);
                    o[k] = d;
                }
                break;
            case "object":
                if(v.needQuotes !== undefined && v.valueString !== undefined) {
                    if(!v.needQuotes) {
                        o[k] = eval(v.valueString);
                    } else {
                        o[k] = v.valueString;
                    }
                } else {
                    for(k in v) {
                        wijmoASPNetParseOptionsReviewer(v, k);
                    }
                }
                break;
        }
    }
}
function wijmoASPNetParseOptions(o) {
    var k;
    if(!o) {
        return o;
    }
    for(k in o) {
        wijmoASPNetParseOptionsReviewer(o, k);
    }
    return o;
}
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/// <reference path="../External/declarations/jquerymobile.d.ts"/>
/// <reference path="wijmo.d.ts"/>
/*
* Depends:
*  jquery.ui.widget.js
*
*/
var wijmo;
(function (wijmo) {
    var $ = jQuery;
    var jQueryWijmo = (function () {
        function jQueryWijmo() { }
        jQueryWijmo.autoMobilize = true;
        jQueryWijmo.wijCSS = {
            widget: "ui-widget",
            overlay: "ui-widget-overlay",
            content: "ui-widget-content",
            header: "ui-widget-header",
            stateDisabled: "ui-state-disabled",
            stateFocus: "ui-state-focus",
            stateActive: "ui-state-active",
            stateDefault: "ui-state-default",
            stateHightlight: "ui-state-highlight",
            stateHover: "ui-state-hover",
            stateChecked: "ui-state-checked",
            stateError: "ui-state-error",
            getState: function (name) {
                name = name.charAt(0).toUpperCase() + name.substr(1);
                return $.wijmo.wijCSS["state" + name];
            },
            icon: "ui-icon",
            iconCheck: "ui-icon-check",
            iconRadioOn: "ui-icon-radio-on",
            iconRadioOff: "ui-icon-radio-off",
            iconClose: "ui-icon-close",
            iconArrow4Diag: "ui-icon-arrow-4-diag",
            iconNewWin: "ui-icon-newwin",
            iconVGripSolid: "ui-icon-grip-solid-vertical",
            iconHGripSolid: "ui-icon-grip-solid-horizontal",
            iconPlay: "ui-icon-play",
            iconPause: "ui-icon-pause",
            iconStop: "ui-icon-stop",
            iconArrowUp: "ui-icon-triangle-1-n",
            iconArrowRight: "ui-icon-triangle-1-e",
            iconArrowDown: "ui-icon-triangle-1-s",
            iconArrowLeft: "ui-icon-triangle-1-w",
            iconArrowRightDown: "ui-icon-triangle-1-se",
            iconCaratUp: "ui-icon-carat-1-n",
            iconCaratRight: "ui-icon-carat-1-e",
            iconCaratDown: "ui-icon-carat-1-s",
            iconCaratLeft: "ui-icon-carat-1-w",
            iconSeekFirst: "ui-icon-seek-first",
            iconSeekEnd: "ui-icon-seek-end",
            iconSeekNext: "ui-icon-seek-next",
            iconSeekPrev: "ui-icon-seek-prev",
            inputSpinnerLeft: "ui-input-spinner-left",
            inputSpinnerRight: "ui-input-spinner-right",
            inputTriggerLeft: "ui-input-trigger-left",
            inputTriggerRight: "ui-input-trigger-right",
            inputSpinnerTriggerLeft: "ui-input-spinner-trigger-left",
            inputSpinnerTriggerRight: "ui-input-spinner-trigger-right",
            cornerAll: "ui-corner-all",
            cornerLeft: "ui-corner-left",
            cornerRight: "ui-corner-right",
            cornerBottom: "ui-corner-bottom",
            cornerBL: "ui-corner-bl",
            cornerBR: "ui-corner-br",
            cornerTop: "ui-corner-top",
            cornerTL: "ui-corner-tl",
            cornerTR: "ui-corner-tr",
            helperClearFix: "ui-helper-clearfix",
            helperReset: "ui-helper-reset",
            helperHidden: "ui-helper-hidden",
            priorityPrimary: "ui-priority-primary",
            prioritySecondary: "ui-priority-secondary",
            button: "ui-button",
            buttonText: "ui-button-text",
            buttonTextOnly: "ui-button-text-only",
            tabs: "ui-tabs",
            tabsTop: "ui-tabs-top",
            tabsBottom: "ui-tabs-bottom",
            tabsLeft: "ui-tabs-left",
            tabsRight: "ui-tabs-right",
            tabsLoading: "ui-tabs-loading",
            tabsActive: "ui-tabs-active",
            tabsPanel: "ui-tabs-panel",
            tabsNav: "ui-tabs-nav",
            tabsHide: "ui-tabs-hide",
            tabsCollapsible: "ui-tabs-collapsible",
            activeMenuitem: "ui-active-menuitem"
        };
        jQueryWijmo.wijMobileCSS = {
            content: "ui-content",
            header: "ui-header",
            overlay: "ui-overlay",
            stateDisabled: "ui-disabled",
            stateFocus: "ui-focus",
            stateActive: "ui-btn-active",
            stateDefault: "ui-btn-up-a",
            iconArrowUp: "ui-icon-arrow-u",
            iconArrowRight: "ui-icon-arrow-r",
            iconArrowDown: "ui-icon-arrow-d",
            iconArrowLeft: "ui-icon-arrow-l",
            iconArrowRightDown: "ui-icon-arrow-d",
            iconSeekFirst: "ui-icon-arrow-l",
            iconSeekEnd: "ui-icon-arrow-r",
            iconSeekNext: "ui-icon-arrow-l",
            iconSeekPrev: "ui-icon-arrow-r",
            iconClose: "ui-icon-delete",
            iconStop: "ui-icon-grid",
            iconCheck: "ui-icon-checkbox-on"
        };
        jQueryWijmo.autoInit = // auto self-init widgets
        function autoInit(widgetName, pageKeepNative) {
            if($.mobile && $.mobile.page && pageKeepNative) {
                //add keepNative to page to prevent default auto-initialization of form elements
                var keepNative = $.mobile.page.prototype.options.keepNative;
                if(keepNative && keepNative.length && keepNative.indexOf(pageKeepNative) === -1) {
                    keepNative = [
                        keepNative, 
                        pageKeepNative
                    ].join(", ");
                } else {
                    keepNative = pageKeepNative;
                }
                $.mobile.page.prototype.options.keepNative = keepNative;
            }
            if($.mobile && $.wijmo[widgetName] && $.wijmo[widgetName].prototype && $.wijmo[widgetName].prototype.enhanceWithin) {
                $(document).bind("pagecreate create", function (e) {
                    $.wijmo[widgetName].prototype.enhanceWithin(e.target);
                });
            }
        };
        jQueryWijmo.registerWidget = function registerWidget(name, baseType, def, customizeInit) {
            var fullName = "wijmo." + name, init;
            if(typeof def === 'function') {
                init = def;
                def = null;
            }
            if(def === null || def === undefined) {
                def = $.extend(true, {
                }, baseType);
                baseType = $.wijmo.widget;
            }
            def.options = def.options || {
            };
            def.options.initSelector = def.options.initSelector || ":jqmData(role='" + name + "')";
            if($.mobile && def.options && def.options.wijMobileCSS) {
                def.options.wijCSS = def.options.wijCSS || {
                };
                $.extend(def.options.wijCSS, def.options.wijMobileCSS);
            }
            $.widget(fullName, baseType, def);
            if(init) {
                init.call();
            } else if(this.autoInit) {
                this.autoInit(name, def.options.initSelector);
            }
        };
        return jQueryWijmo;
    })();    
    $.wijmo = jQueryWijmo;
    // Declarations to support TypeScript type system
    var JQueryUIWidget = (function () {
        function JQueryUIWidget() { }
        JQueryUIWidget.prototype.destroy = function () {
        };
        JQueryUIWidget.prototype._setOption = function (name, value) {
        };
        JQueryUIWidget.prototype._create = function () {
        };
        JQueryUIWidget.prototype._init = function () {
        };
        JQueryUIWidget.prototype.widget = function () {
            return this.element;
        };
        return JQueryUIWidget;
    })();
    wijmo.JQueryUIWidget = JQueryUIWidget;    
    JQueryUIWidget.prototype.options = {
        wijCSS: $.wijmo.wijCSS
    };
    JQueryUIWidget.prototype.destroy = function () {
        $.Widget.prototype.destroy.apply(this, arguments);
    };
    JQueryUIWidget.prototype._setOption = function (name, value) {
        $.Widget.prototype._setOption.apply(this, arguments);
    };
    JQueryUIWidget.prototype._create = function () {
        $.Widget.prototype._create.apply(this, arguments);
    };
    JQueryUIWidget.prototype._init = function () {
        $.Widget.prototype._init.apply(this, arguments);
    };
    var JQueryMobileWidget = (function (_super) {
        __extends(JQueryMobileWidget, _super);
        function JQueryMobileWidget() {
            _super.apply(this, arguments);

        }
        return JQueryMobileWidget;
    })(JQueryUIWidget);
    wijmo.JQueryMobileWidget = JQueryMobileWidget;    
    //Fires a wijmoinit event on the document object for users to override default settings.
    //Use $(document).bind("wijmoinit", function() {//apply overrides here});
    //The event handler must be binded before jquery.wijmo.widget is loaded.
    $(window.document).trigger("wijmoinit");
    var wijmoWidget = (function (_super) {
        __extends(wijmoWidget, _super);
        function wijmoWidget() {
            _super.apply(this, arguments);

            this._widgetCreated = false;
        }
        wijmoWidget.prototype._baseWidget = function () {
            return this._isMobile ? $.mobile.widget : $.Widget;
        };
        wijmoWidget.prototype._createWidget = function (options, element) {
            this._widgetCreated = true;
            //Set widgetName to widgetEventPrefix for binding events like following,
            //$(element).bind(widgetName + eventName, function() {});
            if(this._syncEventPrefix) {
                this.widgetEventPrefix = this.widgetName;
            }
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            this._baseWidget().prototype._createWidget.apply(this, arguments);
        };
        wijmoWidget.prototype._create = function () {
            this._baseWidget().prototype._create.apply(this, arguments);
        };
        wijmoWidget.prototype._init = function () {
            this._baseWidget().prototype._init.apply(this, arguments);
        };
        wijmoWidget.prototype.destroy = function () {
            this._baseWidget().prototype.destroy.apply(this, arguments);
        };
        wijmoWidget.prototype._setOption = function (name, value) {
            this._baseWidget().prototype._setOption.apply(this, arguments);
            //Fixed an issue for jQuery mobile. when set the disabled option, the jQuery mobile set
            // 'ui-state-disabled' css on the element.
            if(name === "disabled" && this._isMobile) {
                this.element.removeClass("ui-state-disabled").addClass(this.options.wijCSS.stateDisabled);
            }
        };
        return wijmoWidget;
    })(JQueryMobileWidget);
    wijmo.wijmoWidget = wijmoWidget;    
    wijmoWidget.prototype._syncEventPrefix = true;
    wijmoWidget.prototype._isMobile = false;
    wijmoWidget.prototype.options = $.extend(true, {
    }, wijmoWidget.prototype.options, wijmoWidget.prototype._baseWidget().prototype.options);
    //Check if jQuery Mobile is on the page and make sure autoMobilize is set to true (so that this default behavior can be turned off)
    if($.mobile != null && $.wijmo.autoMobilize === true) {
        //Set mobile CSS classes to work with jQuery Mobile CSS Framework
        //wijmoWidget.options.wijCSS = $.wijmo.wijMobileCSS;
        $.extend(true, wijmoWidget.prototype.options.wijCSS, $.wijmo.wijMobileCSS);
        wijmoWidget.prototype._isMobile = true;
        wijmoWidget.prototype.enhanceWithin = function (target, useKeepNative) {
            if(!this._widgetCreated) {
                $.mobile.widget.prototype.enhanceWithin.apply(this, arguments);
            }
        };
        wijmoWidget.prototype._getCreateOptions = function () {
            var ele = this.element, baseOptions, optionsParser = optionsParser = function (value) {
                // Add quotes to key pair.
                if(typeof value === 'undefined') {
                    return {
                    };
                } else if(value === null) {
                    return {
                    };
                }
                var reg = /(?:(?:\{[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*)|(?:,[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*))('(.*?[^\\])')?/gi, arrReg = /\[.*?(?=[\]\[])|[\]\[].*?(?=[\]])/gi, str = value.replace(reg, function (i, str1, str2, str3) {
                    var result, reg1 = /[\n\r\t\s]*['"]?([^\{,\s]+?)['"]?\s*:[\n\r\t\s]*/i, reg2 = /\:[\n\r\t\s]*(?:'(.*)')?/i;
                    result = i.replace(reg1, "\"$1\":");
                    if(str3) {
                        return result.replace(reg2, ":\"$1\"");
                    }
                    return result;
                }).replace(arrReg, function (i) {
                    var reg1 = /'(.*?[^\\])'/g;
                    return i.replace(reg1, "\"$1\"");
                });
                return $.parseJSON(str);
            }, options = optionsParser(ele.attr("data-" + $.mobile.nsNormalize("options")));
            baseOptions = $.mobile.widget.prototype._getCreateOptions.apply(this, arguments);
            return $.extend(baseOptions, options);
        };
        $.widget("wijmo.widget", $.mobile.widget, wijmoWidget.prototype);
    } else {
        //jQuery Mobile either does not exist or the autoMobilize flag has been turned off.
        $.widget("wijmo.widget", wijmoWidget.prototype);
    }
})(wijmo || (wijmo = {}));
;
/*globals window*/
/*
* Wijmo Touch Utilities.
*
* Depends:
*	jquery.js
*
*/

jQuery.extend(jQuery.support, {
	isTouchEnabled : function() {
		if (!("ontouchstart" in window) &&
			!("ontouchend" in document) &&
			!window.navigator.msPointerEnabled) {
			return false;
		}else{
			return true;
		}
	}
});

function wijmoApplyWijTouchUtilEvents($) {

    if (!("ontouchstart" in window) &&
	   !("ontouchend" in document) &&
	   !window.navigator.msPointerEnabled || $.supportWijTouch) {
        return $;
    }

    // if this function execute twice, it will throw exception in winjs.
    var replaceEventTypeFn, changeEventNameFn,
		eventsHash = {
		    "click": "wijtap",
		    "dblclick": "wijdoubletap",
		    "mouseenter": "wijmouseover",
		    "mouseover": "wijmouseover",
		    "mouseleave": "wijmouseout",
		    "mouseout": "wijmouseout",
		    "mousedown": "wijmousedown",
		    "mouseup": "wijmouseup",
		    "mousemove": "wijmousemove",
		    "mousecancel": "wijmousecancel",
		    "gesturestart": "wijgesturestart",
		    "gesturechange": "wijgesturechange",
		    "gestureend": "wijgestureend",
		    "swipeleft": "wijswipeleft",
		    "swiperight": "wijswiperight",
		    "swipe": "wijswipe"
		};
    //qq: //focus //blur?

    replaceEventTypeFn = function (t) {
        if (eventsHash[t.substr(1)]) {
            return " " + eventsHash[t.substr(1)];
        }
        return t;
    }
    changeEventNameFn = function (firstArg) {
        if (typeof firstArg === "string") {
            // replace standard events to wijtouchutil events
            var k, i = 0, regexp, s = "";
            for (k in eventsHash) {
                if (i === 0) {
                    s += "(";
                } else {
                    s += "|";
                }
                s += "[\\s]+" + k;
                i += 1;
            }
            s += ")";

            firstArg = " " + firstArg;
            regexp = new RegExp(s, "g");
            firstArg = firstArg.replace(regexp, replaceEventTypeFn).substr(1);
        }
        return firstArg;
    }

    var jQuery = $;
    function jQuerySub(selector, context) {
        return new jQuerySub.fn.init(selector, context);
    }
    jQuery.extend(true, jQuerySub, jQuery);
    jQuerySub.superclass = jQuery;
    jQuerySub.fn = jQuerySub.prototype = jQuery();
    jQuerySub.fn.constructor = jQuerySub;
    jQuerySub.fn.init = function init(selector, context) {
        if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
            context = jQuerySub(context);
        }

        return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
    };
    jQuerySub.fn.init.prototype = jQuerySub.fn;
    var rootjQuerySub = jQuerySub(document);

    $ = jQuerySub;
    $.wijmo = $.wijmo || {};
    $.supportWijTouch = true;

    $.fn.bind = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.bind.apply(this, arguments);
    }
    $.fn.unbind = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.unbind.apply(this, arguments);
    }
    $.fn.live = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.live.apply(this, arguments);
    }
    $.fn.die = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.die.apply(this, arguments);
    }
    $.fn.on = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.on.apply(this, arguments);
    };
    $.fn.off = function () {
        arguments[0] = changeEventNameFn(arguments[0]);
        return jQuery.fn.off.apply(this, arguments);
    };
    return $;
}
(function ($, window, document, undefined) {

    var dataPropertyName = "virtualMouseBindings",
		touchTargetPropertyName = "virtualTouchID",
		virtualEventNames = "wijmouseover wijmousedown wijmousemove wijmouseup wijclick wijtap wijdoubletap wijtaphold wijmouseout wijmousecancel".split(" "),
		msPointerEnabled = window.navigator.msPointerEnabled,
		realEventNames = {
		    "wijmouseover": (!msPointerEnabled ? "mouseover" : "MSPointerOver"),
		    "wijmousedown": (!msPointerEnabled ? "mousedown" : "MSPointerDown"),
		    "wijmousemove": (!msPointerEnabled ? "mousemove" : "MSPointerMove"),
		    "wijmouseup": (!msPointerEnabled ? "mouseup" : "MSPointerUp"),
		    "wijmouseout": (!msPointerEnabled ? "mouseout" : "MSPointerOut"),
		    "wijmousecancel": (!msPointerEnabled ? "mousecancel" : "mousecancel"),
		    "wijclick": (!msPointerEnabled ? "click" : "MSGestureTap"),
		    "wijdoubletap": (!msPointerEnabled ? "dblclick" : "MSGestureDoubleTap"),
		    "wijtaphold": (!msPointerEnabled ? "gesturehold" : "MSGestureHold")
		},
	touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
	nativeEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
	mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
	mouseEventProps = $.event.props.concat(mouseHookProps),
	activeDocHandlers = {},
	resetTimerID = 0,
	startX = 0,
	startY = 0,
	didScroll = false,
	clickBlockList = [],
	blockMouseTriggers = false,
	blockTouchTriggers = false,
	eventCaptureSupported = "addEventListener" in document,
	$document = $(document),
	nextTouchID = 1,
	lastTouchID = 0,
    msPointerEnabled = window.navigator.msPointerEnabled,
	touchStartEventM = (!msPointerEnabled) ? "touchstart" : "MSPointerDown",
	touchEndEventM = (!msPointerEnabled) ? "touchend" : "MSPointerUp",
	touchMoveEventM = (!msPointerEnabled) ? "touchmove" : "MSPointerMove",
	touchScrollEventM = (!msPointerEnabled) ? "scroll" : "scroll";


    $.wijmouse = {
        moveDistanceThreshold: 10,
        clickDistanceThreshold: 10,
        resetTimerDuration: 1500
    };

    function getNativeEvent(event) {

        while (event && typeof event.originalEvent !== "undefined") {
            event = event.originalEvent;
        }
        return event;
    }

    function createVirtualEvent(event, eventType) {

        var t = event.type,
		oe, props, ne, prop, ct, touch, i, j;

        event = $.Event(event);
        event.nativeType = event.type;
        event.type = eventType;

        oe = event.originalEvent;
        props = $.event.props;

        // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
        // https://github.com/jquery/jquery-mobile/issues/3280
        if (t.search(/^(mouse|click)/) > -1) {
            props = mouseEventProps;
        }

        // copy original event properties over to the new event
        // this would happen if we could call $.event.fix instead of $.Event
        // but we don't have a way to force an event to be fixed multiple times
        if (oe) {
            for (i = props.length, prop; i;) {
                prop = props[--i];
                event[prop] = oe[prop];
            }
        }

        // make sure that if the mouse and click virtual events are generated
        // without a .which one is defined
        if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
            event.which = 1;
        }

        ne = getNativeEvent(oe);

        // handle pageX/PageY under Metro:
        for (j = 0, len = nativeEventProps.length; j < len; j++) {
            prop = nativeEventProps[j];
            if (event[prop] === undefined) {
                event[prop] = ne[prop];
            }
        }

        if (t.search(/^touch/) !== -1) {
            t = ne.touches;
            ct = ne.changedTouches;
            touch = (t && t.length) ? t[0] : ((ct && ct.length) ? ct[0] : undefined);

            if (touch) {
                for (j = 0, len = touchEventProps.length; j < len; j++) {
                    prop = touchEventProps[j];
                    event[prop] = touch[prop];
                }
            }
        }

        return event;
    }

    function getVirtualBindingFlags(element) {

        var flags = {},
		b, k;

        while (element) {

            b = $.data(element, dataPropertyName);

            for (k in b) {
                if (b[k]) {
                    flags[k] = flags.hasVirtualBinding = true;
                }
            }
            element = element.parentNode;
        }
        return flags;
    }

    function getClosestElementWithVirtualBinding(element, eventType) {
        var b;
        while (element) {

            b = $.data(element, dataPropertyName);

            if (b && (!eventType || b[eventType])) {
                return element;
            }
            element = element.parentNode;
        }
        return null;
    }

    function enableTouchBindings() {
        blockTouchTriggers = false;
    }

    function disableTouchBindings() {
        blockTouchTriggers = true;
    }

    function enableMouseBindings() {
        lastTouchID = 0;
        clickBlockList.length = 0;
        blockMouseTriggers = false;

        // When mouse bindings are enabled, our
        // touch bindings are disabled.
        disableTouchBindings();
    }

    function disableMouseBindings() {
        // When mouse bindings are disabled, our
        // touch bindings are enabled.
        enableTouchBindings();
    }

    function startResetTimer() {
        clearResetTimer();
        resetTimerID = setTimeout(function () {
            resetTimerID = 0;
            enableMouseBindings();
        }, $.wijmouse.resetTimerDuration);
    }

    function clearResetTimer() {
        if (resetTimerID) {
            clearTimeout(resetTimerID);
            resetTimerID = 0;
        }
    }

    function triggerVirtualEvent(eventType, event, flags) {
        var ve;

        if ((flags && flags[eventType]) ||
				(!flags && getClosestElementWithVirtualBinding(event.target, eventType))) {

            ve = createVirtualEvent(event, eventType);

            $(event.target).trigger(ve);
        }

        return ve;
    }

    function mouseEventCallback(event) {
        var touchID = $.data(event.target, touchTargetPropertyName), vEventName, k;
        if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
            vEventName = "wij" + event.type;
            for (k in realEventNames) {
                if (realEventNames[k] === event.type) {
                    vEventName = k;
                }
            }
            var ve = triggerVirtualEvent(vEventName, event);

            if (ve) {
                if (ve.isDefaultPrevented()) {
                    event.preventDefault();
                }
                if (ve.isPropagationStopped()) {
                    event.stopPropagation();
                }
                if (ve.isImmediatePropagationStopped()) {
                    event.stopImmediatePropagation();
                }
            }
        }
    }

    function handleTouchStart(event) {

        var touches = getNativeEvent(event).touches,
		target, flags, ne;
        
        if (touches && touches.length === 1 || msPointerEnabled) {

            target = event.target;
            flags = getVirtualBindingFlags(target);
            if (flags.hasVirtualBinding) {

                lastTouchID = nextTouchID++;
                $.data(target, touchTargetPropertyName, lastTouchID);

                clearResetTimer();
                disableMouseBindings();
                didScroll = false;
                ne = getNativeEvent(event);
                var t = ne.touches ? ne.touches[0] : ne;
                startX = t.pageX;
                startY = t.pageY;

                triggerVirtualEvent("wijmouseover", event, flags);
                triggerVirtualEvent("wijmousedown", event, flags);
            }
        }
    }

    function handleScroll(event) {
        if (blockTouchTriggers) {
            return;
        }

        if (!didScroll) {
            triggerVirtualEvent("wijmousecancel", event, getVirtualBindingFlags(event.target));
        }

        didScroll = true;
        startResetTimer();
    }

    function handleTouchMove(event) {
        if (blockTouchTriggers) {
            return;
        }

        var ne = getNativeEvent(event),
            t = ne.touches ? ne.touches[0] : ne,
		didCancel = didScroll,
		moveThreshold = $.wijmouse.moveDistanceThreshold;
        didScroll = didScroll ||
			(Math.abs(t.pageX - startX) > moveThreshold ||
				Math.abs(t.pageY - startY) > moveThreshold),
		flags = getVirtualBindingFlags(event.target);
        if (didScroll && !didCancel) {
            triggerVirtualEvent("wijmousecancel", event, flags);
        }

        triggerVirtualEvent("wijmousemove", event, flags);
        startResetTimer();
    }

    function handleTouchEnd(event) {
        if (blockTouchTriggers) {
            return;
        }
        disableTouchBindings();

        var flags = getVirtualBindingFlags(event.target),
		ne, t;
        triggerVirtualEvent("wijmouseup", event, flags);
        if (!didScroll) {
            var ve = triggerVirtualEvent("wijclick", event, flags);
            if (ve && ve.isDefaultPrevented()) {
                // The target of the mouse events that follow the touchend
                // event don't necessarily match the target used during the
                // touch. This means we need to rely on coordinates for blocking
                // any click that is generated.
                ne = getNativeEvent(event);
                t = ne.changedTouches ? ne.changedTouches[0] : ne;
                clickBlockList.push({
                    touchID: lastTouchID,
                    x: t.clientX,
                    y: t.clientY
                });

                // Prevent any mouse events that follow from triggering
                // virtual event notifications.
                blockMouseTriggers = true;
            }
        }
        triggerVirtualEvent("wijmouseout", event, flags);
        didScroll = false;

        startResetTimer();
    }

    function hasVirtualBindings(ele) {
        var bindings = $.data(ele, dataPropertyName),
		k;

        if (bindings) {
            for (k in bindings) {
                if (bindings[k]) {
                    return true;
                }
            }
        }
        return false;
    }

    function dummyMouseHandler() { }

    function getSpecialEventObject(eventType) {

        //var realType = eventType.substr(2); //qq
        var realType = realEventNames[eventType];
        return {
            setup: function (data, namespace) {
                // If this is the first virtual mouse binding for this element,
                // add a bindings object to its data.

                if (!hasVirtualBindings(this)) {
                    $.data(this, dataPropertyName, {});
                }

                // If setup is called, we know it is the first binding for this
                // eventType, so initialize the count for the eventType to zero.
                var bindings = $.data(this, dataPropertyName);
                bindings[eventType] = true;

                // If this is the first virtual mouse event for this type,
                // register a global handler on the document.

                activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

                if (activeDocHandlers[eventType] === 1) {
                    $document.bind(realType, mouseEventCallback);
                }

                // Some browsers, like Opera Mini, won't dispatch mouse/click events
                // for elements unless they actually have handlers registered on them.
                // To get around this, we register dummy handlers on the elements.

                $(this).bind(realType, dummyMouseHandler);

                // For now, if event capture is not supported, we rely on mouse handlers.
                if (eventCaptureSupported) {
                    // If this is the first virtual mouse binding for the document,
                    // register our touchstart handler on the document.				    

                    activeDocHandlers[touchStartEventM] = (activeDocHandlers[touchStartEventM] || 0) + 1;

                    if (activeDocHandlers[touchStartEventM] === 1) {
                        $document.bind(touchStartEventM, handleTouchStart)
						.bind(touchEndEventM, handleTouchEnd)

						// On touch platforms, touching the screen and then dragging your finger
						// causes the window content to scroll after some distance threshold is
						// exceeded. On these platforms, a scroll prevents a click event from being
						// dispatched, and on some platforms, even the touchend is suppressed. To
						// mimic the suppression of the click event, we need to watch for a scroll
						// event. Unfortunately, some platforms like iOS don't dispatch scroll
						// events until *AFTER* the user lifts their finger (touchend). This means
						// we need to watch both scroll and touchmove events to figure out whether
						// or not a scroll happenens before the touchend event is fired.

						.bind(touchMoveEventM, handleTouchMove)
						.bind(touchScrollEventM, handleScroll);
                    }
                }
            },

            teardown: function (data, namespace) {
                // If this is the last virtual binding for this eventType,
                // remove its global handler from the document.

                --activeDocHandlers[eventType];

                if (!activeDocHandlers[eventType]) {
                    $document.unbind(realType, mouseEventCallback);
                }

                if (eventCaptureSupported) {
                    // If this is the last virtual mouse binding in existence,
                    // remove our document touchstart listener.

                    --activeDocHandlers[touchStartEventM];

                    if (!activeDocHandlers[touchStartEventM]) {
                        $document.unbind(touchStartEventM, handleTouchStart)
						.unbind(touchMoveEventM, handleTouchMove)
						.unbind(touchEndEventM, handleTouchEnd)
						.unbind(touchScrollEventM, handleScroll);
                    }
                }

                var $this = $(this),
				bindings = $.data(this, dataPropertyName);

                // teardown may be called when an element was
                // removed from the DOM. If this is the case,
                // jQuery core may have already stripped the element
                // of any data bindings so we need to check it before
                // using it.
                if (bindings) {
                    bindings[eventType] = false;
                }

                // Unregister the dummy event handler.

                $this.unbind(realType, dummyMouseHandler);

                // If this is the last virtual mouse binding on the
                // element, remove the binding data from the element.

                if (!hasVirtualBindings(this)) {
                    $this.removeData(dataPropertyName);
                }
            }
        };
    }

    // Expose our custom events to the jQuery bind/unbind mechanism.

    for (var i = 0; i < virtualEventNames.length; i++) {
        $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
    }

    // Add a capture click handler to block clicks.
    // Note that we require event capture support for this so if the device
    // doesn't support it, we punt for now and rely solely on mouse events.
    if (eventCaptureSupported) {
        document.addEventListener("click", function (e) {
            var cnt = clickBlockList.length,
			target = e.target,
			x, y, ele, i, o, touchID;

            if (cnt) {
                x = e.clientX;
                y = e.clientY;
                threshold = $.wijmouse.clickDistanceThreshold;

                // The idea here is to run through the clickBlockList to see if
                // the current click event is in the proximity of one of our
                // wijclick events that had preventDefault() called on it. If we find
                // one, then we block the click.
                //
                // Why do we have to rely on proximity?
                //
                // Because the target of the touch event that triggered the wijclick
                // can be different from the target of the click event synthesized
                // by the browser. The target of a mouse/click event that is syntehsized
                // from a touch event seems to be implementation specific. For example,
                // some browsers will fire mouse/click events for a link that is near
                // a touch event, even though the target of the touchstart/touchend event
                // says the user touched outside the link. Also, it seems that with most
                // browsers, the target of the mouse/click event is not calculated until the
                // time it is dispatched, so if you replace an element that you touched
                // with another element, the target of the mouse/click will be the new
                // element underneath that point.
                //
                // Aside from proximity, we also check to see if the target and any
                // of its ancestors were the ones that blocked a click. This is necessary
                // because of the strange mouse/click target calculation done in the
                // Android 2.1 browser, where if you click on an element, and there is a
                // mouse/click handler on one of its ancestors, the target will be the
                // innermost child of the touched element, even if that child is no where
                // near the point of touch.

                ele = target;

                while (ele) {
                    for (i = 0; i < cnt; i++) {
                        o = clickBlockList[i];
                        touchID = 0;

                        if ((ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold) ||
								$.data(ele, touchTargetPropertyName) === o.touchID) {
                            // XXX: We may want to consider removing matches from the block list
                            //      instead of waiting for the reset timer to fire.
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                    }
                    ele = ele.parentNode;
                }
            }
        }, true);
    }
})(jQuery, window, document);


(function ($, window, undefined) {

    // add new event shortcuts
    $.each(("touchstart touchmove touchend orientationchange throttledresize " +
					"wijtap wijtaphold wijswipe wijswipeleft wijswiperight wijscrollstart wijscrollstop").split(" "), function (i, name) {

					    $.fn[name] = function (fn) {
					        return fn ? this.bind(name, fn) : this.trigger(name);
					    };

					    if ($.attrFn) {
					        $.attrFn[name] = true;
					    }
					});

    var supportTouch = ("ontouchend" in document),
	scrollEvent = "touchmove scroll",
	touchStartEvent = supportTouch ? "touchstart" : "mousedown",
	touchStopEvent = supportTouch ? "touchend" : "mouseup",
	touchMoveEvent = supportTouch ? "touchmove" : "mousemove",
	gesturestartEvent = supportTouch ? "gesturestart" : "gesturestart",
	gesturechangeEvent = supportTouch ? "gesturechange" : "gesturechange",
	gestureendEvent = supportTouch ? "gestureend" : "gestureend";
    if (window.navigator.msPointerEnabled) {
        touchStartEvent = "MSPointerDown";
        touchStopEvent = "MSPointerUp";
        touchMoveEvent = "MSPointerMove";
        gesturestartEvent = "MSGestureStart";
        gesturechangeEvent = "MSGestureChange";
        gestureendEvent = "MSGestureEnd";
    }

    function triggerCustomEvent(obj, eventType, event) {
        var originalType = event.type;
        event.nativeType = event.type;
        event.type = eventType;
        try {
            $([obj]).trigger(event);
        } finally {
            event.type = originalType;
        }
    }

    // also handles scrollstop
    $.event.special.wijscrollstart = {

        enabled: true,

        setup: function () {

            var thisObject = this,
			$this = $(thisObject),
			scrolling,
			timer;

            function trigger(event, state) {
                scrolling = state;
                triggerCustomEvent(thisObject, scrolling ? "wijscrollstart" : "wijscrollstop", event);
            }

            // iPhone triggers scroll after a small delay; use touchmove instead
            $this.bind(scrollEvent, function (event) {

                if (!$.event.special.wijscrollstart.enabled) {
                    return;
                }

                if (!scrolling) {
                    trigger(event, true);
                }

                clearTimeout(timer);
                timer = setTimeout(function () {
                    trigger(event, false);
                }, 50);
            });
        }
    };

    // also handles taphold
    $.event.special.wijtap = {
        setup: function () {
            var thisObject = this,
			$this = $(thisObject);

            $this.bind("wijmousedown", function (event) {

                if (event.which && event.which !== 1) {
                    return false;
                }

                var origTarget = event.target,
				origEvent = event.originalEvent,
				timer;

                function clearTapTimer() {
                    clearTimeout(timer);
                }

                function clearTapHandlers() {
                    clearTapTimer();

                    $this.unbind("wijclick", clickHandler)
					.unbind("wijmouseup", clearTapTimer);
                    $(document).unbind("wijmousecancel", clearTapHandlers);
                }

                function clickHandler(event) {
                    clearTapHandlers();

                    // ONLY trigger a 'tap' event if the start target is
                    // the same as the stop target.
                    if (origTarget == event.target) {
                        triggerCustomEvent(thisObject, "wijtap", event);
                    }
                }

                $this.bind("wijmouseup", clearTapTimer)
				.bind("wijclick", clickHandler);
                $(document).bind("wijmousecancel", clearTapHandlers);

                timer = setTimeout(function () {
                    triggerCustomEvent(thisObject, "wijtaphold", $.Event("wijtaphold", { target: origTarget }));
                }, 750);
            });
        }
    };

    // also handles swipeleft, swiperight
    $.event.special.wijswipe = {
        scrollSupressionThreshold: 10, // More than this horizontal displacement, and we will suppress scrolling.

        durationThreshold: 1000, // More time than this, and it isn't a swipe.

        horizontalDistanceThreshold: 30,  // Swipe horizontal displacement must be more than this.

        verticalDistanceThreshold: 75,  // Swipe vertical displacement must be less than this.

        setup: function () {
            var thisObject = this,
			$this = $(thisObject);
            $this.bind(touchStartEvent, function (event) {
                var data = event.originalEvent.touches ?
								event.originalEvent.touches[0] : event,
				start = {
				    time: (new Date()).getTime(),
				    coords: [data.pageX, data.pageY],
				    origin: $(event.target)
				},
				stop;

                function moveHandler(event) {

                    if (!start) {
                        return;
                    }

                    var data = event.originalEvent.touches ?
						event.originalEvent.touches[0] : event;

                    stop = {
                        time: (new Date()).getTime(),
                        coords: [data.pageX, data.pageY]
                    };

                    // prevent scrolling
                    if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.wijswipe.scrollSupressionThreshold) {
                        event.preventDefault();
                    }
                }

                $this.bind(touchMoveEvent, moveHandler)
				.one(touchStopEvent, function (event) {
				    $this.unbind(touchMoveEvent, moveHandler);

				    if (start && stop) {
				        if (stop.time - start.time < $.event.special.wijswipe.durationThreshold &&
								Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.wijswipe.horizontalDistanceThreshold &&
								Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.wijswipe.verticalDistanceThreshold) {

				            start.origin.trigger("wijswipe")
								.trigger(start.coords[0] > stop.coords[0] ? "wijswipeleft" : "wijswiperight");//qq
				        }
				    }
				    start = stop = undefined;
				});
            });
        }
    };

    // gesture events

    var gestureEventProps = "altKey ctrlKey metaKey rotation scale shiftKey target velocityX velocityY translationX translationY".split(" ");

    function preInitGestureEvent(elem, eventName) {		
		if(window.navigator.msPointerEnabled && !elem.__wijMSGesturePreInit) {
			// listen for MS gestures
			elem.__wijMSGesturePreInit = true;
			var msGesture = new MSGesture();
			msGesture.target = elem;
            elem.addEventListener("MSPointerDown", function (e) {
				msGesture.addPointer(e.pointerId);			
            }, false);     
		}
	}

    function triggerGestureEvent(eventType, event) {
        var ve = createGestureEvent(event, eventType);

        $(event.target).trigger(ve);
        return ve;
    }

    function createGestureEvent(event, eventType) {
        var t = event.type,
		oe, props, ne, prop, ct, touch, i, j, len;
        oe = event.originalEvent;
        event = $.Event(event);
        event.nativeType = event.type;
        event.type = eventType;
        props = $.event.props;
        // copy original event properties over to the new event
        // this would happen if we could call $.event.fix instead of $.Event
        // but we don't have a way to force an event to be fixed multiple times
        if (oe) {
            for (i = props.length, prop; i;) {
                prop = props[--i];
                event[prop] = event[prop] || oe[prop];
            }
        }
        for (j = 0, len = gestureEventProps.length; j < len; j++) {
            prop = gestureEventProps[j];
            event[prop] = event[prop] || oe[prop];
        }

        if (window.navigator.msPointerEnabled && event.rotation) {
            // automatically convert to degrees for metro:
            event.rotation = event.rotation * 360 / Math.PI
        }
        return event;
    }

    $.event.special.wijgesturestart = {
        setup: function () {             
            var thisObject = this, $this = $(thisObject);
			preInitGestureEvent(thisObject, "wijgesturestart");
            $this.bind(gesturestartEvent, function (event) {
                triggerGestureEvent("wijgesturestart", event);
            });
        }
    };

    $.event.special.wijgesturechange = {
        setup: function () {
            var thisObject = this, $this = $(thisObject);
			preInitGestureEvent(thisObject, "wijgesturechange");
            $this.bind(gesturechangeEvent, function (event) {
                triggerGestureEvent("wijgesturechange", event);
            });
        }
    };

    $.event.special.wijgestureend = {
        setup: function () {
            var thisObject = this, $this = $(thisObject);
			preInitGestureEvent(thisObject, "wijgestureend");
            $this.bind(gestureendEvent, function (event) {
                triggerGestureEvent("wijgestureend", event);
            });
        }
    };
    //--

    (function ($, window) {
        // "Cowboy" Ben Alman

        var win = $(window),
		special_event,
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true };

        // It seems that some device/browser vendors use window.orientation values 0 and 180 to
        // denote the "default" orientation. For iOS devices, and most other smart-phones tested,
        // the default orientation is always "portrait", but in some Android and RIM based tablets,
        // the default orientation is "landscape". The following code attempts to use the window
        // dimensions to figure out what the current orientation is, and then makes adjustments
        // to the to the portrait_map if necessary, so that we can properly decode the
        // window.orientation value whenever get_orientation() is called.
        //
        // Note that we used to use a media query to figure out what the orientation the browser
        // thinks it is in:
        //
        //     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
        //
        // but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
        // where the browser *ALWAYS* applied the landscape media query. This bug does not
        // happen on iPad.

        if ("orientation" in window && "onorientationchange" in window) {

            // Check the window width and height to figure out what the current orientation
            // of the device is at this moment. Note that we've initialized the portrait map
            // values to 0 and 180, *AND* we purposely check for landscape so that if we guess
            // wrong, , we default to the assumption that portrait is the default orientation.
            // We use a threshold check below because on some platforms like iOS, the iPhone
            // form-factor can report a larger width than height if the user turns on the
            // developer console. The actual threshold value is somewhat arbitrary, we just
            // need to make sure it is large enough to exclude the developer console case.

            var ww = window.innerWidth || $(window).width(),
			wh = window.innerHeight || $(window).height(),
			landscape_threshold = 50;

            initial_orientation_is_landscape = ww > wh && (ww - wh) > landscape_threshold;


            // Now check to see if the current window.orientation is 0 or 180.
            initial_orientation_is_default = portrait_map[window.orientation];

            // If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
            // if the initial orientation is portrait, but window.orientation reports 90 or -90, we
            // need to flip our portrait_map values because landscape is the default orientation for
            // this device/browser.
            if ((initial_orientation_is_landscape && initial_orientation_is_default) || (!initial_orientation_is_landscape && !initial_orientation_is_default)) {
                portrait_map = { "-90": true, "90": true };
            }
        }

        $.event.special.orientationchange = special_event = {
            setup: function () {
                // If the event is supported natively, return false so that jQuery
                // will bind to the event using DOM methods.
                if (("orientation" in window && "onorientationchange" in window) && $.mobile.orientationChangeEnabled) {
                    return false;
                }

                // Get the current orientation to avoid initial double-triggering.
                last_orientation = get_orientation();

                // Because the orientationchange event doesn't exist, simulate the
                // event by testing window dimensions on resize.
                win.bind("throttledresize", handler);
            },
            teardown: function () {
                // If the event is not supported natively, return false so that
                // jQuery will unbind the event using DOM methods.
                if (("orientation" in window && "onorientationchange" in window) && $.mobile.orientationChangeEnabled) {
                    return false;
                }

                // Because the orientationchange event doesn't exist, unbind the
                // resize event handler.
                win.unbind("throttledresize", handler);
            },
            add: function (handleObj) {
                // Save a reference to the bound event handler.
                var old_handler = handleObj.handler;


                handleObj.handler = function (event) {
                    // Modify event object, adding the .orientation property.
                    event.orientation = get_orientation();

                    // Call the originally-bound event handler and return its result.
                    return old_handler.apply(this, arguments);
                };
            }
        };

        // If the event is not supported natively, this handler will be bound to
        // the window resize event to simulate the orientationchange event.
        function handler() {
            // Get the current orientation.
            var orientation = get_orientation();

            if (orientation !== last_orientation) {
                // The orientation has changed, so trigger the orientationchange event.
                last_orientation = orientation;
                win.trigger("orientationchange");
            }
        }

        // Get the current page orientation. This method is exposed publicly, should it
        // be needed, as jQuery.event.special.orientationchange.orientation()
        $.event.special.orientationchange.orientation = get_orientation = function () {
            var isPortrait = true, elem = document.documentElement;

            // prefer window orientation to the calculation based on screensize as
            // the actual screen resize takes place before or after the orientation change event
            // has been fired depending on implementation (eg android 2.3 is before, iphone after).
            // More testing is required to determine if a more reliable method of determining the new screensize
            // is possible when orientationchange is fired. (eg, use media queries + element + opacity)
            if ("orientation" in window && "onorientationchange" in window) {
                // if the window orientation registers as 0 or 180 degrees report
                // portrait, otherwise landscape
                isPortrait = portrait_map[window.orientation];
            } else {
                isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
            }

            return isPortrait ? "portrait" : "landscape";
        };

    })(jQuery, window);


    // throttled resize event
    (function () {

        $.event.special.throttledresize = {
            setup: function () {
                $(this).bind("resize", handler);
            },
            teardown: function () {
                $(this).unbind("resize", handler);
            }
        };

        var throttle = 250,
		handler = function () {
		    curr = (new Date()).getTime();
		    diff = curr - lastCall;

		    if (diff >= throttle) {

		        lastCall = curr;
		        $(this).trigger("throttledresize");

		    } else {

		        if (heldCall) {
		            clearTimeout(heldCall);
		        }

		        // Promise a held call will still execute
		        heldCall = setTimeout(handler, throttle - diff);
		    }
		},
		lastCall = 0,
		heldCall,
		curr,
		diff;
    })();


    $.each({
        wijscrollstop: "wijscrollstart",
        wijtaphold: "wijtap",
        wijswipeleft: "wijswipe",
        wijswiperight: "wijswipe"
    }, function (event, sourceEvent) {

        $.event.special[event] = {
            setup: function () {
                $(this).bind(sourceEvent, $.noop);
            }
        };
    });

})(jQuery, this);

//jQuery.wijtouch = wijmoApplyWijTouchUtilEvents(jQuery);;
/*globals window*/
/*
 * Depends:
 *	jquery.effects.core.js
 *
 */

$(document).ready(function () {
	var userAgent = window.navigator.userAgent,
		isAndroidVerBellow2_2 = userAgent.match(new RegExp("android ((1\\.)|(2\\.([^345]+)))", "i")),
		areTransformsSupported = ((window.WebKitCSSMatrix) ? !isAndroidVerBellow2_2 : false), 
		isWebKitEnabled = !!(typeof userAgent == "string" && userAgent.match(/applewebkit/)),
		isTouchDevice = "ontouchend" in document,
		div = document.createElement('div'),
		cssTransitionsSupported;
	div.setAttribute('style', 'transition:top 1s ease;-webkit-transition:top 1s ease;-moz-transition:top 1s ease;-o-transition:top 1s ease;');
	document.body.appendChild(div);
	cssTransitionsSupported = !!(div.style.transition || div.style.webkitTransition || div.style.MozTransition || div.style.OTransitionDuration);
	div.parentNode.removeChild(div);
	div = null;

	// prevent transition flickering for iTouch devices:
	function with3DAcceleration(element, action, args) {
	    var property = "-webkit-transform",
            enabler = "translate3d(0,0,0)",
	        origValue = element.css(property);

	    var isNone = !(origValue && origValue.match(/^\s*none\s*$/i));
	    element.css(property, isNone ? enabler : origValue + " " + enabler);
	    try {
	        return action.apply(this, args);
	    } finally {
	        element.css(property, origValue);
	    }
	}


	var $animate = jQuery.fn.animate;
	jQuery.fn.animate = function (prop, speed, easing, callback) {
	    if (!isWebKitEnabled || !webKitTransition.apply(this, arguments)) {
	        return with3DAcceleration.call(this, this, function () {
	            return $animate.apply(this, arguments);
	        }, arguments);
		}
	};


	function webKitTransition(prop, speed, easing, callback) {
		var result = false, propVal, newVal,
			speedOpt = $.speed(speed, easing, callback),
			self = this;
		if (!prop) {
			return false;
		}

		for (var k in prop) {
			propVal = prop[k];
			if (k === "height") {
				if (propVal === "hide") {
					this.css("display", "none");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeOut(this[0], speedOpt.duration, "linear", speedOpt.complete);
				} else if (propVal === "show") {
					this.css("display", "");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeIn(this[0], speedOpt.duration, "linear", speedOpt.complete);
				}
			} else if (k === "width") {
				if (propVal === "hide") {
					this.css("display", "none");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeOut(this[0], speedOpt.duration, "linear", speedOpt.complete);
				} else if (propVal === "show") {
					this.css("display", "");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeIn(this[0], speedOpt.duration, "linear", speedOpt.complete);
				}
			} else if (k === "left") {
				newVal = this.css("left").replace("px", "") * 1;

				if (typeof propVal === "string") {
					if (propVal.indexOf("-=") === 0) {
						newVal = newVal -
                                propVal.replace("-=", "") * 1;
					}
					else if (propVal.indexOf("+=") === 0) {
						newVal = newVal +
                                propVal.replace("+=", "") * 1;
					}
				}

				result = true;
				/*
				var completeTranslateTransition = $.proxy(function () {
				speedOpt.complete();
				}, this);
				*/
				// prevent flickering for iTouch devices:
				this.css("-webkit-perspective", 1000);
				this.css("-webkit-backface-visibility", "hidden");
				//
				//-webkit-perspective: 1000;
				//: ;  
				scrollToX(this[0], newVal, speedOpt.duration, "linear", speedOpt.complete);
				//speedOpt.complete();
			}
		}

		return result;
	}

	/// <summary>
	/// Hide the element by fading it to transparent.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function fadeOut(element, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        if (!timing) {
	            timing = "ease";
	        }
	        setupTransition(element, "opacity", duration, timing);
	        setOpacity(element, 0);

	        element.addEventListener("webkitTransitionEnd", $.proxy(function () {
	            clearTransition(element);
	            element.style.display = "none";
	            setOpacity(element, 1);
	            if (endHandler) {
	                endHandler();
	            }
	        }, this), false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Display the element by fading it to opaque.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function fadeIn(element, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        if (!timing) {
	            timing = "ease";
	        }
	        setupTransition(element, "opacity", duration, timing);
	        setOpacity(element, 1);

	        element.addEventListener("webkitTransitionEnd", $.proxy(function () {
	            clearTransition(element);
	            if (element.style.display === "none") {
	                element.style.display = "";
	            }
	            if (endHandler) {
	                endHandler();
	            }
	        }, this), false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Scroll element horizontally using webkit transitions.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="x" type="Number">
	///	The new translate value.
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function scrollToX(element, x, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        setupTransitionTransform(element, duration, timing);
	        setTranslateX(element, x);
	        element.___animationEndHandler = endHandler;
	        element.___internalEndHandler = $.proxy(_onScrollTransitionEnd, {});
	        element.addEventListener("webkitTransitionEnd", element.___internalEndHandler, false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Set opacity value.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new opacity value.
	///	</param>
    function setOpacity(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        st = element.style || element;
	        st.opacity = value;
	    }
	    else {

	    }
	}


	/// <summary>
	/// Set translate X value. This method will use left style for non-webkit browsers.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new translate value.
	///	</param>
    function setTranslateX(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        element.___translateX = value;
	        st = element.style || element;
	        //st.webkitTransform = "translate3d(" + value + "px," + getTranslateY(element) + "px, 0)";
	        st.webkitTransform = "translateX(" + value + "px)";
	    }
	    else {
	        element.style.left = value + "px";
	    }
	}

	/// <summary>
	/// Set translate Y value. This method will use top style for non-webkit browsers.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new translate value.
	///	</param>
    function setTranslateY(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        element.___translateY = value;
	        st = element.style || element;
	        //st.webkitTransform = "translate3d(" + getTranslateX(element) + "px," + value + "px, 0)";
	        st.webkitTransform = "translateY(" + value + "px)";
	    }
	    else {
	        element.style.top = value + "px";
	    }
	}

	/// <summary>
	/// Gets translate X value. This method will return left style for non-webkit browsers.
	/// </summary>
    function getTranslateX(element) {
	    var style, transform, r, match, k;
	    if (!element) {
	        return 0;
	    }
	    if (cssTransitionsSupported) {
	        style = element.style || element;
	        transform = style.webkitTransform;
	        if (typeof transform === "string") {
	            r = new RegExp("translate(3d|X|)\\(-*(\\d+)");
	            match = r.exec(transform);
	            if (match) {
	                k = parseFloat(match[1]);
	                if (isFinite(k)) {
	                    return k;
	                }
	            }
	        }
	    }
	    else {
	        var k = parseInt($(element).css("left"));
	        if (isFinite(k)) {
	            return k;
	        }
	    }
	    return 0;
	}

	/// <summary>
	/// Gets translate Y value. This method will return top style for non-webkit browsers.
	/// </summary>
    function getTranslateY(element) {
	    var style, transform, r, match, k;
	    if (!element) {
	        return 0;
	    }
	    if (cssTransitionsSupported) {
	        style = element.style || element;
	        transform = style.webkitTransform;
	        if (typeof transform === "string") {
	            r = new RegExp("translate(3d|X|)\\(.*,\\s*-*(\\d+)");
	            match = r.exec(transform);
	            if (match) {
	                k = parseFloat(match[1]);
	                if (isFinite(k)) {
	                    return k;
	                }
	            }
	        }
	    }
	    else {
	        var k = parseInt(jQuery(element).css("top"));
	        if (isFinite(k)) {
	            return k;
	        }
	    }
	    return 0;
	}

	/// <summary>
	/// Call this method in order to setup transition for transform animation.
	/// </summary>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
    function setupTransitionTransform(element, duration, timing) {
	    if (!timing) {
	        timing = "ease";
	    }
	    setupTransition(element, "-webkit-transform", duration, timing);
	}

	/// <summary>
	/// Setup transition animation for element given by parameter element.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM element for transition.
	///	</param>
	/// <param name="properties" type="String">
	///	String, specifies the name of the CSS property to which the transition is applied. 
	///	You can list multiple properties. Property names should be bare, unquoted names.
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
    function setupTransition(element, properties, duration, timing) {
	    if (cssTransitionsSupported) {
	        var style = (element).style;
	        style.webkitTransitionProperty = properties;
	        style.webkitTransitionDuration = duration + 'ms';
	        style.webkitTransitionTimingFunction = timing;
	    }
	}

	/// <summary>
	/// Clear transition animation for element given by parameter element.
	/// </summary>
    function clearTransition(element) {
	    if (cssTransitionsSupported) {
	        var st = element.style;
	        st.webkitTransitionProperty = 'none';
	        var internalEndHandler = element.___internalEndHandler;
	        if (internalEndHandler) {
	            delete element.___internalEndHandler;
	            element.removeEventListener('webkitTransitionEnd', internalEndHandler, false);
	        }
	    }
	}

    function _onScrollTransitionEnd(e) {
	    try {
	        var targetElement, endHandler;
	        switch (e.type) {
	            case "webkitTransitionEnd":
	                targetElement = e.target;
	                if (targetElement) {
	                    clearTransition(targetElement);
	                    if (targetElement.___animationEndHandler) {
	                        endHandler = targetElement.___animationEndHandler;
	                        targetElement.___animationEndHandler = null;
	                        endHandler(e);
	                    }
	                }
	                break;
	        }
	    }
	    catch (ex) {
	        if (window.console && window.console.log) {
	            window.console.log("[ew219290] error: " +
					(ex.message ? ex.message : ex) +
						", event: " + e);
	        }
	    }
	    return true;
	}

});

/*
prop:left=-=1224; jquery.wijmo.wijtouchtransitions.js:11
speed:queue=false;duration=250;easing=easeInQuad;complete=function (){...}
*/
/*
prop:height=hide;paddingTop=hide;paddingBottom=hide; jquery.wijmo.wijtouchtransitions.js:11
speed:step=function (now, settings) {
					        var val;
					        if (settings.prop === options.horizontal ?
													"width" : "height") {
					            percentDone = (settings.end - settings.start === 0) ? 0 :
							(settings.now - settings.start) /
							(settings.end - settings.start);
					        }

					        val = (percentDone * showProps[settings.prop].value);
					        if (val < 0) {
					            //fix for 16943:
					            val = 0;
					        }
					        options.toShow[0].style[settings.prop] =
											val + showProps[settings.prop].unit;

					    };
       duration=300;easing=swing;complete=function () {...}; 
*/

/*
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
*/;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/// <reference path="../external/declarations/globalize.d.ts"/>
/*globals window document clearTimeout setTimeout jQuery */
/*
* Depends:
*	jQuery.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jQuery.ui.position.js
*	jquery.bgiframe-2.1.3-pre.js
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijtooltip", defaultTooltipKey = "@wijtp@", tipCss = "wijmo-wijtooltip", calloutCssPrefix = tipCss + "-arrow-", parseF = parseFloat, win = window, doc = document, math = Math, max = math.max, oldTipPos = {
    };
    var wijtooltip = (function (_super) {
        __extends(wijtooltip, _super);
        function wijtooltip() {
            _super.apply(this, arguments);

        }
        wijtooltip._tooltips = new Array();
        wijtooltip.prototype._setOption = function (key, value) {
            var self = this, funName = "_set_" + key, oldValue = self.options[key];
            _super.prototype._setOption.call(this, key, value);
            if($.isPlainObject(value)) {
                self.options[key] = $.extend({
                }, oldValue, value);
            }
            if(self[funName]) {
                self[funName](oldValue);
            }
        };
        wijtooltip.prototype._set_cssClass = //fix the issue 21416: cssClass does not show.
        function () {
            var self = this, o = self.options, tooltip = self._tooltipCache._$tooltip;
            if(!tooltip) {
                return;
            }
            if(!tooltip.hasClass(o.cssClass)) {
                tooltip.addClass(o.cssClass);
            }
        };
        wijtooltip.prototype._set_content = function (value) {
            var self = this;
            if(self._isAjaxCallback) {
                self._callbacked = true;
                self.show();
                self._callbacked = false;
            } else {
                self._setText();
            }
        };
        wijtooltip.prototype._create = function () {
            var self = this, o = self.options, element = self.element, id = element && element.attr("id"), describedBy = "", cssClass = "", key = o.group || defaultTooltipKey, tooltip = wijtooltip._getTooltip(key);
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(tooltip) {
                tooltip.count++;
            } else {
                tooltip = self._createTooltip();
                tooltip.count = 0;
                wijtooltip._tooltips[key] = tooltip;
            }
            //fix the issue 21416: cssClass does not show.
            cssClass = o.cssClass ? o.cssClass : "";
            if(!tooltip._$tooltip.hasClass(cssClass)) {
                tooltip._$tooltip.addClass(cssClass);
            }
            o.position.of = self.element;
            self._bindLiveEvents();
            self._tooltipCache = tooltip;
            if(id !== "") {
                describedBy = tooltip._$tooltip.attr("aria-describedby");
                describedBy = describedBy === undefined ? "" : describedBy + " ";
                tooltip._$tooltip.attr("aria-describedby", describedBy + id);
            }
        };
        wijtooltip.prototype.destroy = function () {
            /// <summary>
            ///	Removes the wijtooltip functionality completely.
            ///	This returns the element back to its pre-init state.
            /// </summary>
                        var self = this, element = self.element, key = self.options.group || defaultTooltipKey;
            element.unbind(".tooltip");
            element.attr("title", self._content);
            wijtooltip._removeTooltip(key);
            _super.prototype.destroy.call(this);
        };
        wijtooltip.prototype.widget = function () {
            /// <summary>
            /// Returns the wijtooltip element.
            /// Code example:
            /// $("#tooltip").wijtooltip("widget");
            /// </summary>
            return this._tooltipCache._$tooltip;
        };
        wijtooltip.prototype.show = //public methods
        function () {
            /// <summary>
            ///	Shows the tooltip
            /// Code example:
            /// $("#tooltip").wijtooltip("show");
            /// </summary>
                        var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, o = self.options;
            if(!tooltipCache || o.disabled) {
                return;
            }
            if(tooltipCache._showAnimationTimer) {
                clearTimeout(tooltipCache._showAnimationTimer);
                tooltipCache._showAnimationTimer = null;
            }
            if(tooltipCache._showAtAnimationTimer) {
                clearTimeout(tooltipCache._showAtAnimationTimer);
                tooltipCache._showAtAnimationTimer = null;
            }
            if(tooltipCache._hideAnimationTimer) {
                clearTimeout(tooltipCache._hideAnimationTimer);
                tooltipCache._hideAnimationTimer = null;
            }
            _$tooltip.stop(true, true);
            if(o.ajaxCallback && $.isFunction(o.ajaxCallback) && !self._callbacked) {
                self._isAjaxCallback = true;
                o.ajaxCallback.call(self.element);
                return;
            }
            self._setText();
            tooltipCache._showAnimationTimer = setTimeout(function () {
                //self._setText();
                oldTipPos = _$tooltip.offset();
                if(o.mouseTrailing) {
                    self._setCalloutCss();
                    return;
                }
                self._setPosition();
                self._showTooltip();
            }, self.options.showDelay);
        };
        wijtooltip.prototype.showAt = function (point) {
            /// <summary>
            ///	Show the tooltip at the specified position
            ///	</summary>
            /// <param name="point" type="Object">
            ///	A point value that indicates the position that tooltip will be shown.
            /// Code example:
            /// $("#tooltip").wijtooltip("showAt", {x:100, y:120});
            /// </param>
                        var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache ? tooltipCache._callout : null, calloutPos, offsetX = 0, offsetY = 0, offset = {
            }, calloutShape, border, hBorder, vBorder, width, height;
            if(!tooltipCache || !callout) {
                return;
            }
            _$tooltip.stop(true, true);
            if(tooltipCache._showAtAnimationTimer) {
                clearTimeout(tooltipCache._showAtAnimationTimer);
                tooltipCache._showAtAnimationTimer = null;
            }
            if(tooltipCache._hideAnimationTimer) {
                clearTimeout(tooltipCache._hideAnimationTimer);
                tooltipCache._hideAnimationTimer = null;
            }
            tooltipCache._showAtAnimationTimer = setTimeout(function () {
                var visible = _$tooltip.is(":visible");
                self._setText();
                oldTipPos = _$tooltip.offset();
                _$tooltip.offset({
                    left: 0,
                    top: 0
                }).show();
                calloutPos = callout.position();
                offsetX = calloutPos.left;
                offsetY = calloutPos.top;
                border = self._getBorder(callout);
                hBorder = border.left || border.right;
                vBorder = border.top || border.bottom;
                width = _$tooltip.width();
                height = _$tooltip.height();
                calloutShape = self._getCalloutShape();
                offset = {
                    "rt": {
                        left: point.x - width - hBorder,
                        top: point.y - offsetY
                    },
                    "rc": {
                        left: point.x - width - hBorder,
                        top: point.y - height / 2
                    },
                    "rb": {
                        left: point.x - width - hBorder,
                        top: point.y - offsetY - vBorder
                    },
                    "lt": {
                        left: point.x + hBorder,
                        top: point.y - offsetY
                    },
                    "lc": {
                        left: point.x + hBorder,
                        top: point.y - height / 2
                    },
                    "lb": {
                        left: point.x + hBorder,
                        top: point.y - offsetY - vBorder
                    },
                    "tl": {
                        left: point.x - offsetX,
                        top: point.y + vBorder
                    },
                    "tc": {
                        left: point.x - width / 2,
                        top: point.y + vBorder
                    },
                    "tr": {
                        left: point.x - offsetX - hBorder,
                        top: point.y + vBorder
                    },
                    "bl": {
                        left: point.x - offsetX,
                        top: point.y - height - vBorder
                    },
                    "bc": {
                        left: point.x - width / 2,
                        top: point.y - height - vBorder
                    },
                    "br": {
                        left: point.x - offsetX - hBorder,
                        top: point.y - height - vBorder
                    },
                    "cc": {
                        left: point.x - width / 2,
                        top: point.y - height / 2
                    }
                }[calloutShape];
                calloutShape = self._flipTooltip(offset, calloutShape, border);
                self._setUnfilledCallout(calloutShape);
                _$tooltip.offset(offset)//.hide();
                ;
                if(!visible) {
                    _$tooltip.hide();
                }
                self._calloutShape = calloutShape;
                self._showTooltip();
            }, self.options.showDelay);
        };
        wijtooltip.prototype.hide = function () {
            /// <summary>
            ///	Hides the tooltip
            /// Code example:
            /// $("#tooltip").wijtooltip("hide");
            /// </summary>
                        var self = this, tooltipCache = self._tooltipCache;
            if(!tooltipCache) {
                return;
            }
            if(tooltipCache._showAnimationTimer) {
                clearTimeout(tooltipCache._showAnimationTimer);
                tooltipCache._showAnimationTimer = null;
            }
            if(tooltipCache._showAtAnimationTimer) {
                clearTimeout(tooltipCache._showAtAnimationTimer);
                tooltipCache._showAtAnimationTimer = null;
            }
            if(tooltipCache._hideAnimationTimer) {
                clearTimeout(tooltipCache._hideAnimationTimer);
                tooltipCache._hideAnimationTimer = null;
            }
            //clearTimeout(tooltip._showAnimationTimer);
            tooltipCache._hideAnimationTimer = setTimeout($.proxy(self._hideTooltip, self), self.options.hideDelay);
        };
        wijtooltip.prototype._createTooltip = //begin private methods
        function () {
            var self = this, o = self.options, tooltipCache = new TooltipCache(), _$tooltip = $("<div></div>").addClass(o.wijCSS.tooltip).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll), container = $("<div></div>").addClass(o.wijCSS.tooltipContainer), callout = $("<div></div>").addClass(o.wijCSS.content).addClass(o.wijCSS.tooltipPointer).append($("<div></div>").addClass(o.wijCSS.tooltipPointerInner)), title = $("<div></div>").addClass(o.wijCSS.tooltipTitle).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll), closeBtn = $("<a href='#'></a>").addClass(o.wijCSS.tooltipClose).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
            closeBtn.append($("<span></span>").addClass(o.wijCSS.icon).addClass(o.wijCSS.iconClose)).bind("click", $.proxy(self._onClickCloseBtn, self));
            if(o.closeBehavior !== "sticky") {
                closeBtn.hide();
            }
            if(!o.showCallout) {
                callout.hide();
            }
            _$tooltip.append(title).append(closeBtn).append(container).append(callout).css("position", "absolute").attr("role", "tooltip").appendTo("body").hide();
            tooltipCache._$tooltip = _$tooltip;
            tooltipCache._container = container;
            tooltipCache._callout = callout;
            tooltipCache._closeBtn = closeBtn;
            tooltipCache._title = title;
            return tooltipCache;
        };
        wijtooltip.prototype._bindLiveEvents = function () {
            var self = this, o = self.options, element = self.element;
            if(self._content === undefined) {
                self._content = element.attr("title");
                element.attr("title", "");
            }
            element.unbind('.tooltip');
            if(o.mouseTrailing) {
                element.bind("mousemove.tooltip", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    var offset = o.position.offset || "", offsets = offset.split(" ");
                    if(offsets.length === 2) {
                        self.showAt({
                            x: e.pageX + parseInt(offsets[0], 10),
                            y: e.pageY + parseInt(offsets[1], 10)
                        });
                    } else {
                        self.showAt({
                            x: e.pageX,
                            y: e.pageY
                        });
                    }
                });
            }
            switch(o.triggers) {
                case "hover":
                    element.bind("mouseover.tooltip", $.proxy(self.show, self)).bind("mouseout.tooltip", $.proxy(self._hideIfNeeded, self));
                    break;
                case "click":
                    element.bind("click.tooltip", $.proxy(self.show, self));
                    break;
                case "focus":
                    element.bind("focus.tooltip", $.proxy(self.show, self)).bind("blur.tooltip", $.proxy(self._hideIfNeeded, self));
                    break;
                case "rightClick":
                    element.bind("contextmenu.tooltip", function (e) {
                        self.show();
                        e.preventDefault();
                    });
                    break;
            }
        };
        wijtooltip.prototype._hideIfNeeded = function () {
            var self = this, o = self.options, closeBehavior = o.closeBehavior;
            if(closeBehavior === "sticky" || o.modal || closeBehavior === "none" || o.disabled) {
                return;
            }
            self.hide();
        };
        wijtooltip.prototype._flipTooltip = function (pos, calloutShape, calloutBorder) {
            var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, bound = {
                width: _$tooltip.width(),
                height: _$tooltip.height()
            }, flipCallout = self._flipCallout(pos, bound, calloutShape), flip = flipCallout && flipCallout.flip, width, height;
            if(!tooltipCache || !flipCallout || (!flip.h && !flip.v)) {
                return flipCallout.calloutShape;
            }
            width = _$tooltip.width();
            height = _$tooltip.height();
            if(flip.h === "l") {
                pos.left -= (width + calloutBorder.right * 2) + 1;
            } else if(flip.h === "r") {
                pos.left += (width + calloutBorder.left * 2) + 1;
            } else if(flip.v === "t") {
                pos.top -= (height + calloutBorder.bottom * 2) + 1;
            } else if(flip.v === "b") {
                pos.top += (height + calloutBorder.top * 2) + 1;
            }
            return flipCallout.calloutShape;
        };
        wijtooltip.prototype._flipCallout = function (pos, bound, calloutShape) {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache._$tooltip, flip = {
                h: false,
                v: false
            }, jqWin = $(win), collision = (o.position.collision || "flip").split(" ");
            if(collision.length === 1) {
                collision[1] = collision[0];
            }
            if(!tooltipCache || (collision[0] !== "flip" && collision[1] !== "flip")) {
                return {
                    flip: flip,
                    calloutShape: null
                };
            }
            if(collision[0] === "flip") {
                if(pos.left < 0 || pos.left + bound.width > jqWin.width() + jqWin.scrollLeft()) {
                    flip.h = true;
                }
            }
            if(collision[0] === "flip") {
                if(pos.top < 0 || pos.top + bound.height > jqWin.height() + jqWin.scrollTop()) {
                    flip.v = true;
                }
            }
            //fix the issue 21386, calloutShape undefind
            if(o.showCallout) {
                if(flip.h) {
                    if(calloutShape.indexOf('l') > -1) {
                        calloutShape = calloutShape.replace(/l/, 'r');
                        flip.h = "l";
                    } else if(calloutShape.indexOf('r') > -1) {
                        calloutShape = calloutShape.replace(/r/, 'l');
                        flip.h = "r";
                    }
                }
                if(flip.v) {
                    if(calloutShape.indexOf('t') > -1) {
                        calloutShape = calloutShape.replace(/t/, 'b');
                        flip.v = "t";
                    } else if(calloutShape.indexOf('b') > -1) {
                        calloutShape = calloutShape.replace(/b/, 't');
                        flip.v = "b";
                    }
                }
                if(flip.h || flip.v) {
                    self._removeCalloutCss();
                    _$tooltip.addClass(calloutCssPrefix + calloutShape);
                }
            }
            return {
                flip: flip,
                calloutShape: calloutShape
            };
        };
        wijtooltip.prototype._set_position = //methods for options setters
        function (oldValue) {
            var self = this, o = self.options, val = o.position;
            if(o.showCallout) {
                if(oldValue.my !== val.my || oldValue.at !== val.at) {
                    self._setPosition();
                }
                self._setCalloutOffset(true);
            }
            //fix the issue 21467.
            self._setText();
        };
        wijtooltip.prototype._set_showCallout = function () {
            var self = this, tooltipCache = self._tooltipCache, callout = tooltipCache ? tooltipCache._callout : null;
            if(!tooltipCache || !callout) {
                return;
            }
            if(self.options.showCallout) {
                self._setCalloutCss();
                callout.show();
            } else {
                callout.hide();
            }
        };
        wijtooltip.prototype._set_closeBehavior = function () {
            var self = this, tooltipCache = self._tooltipCache, closeBtn = tooltipCache ? tooltipCache._closeBtn : null;
            if(closeBtn) {
                closeBtn[self.options.closeBehavior === "sticky" ? "show" : "hide"]();
            }
        };
        wijtooltip.prototype._set_triggers = function () {
            this._bindLiveEvents();
        };
        wijtooltip.prototype._set_mouseTrailing = function () {
            this._bindLiveEvents();
        };
        wijtooltip.prototype._getCalloutShape = //end of methods for options setters.
        function () {
            var self = this, position = self.options.position, makeArr = //makeArr = function (items) {
            //	return $.map(items, function (item) {
            //		return item.substr(0, 1);
            //	});
            //},
            function (items) {
                return $.makeArray($.map(items, function (item) {
                    return item.substr(0, 1);
                }));
            }, myItems = makeArr(position.my.split(" ")), atItems = makeArr(position.at.split(" ")), shape = [];
            if(myItems.length === 2) {
                shape = myItems;
            }
            if(myItems[0] === atItems[0]) {
                if((myItems[1] === 't' && atItems[1] === 'b') || (myItems[1] === 'b' && atItems[1] === 't')) {
                    shape.reverse();
                }
            } else if(atItems[0] === 'c') {
                shape.reverse();
            }
            if(shape[0] === 'c') {
                shape.reverse();
            }
            return shape.join("");
        };
        wijtooltip.prototype._setCalloutCss = function () {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, cssName = "", calloutShape = "", isTouchEnabled = $.support.isTouchEnabled;
            if(!o.showCallout && !isTouchEnabled) {
                return;
            }
            self._removeCalloutCss();
            calloutShape = self._getCalloutShape();
            cssName = calloutCssPrefix + calloutShape;
            if(_$tooltip) {
                _$tooltip.addClass(cssName);
            }
            return calloutShape;
        };
        wijtooltip.prototype._removeCalloutCss = function () {
            var tooltipCache = this._tooltipCache, _$tooltip;
            if(tooltipCache) {
                _$tooltip = tooltipCache._$tooltip;
                $.each([
                    "tl", 
                    "tc", 
                    "tr", 
                    "bl", 
                    "bc", 
                    "br", 
                    "rt", 
                    "rc", 
                    "rb", 
                    "lt", 
                    "lc", 
                    "lb", 
                    "cc"
                ], function (idx, compass) {
                    var cssName = calloutCssPrefix + compass;
                    if(_$tooltip.hasClass(cssName)) {
                        _$tooltip.removeClass(cssName);
                        return false;
                    }
                });
            }
        };
        wijtooltip.prototype._getBorder = function (element) {
            var obj = {
            };
            $.each([
                "top", 
                "right", 
                "left", 
                "bottom"
            ], function (idx, compass) {
                obj[compass] = parseF(element.css("border-" + compass + "-width"));
            });
            return obj;
        };
        wijtooltip.prototype._setPosition = function () {
            var self = this, o = self.options, position = o.position, my = position.my, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, isHidden = _$tooltip.is(":hidden"), calloutShape = self._setCalloutCss(), arrCalloutShape = calloutShape ? calloutShape.split('') : null, offset = [
                0, 
                0
            ], callout = //sOffset = "",
            tooltipCache._callout, border, top, left, right, bottom, bound = {
                width: _$tooltip.width(),
                height: _$tooltip.height()
            }, flipCallout, flip, isTouchEnabled = $.support.isTouchEnabled;
            if(isHidden) {
                _$tooltip.show();
            }
            _$tooltip.css({
                left: 0,
                top: 0
            });
            if(o.showCallout) {
                border = self._getBorder(callout);
                left = parseF(callout.css("left"));
                top = parseF(callout.css("top"));
                right = parseF(callout.css("right"));
                bottom = parseF(callout.css("bottom"));
                switch(arrCalloutShape[0]) {
                    case "l":
                        offset[0] = border.right;
                        break;
                    case "r":
                        offset[0] = -border.left;
                        break;
                    case "b":
                        offset[1] = bottom;
                        break;
                    case "t":
                        offset[1] = -top;
                        break;
                }
                switch(arrCalloutShape[1]) {
                    case "t":
                        offset[1] = -top;
                        break;
                    case "b":
                        offset[1] = bottom;
                        break;
                    case "r":
                        offset[0] = right;
                        break;
                    case "l":
                        offset[0] = -left;
                        break;
                }
                //sOffset = offset.join(" ");
                            }
            if(isTouchEnabled) {
                switch(arrCalloutShape[0]) {
                    case "l":
                        offset[0] = offset[0] + 30;
                        break;
                    case "r":
                        offset[0] = offset[0] - 30;
                        break;
                    case "b":
                        offset[1] = offset[1] - 30;
                        break;
                    case "t":
                        offset[1] = offset[1] + 30;
                        break;
                }
                switch(arrCalloutShape[1]) {
                    case "t":
                        offset[1] = offset[1] + 30;
                        break;
                    case "b":
                        offset[1] = offset[1] - 30;
                        break;
                    case "r":
                        offset[0] = offset[0] - 30;
                        break;
                    case "l":
                        offset[0] = offset[0] + 30;
                        break;
                }
                //sOffset = offset.join(" ");
                            }
            //"left+10 top+-10"
            if(position.my.indexOf(" ") > -1) {
                my = position.my.split(" ")[0] + "+" + offset[0] + " " + position.my.split(" ")[1] + "+" + offset[1];
            } else {
                my = position.my + "+" + offset[0] + " " + position.my + "+" + offset[1];
            }
            _$tooltip.position({
                my: my,
                at: position.at,
                of: position.of,
                collision: //offset: sOffset, collision: "none none"
                "none none"
            });
            flipCallout = self._flipCallout(_$tooltip.offset(), bound, calloutShape);
            flip = flipCallout.flip;
            if(flip.h || flip.v) {
                _$tooltip.css({
                    left: 0,
                    top: 0
                });
                _$tooltip.position({
                    my: my,
                    at: position.at,
                    of: position.of,
                    collision: //offset: sOffset, collision: position.collision
                    position.collision
                });
            }
            if(o.showCallout) {
                self._setUnfilledCallout(calloutShape);
            }
            self._calloutShape = calloutShape;
            if(isHidden) {
                _$tooltip.hide();
            }
        };
        wijtooltip.prototype._setCalloutOffset = function (showCalloutAnimation) {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, calloutShape = self._calloutShape, horizontal = false, offset = o.position.offset, value = "", offsetItems = [], calloutAnimation = o.calloutAnimation;
            if(!callout) {
                return;
            }
            if(!offset || offset.length === 0) {
                return;
            }
            callout.stop(true, true);
            $.each([
                "tr", 
                "tc", 
                "tl", 
                "bl", 
                "bc", 
                "br"
            ], function (idx, compass) {
                if(calloutShape === compass) {
                    horizontal = true;
                    return false;
                }
            });
            if(offset) {
                offsetItems = offset.split(" ");
                if(offsetItems.length === 2) {
                    value = horizontal ? offsetItems[0] : offsetItems[1];
                } else if(offsetItems.length === 1) {
                    value = offsetItems[0];
                }
            }
            //when 'position.offset' is set "none none",
            //the properties left and top of the 'callout' element in the tooltip
            //need to be removed.
            if(offsetItems && offsetItems.length === 2 && offsetItems[0] === "none" && offsetItems[1] === "none") {
                callout.css("left", "").css("top", "");
            } else if(value === "none") {
                callout.css(horizontal ? "left" : "top", "");
            } else if(value !== "") {
                if(showCalloutAnimation && !showCalloutAnimation.disabled) {
                    if(horizontal) {
                        callout.animate({
                            left: value
                        }, calloutAnimation.duration, calloutAnimation.easing);
                    } else {
                        callout.animate({
                            top: value
                        }, calloutAnimation.duration, calloutAnimation.easing);
                    }
                } else {
                    callout.css(horizontal ? "left" : "top", value);
                }
            }
        };
        wijtooltip.prototype._setUnfilledCallout = function (calloutShape) {
            var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, innerCallout = callout && callout.children(), arrCalloutSharp = calloutShape.split(''), borderColor = _$tooltip ? _$tooltip.css("background-color") : "";
            if(!innerCallout) {
                return;
            }
            innerCallout.css({
                "border-left-color": "",
                "border-top-color": "",
                "border-bottom-color": "",
                "border-right-color": ""
            });
            if(!self.options.calloutFilled) {
                switch(arrCalloutSharp[0]) {
                    case "l":
                        innerCallout.css("border-right-color", borderColor);
                        break;
                    case "t":
                        innerCallout.css("border-bottom-color", borderColor);
                        break;
                    case "r":
                        innerCallout.css("border-left-color", borderColor);
                        break;
                    case "b":
                        innerCallout.css("border-top-color", borderColor);
                        break;
                }
            }
        };
        wijtooltip.prototype._showTooltip = function () {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, showAnimation, animations, curPos;
            if(!tooltipCache) {
                return;
            }
            if(self._trigger("showing", null, self) === false) {
                return;
            }
            self._showModalLayer();
            _$tooltip.css("z-index", 99999);
            if($.fn.wijshow) {
                animations = {
                    show: true,
                    context: _$tooltip
                };
                showAnimation = $.extend({
                }, o.animation, o.showAnimation);
                if(_$tooltip.is(":visible")) {
                    curPos = _$tooltip.offset();
                    _$tooltip.offset(oldTipPos);
                    $.extend(animations, {
                        pos: curPos
                    });
                    showAnimation.animated = "tooltipSlide";
                }
                _$tooltip.wijshow(showAnimation, wijtooltip.animations, animations, null, function () {
                    self._trigger("shown");
                });
            } else {
                _$tooltip.show();
                self._trigger("shown");
            }
            self._setCalloutOffset(false);
        };
        wijtooltip.prototype._hideTooltip = function () {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, hideAnimation = $.extend({
            }, o.animation, o.hideAnimation), animations;
            if(!tooltipCache) {
                return;
            }
            if(self._trigger("hiding", null, self) === false) {
                return;
            }
            self._hideModalLayer();
            if($.fn.wijhide) {
                animations = {
                    show: false,
                    context: _$tooltip
                };
                _$tooltip.wijhide(hideAnimation, wijtooltip.animations, animations, null, function () {
                    self._trigger("hidden");
                    _$tooltip.css("z-index", "");
                });
            } else {
                _$tooltip.hide();
                self._trigger("hidden");
                _$tooltip.css("z-index", "");
            }
        };
        wijtooltip.prototype._getContent = function (content) {
            var obj = {
                data: ""
            }, retValue;
            if($.isFunction(content)) {
                retValue = content.call(this.element, obj);
                if(obj.data !== "") {
                    return obj.data;
                } else {
                    return retValue;
                }
            } else if(window[content] && $.isFunction(window[content])) {
                // if window[content/title] is a function, then get the
                // function value.
                retValue = window[content].call(this.element, obj);
                if(obj.data !== "") {
                    return obj.data;
                } else {
                    return retValue;
                }
            }
            return content;
        };
        wijtooltip.prototype._setText = function () {
            var self = this, o = self.options, tooltipCache = self._tooltipCache, content = "", title = "", jqTitle = tooltipCache ? tooltipCache._title : null;
            if(!tooltipCache) {
                return;
            }
            content = self._getContent(o.content);
            content = content === "" ? self._content : content;
            tooltipCache._container.html(content);
            title = self._getContent(o.title);
            if(title !== "") {
                jqTitle.html(title).show();
            } else {
                jqTitle.hide();
            }
        };
        wijtooltip.prototype._showModalLayer = function () {
            var self = this, o = self.options, modalLayer = null;
            if(self.options.modal) {
                modalLayer = $("<div>").addClass(o.wijCSS.overlay).css("z-index", 99000).width(self._getDocSize("Width")).height(self._getDocSize("Height")).appendTo("body");
                $(window).bind("resize.wijtooltip", function () {
                    modalLayer.width(self._getDocSize("Width")).height(self._getDocSize("Height"));
                });
                self._tooltipCache._modalLayer = modalLayer;
            }
        };
        wijtooltip.prototype._hideModalLayer = function () {
            var self = this, modalLayer = self._tooltipCache._modalLayer;
            if(modalLayer) {
                modalLayer.css("z-index", "").remove();
                $(window).unbind("resize.wijtooltip");
            }
        };
        wijtooltip.prototype._getDocSize = function (name) {
            var scrollValue, offsetValue, de = "documentElement", body = "body";
            // handle IE 6
            if($.browser.msie && parseFloat($.browser.version) < 9) {
                scrollValue = max(doc[de]["scroll" + name], doc[body]["scroll" + name]);
                offsetValue = max(doc[de]["offset" + name], doc[body]["offset" + name]);
                return (scrollValue < offsetValue ? ($(win)[name.toLowerCase()]() + 'px') : scrollValue + 'px');
            } else {
                return $(doc)[name.toLowerCase()]() + 'px';
            }
        };
        wijtooltip.prototype._onClickCloseBtn = //begin event handler methods
        function (e) {
            this.hide();
            e.preventDefault();
        };
        wijtooltip.animations = {
            fade: function (options, additions) {
                options = $.extend({
                    duration: 300,
                    easing: "swing"
                }, options, additions);
                options.context.stop(true, true).animate(options.show ? {
                    opacity: 'show'
                } : {
                    opacity: 'hide'
                }, options);
            },
            tooltipSlide: function (options, additions) {
                options = $.extend({
                    duration: 300,
                    easing: "swing"
                }, options, additions);
                options.context.stop(true, true).animate({
                    left: options.pos.left,
                    top: options.pos.top
                }, options);
            }
        };
        wijtooltip._getTooltip = function _getTooltip(key) {
            return wijtooltip._tooltips[key];
        };
        wijtooltip._removeTooltip = function _removeTooltip(key) {
            var tooltipCache = wijtooltip._tooltips[key], _$tooltip = tooltipCache ? tooltipCache._$tooltip : null;
            if(tooltipCache) {
                tooltipCache.count--;
                if(tooltipCache.count <= 0) {
                    _$tooltip.remove();
                    wijtooltip._tooltips[key] = null;
                }
                //tooltip = null;
                            }
        };
        return wijtooltip;
    })(wijmo.wijmoWidget);
    wijmo.wijtooltip = wijtooltip;    
    //#endregion
    //#region options
    wijtooltip.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijtooltip')",
        wijCSS: /// <summary>
        /// tooltip css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            tooltip: "wijmo-wijtooltip",
            tooltipContainer: "wijmo-wijtooltip-container",
            tooltipPointer: "wijmo-wijtooltip-pointer",
            tooltipPointerInner: "wijmo-wijtooltip-pointer-inner",
            tooltipTitle: "wijmo-wijtooltip-title",
            tooltipClose: "wijmo-wijtooltip-close"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body-a",
            stateDefault: "ui-btn-up-a",
            stateHover: "ui-btn-down-a",
            stateActive: "ui-btn-down-a"
        },
        content: /// <summary>
        /// Sets the tooltip's content..
        /// Type: String or Function.
        /// Default: "".
        /// Remarks: The value can be a string, html code, or a function.
        /// If it is a function, then the content will be
        /// the function's return value.
        /// Code example: $(".selector").wijtooltip("option", "content", "content").
        /// </summary>
        '',
        title: /// <summary>
        /// Specifies a value that sets the tooltip's title.
        /// Type: String or Function.
        /// Default: "".
        /// Code example: $(".selector").wijtooltip("option", "title", "title");
        /// Remark: The value can be a string, html code, or a function.
        /// If it is a function, then the title will be
        /// the function's return value.
        /// </summary>
        "",
        closeBehavior: /// <summary>
        /// Determines how to close the tooltip. Behaviors include auto or sticky.
        /// Type: String.
        /// Default: "auto".
        /// Options: "auto", "none" and "sticky".
        /// Code example: $(".selector")
        ///				.wijtooltip("option", "closeBehavior", "auto").
        /// </summary>
        'auto',
        mouseTrailing: /// <summary>
        /// If true, then the tooltip moves with the mouse.
        /// Type: Boolean.
        /// Default: false.
        /// Code example: $(".selector").wijtooltip("option", "mouseTrailing", false).
        /// </summary>
        false,
        triggers: /// <summary>
        /// Sets the event that will cause the tooltip to appear.
        /// Type: String
        /// Default: "hover".
        /// Options: "hover", "click", "focus", "rightClick", "custom".
        /// Code example: $(".selector").wijtooltip("option", "triggers", "hover").
        /// </summary>
        'hover',
        position: /// <summary>
        /// Sets the tooltip's position mode in relation to the 'relativeTo',
        /// 'offsetX', and 'offsetY' properties. For example,
        /// here is the jQuery ui position's position:
        /// {my:'top left',at:'right bottom',offset:}.
        /// Type: Object.
        /// Default: { my: "left bottom", at: "right top", offset: null}
        /// Code expamle: $(".selector").wijtooltip("option", "position",
        ///				{my: 'left bottom', at: 'right top', offset: '0 0'}).
        /// </summary>
        {
            my: 'left bottom',
            at: 'right top',
            offset: null
        },
        showCallout: /// <summary>
        /// Determines whether to show the callout element.
        /// Type: Boolean.
        /// Default: true.
        /// Code example: $(".selector").wijtooltip("option", "showCallout", true).
        /// </summary>
        true,
        animation: /// <summary>
        /// Sets showAnimation and hideAnimation if they are
        /// not specified individually.
        /// Default: { animated: "fade", duration: 500, easing: null }.
        /// Type: Object.
        /// Remark: User's standard animation setting syntax from other widgets.
        /// Code example:
        /// $(".selector").wijtooltip("option", "animation",
        /// {animated: "fade", duration: 400, easing: null})
        /// </summary>
        {
            animated: "fade",
            duration: 500,
            easing: null
        },
        showAnimation: /// <summary>
        /// Determines the animation effect that will be shown.
        /// Type: Object.
        /// Default: {}.
        /// Remarks: This should be an object value. Possible values include:
        /// 'animated', 'duration', and 'easing'.
        /// This property works with jQuery animation..
        /// Code example: $(".selector").wijtooltip("option", "showAnimation",
        ///				{animated: "fade", duration: 500, easing: "linear"}).
        /// </summary>
        {
        },
        hideAnimation: /// <summary>
        /// Determines whether the animation effect can be seen.
        /// Type: Object.
        /// Default: {animated: 'fade', duration:500, easing: null}.
        /// Remarks: This should be an object value,
        /// like the showAnimation property.
        /// Code example: $(".selector").wijtooltip("option", "hideAnimation",
        ///				{animated: "fade", duration: 500, easing: null}).
        /// </summary>
        {
        },
        showDelay: /// <summary>
        /// Determines the length of the delay before the tooltip appears.
        /// Type: Number
        /// Default: 150.
        /// Code example: $(".selector").wijtooltip("option", "showDelay", 200).
        /// </summary>
        150,
        hideDelay: /// <summary>
        /// Determines the length of the delay before the tooltip disappears.
        /// Type: Number.
        /// Default: 150.
        /// Code example: $(".selector").wijtooltip("option", "hideDelay", 200).
        /// </summary>
        150,
        calloutAnimation: /// <summary>
        /// Sets the callout's offset changing animation..
        /// Type: Object.
        /// Default: {duration: 1000, disabled: false, easing: null}.
        /// Code example: $(".selector").wijtooltip("option",
        ///				"calloutAnimation", {easing: "swing", duration: 200}).
        /// </summary>
        {
            duration: 1000,
            disabled: false,
            easing: null
        },
        calloutFilled: /// <summary>
        /// Determines the callout's class style.
        /// If true, then the callout triangle will be filled..
        /// Type: Boolean.
        /// Default: false.
        /// Code example: $(".selector").wijtooltip("option", "calloutFilled", false).
        /// </summary>
        false,
        modal: /// <summary>
        /// A value that indicates whether to show the modal tooltip.
        /// Type: Boolean.
        /// Default: false.
        /// Code example: $(".selector").wijtooltip("option", "modal", true).
        /// </summary>
        false,
        group: /// <summary>
        /// A value that indicates which group the tooltip belongs to.
        /// Type: String.
        /// Default: null.
        /// Code example: $(".selector").wijtooltip("option", "group", "A").
        /// </summary>
        null,
        ajaxCallback: /// <summary>
        /// A function that defines a callback when user use ajax to set
        /// content property.
        /// Default: false.
        /// Type: Function.
        /// Code example: $(".selector").wijtooltip("option",
        /// "ajaxCallback", function () {}).
        /// Remark: In ajax's complete callback method, user set callback
        /// data to the content option.
        /// </summary>
        null,
        showing: /// <summary>
        /// Trigegred before showing the tooltip
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $(".selector").wijtooltip("showing",function(e, ui){})
        /// Bind to the event by type: wijtooltipshowing
        /// $(".selector").bind("wijtooltipshowing", function(e, ui) { } );
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="ui" type="Object">
        /// The wijtooltip widget.
        /// </param>
        /// <returns type="Boolean">
        /// Return false to cancel the showing event.
        /// </returns>
        null,
        shown: /// <summary>
        /// Triggered once the tooltip has shown.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $(".selector").wijtooltip("shown",function(e, ui){})
        /// Bind to the event by type: wijtooltipshown
        /// $(".selector").bind("wijtooltipshown", function(e, ui) { } );
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="ui" type="Object">
        /// The wijtooltip widget object.
        /// </param>
        null,
        hiding: /// <summary>
        /// Triggered before hiding the tooltip.If data.cancel is
        /// set to true, then the tooltip is no longer hidden
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $(".selector").wijtooltip("hiding", function(e, ui){})
        /// Bind to the event by type: wijtooltiphiding
        /// $(".selector").bind("wijtooltiphiding", function(e, ui) { } );
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="ui" type="Object">
        /// The wijtooltip widget object.
        /// </param>
        /// <returns type="Boolean">
        /// Return false to cancel the hiding event.
        /// </returns>
        null,
        hidden: /// <summary>
        /// Triggered once the tooltip has hidden.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $(".selector").wijtooltip("hidden",function(e, ui){})
        /// Bind to the event by type: wijtooltiphidden
        /// $(".selector").bind("wijtooltiphidden", function(e, ui) { } );
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="ui" type="Object">
        /// The wijtooltip widget object.
        /// </param>
        null,
        cssClass: /// <summary>
        /// A value that indicates whether to set user-defined class.
        /// Type: String.
        /// Default: "".
        /// Code example:
        /// $(".selector").wijtooltip("option", "cssClass", cssClass).
        /// </summary>
        ""
    });
    //#endregion
    $.wijmo.registerWidget(widgetName, wijtooltip.prototype);
})(wijmo || (wijmo = {}));
var TooltipCache = (function () {
    function TooltipCache() { }
    return TooltipCache;
})();
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals window,document,jQuery*/
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.mouse.js
*  jquery.ui.widget.js
*  jquery.ui.slider.js
*  jquery.ui.wijutil.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijslider";
    var JQueryUISlider = (function (_super) {
        __extends(JQueryUISlider, _super);
        function JQueryUISlider() {
            _super.apply(this, arguments);

        }
        JQueryUISlider.prototype._valueMin = function () {
            return this._super();
        };
        JQueryUISlider.prototype._refreshValue = function () {
            return this._super();
        };
        JQueryUISlider.prototype._create = function () {
            return this._super();
        };
        JQueryUISlider.prototype.values = function (index, val) {
            if(index === undefined && val === undefined) {
                return this._super();
            } else if(val === undefined) {
                return this._super(index);
            } else {
                return this._super(index, val);
            }
        };
        JQueryUISlider.prototype.value = function (val) {
            if(val === undefined) {
                return this._super();
            } else {
                return this._super(val);
            }
        };
        JQueryUISlider.prototype._slide = function (event, index, newValue) {
            return this._super(event, index, newValue);
        };
        JQueryUISlider.prototype._change = function (event, index) {
            return this._super(event, index);
        };
        return JQueryUISlider;
    })(wijmo.JQueryUIWidget);
    wijmo.JQueryUISlider = JQueryUISlider;    
    var wijslider = (function (_super) {
        __extends(wijslider, _super);
        function wijslider() {
            _super.apply(this, arguments);

        }
        wijslider.prototype._setOption = function (key, value) {
            ///	<summary>
            ///		Sets Slider options.
            ///	</summary>
            var self = this;
            if(key === "values") {
                value = self._pre_set_values(value);
                self.options[key] = value;
                self._setValuesOption();
            } else {
                $.ui.slider.prototype._setOption.apply(self, arguments);
            }
            //Add for support disabled option at 2011/7/8
            if(key === "disabled") {
                self._handleDisabledOption(value, self.element.parent());
            } else if(key === "range") {
                self._setRangeOption(value);
            }
            //end for disabled option
            return this;
        };
        wijslider.prototype._setRangeOption = function (value) {
            var self = this, o = self.options, valueMin;
            if(value === true) {
                if(!o.values || (o.values && o.values.length === 0)) {
                    valueMin = self._valueMin();
                    o.values = [
                        valueMin, 
                        valueMin
                    ];
                } else if(o.values.length && o.values.length !== 2) {
                    valueMin = o.values[0];
                    o.values = [
                        valueMin, 
                        valueMin
                    ];
                }
                self._refresh_handle(2);
            }
            self._re_createRange();
            self._refreshValue();
        };
        wijslider.prototype._setValuesOption = function () {
            var self = this, valsLength = 0, i;
            self._animateOff = true;
            self._refreshValue();
            if($.isArray(self.options.values)) {
                valsLength = self.options.values.length;
            }
            for(i = 0; i < valsLength; i++) {
                self._change(null, i);
            }
            self._animateOff = false;
        };
        wijslider.prototype._re_createRange = function () {
            var self = this, o = self.options;
            if(self.range) {
                self.range.remove();
                //update for jquery ui 1.10 upgrade
                if($(".ui-slider-range", self.element).length > 0) {
                    $(".ui-slider-range", self.element).remove();
                }
            }
            if(o.range) {
                self.range = $("<div></div>").appendTo(self.element).addClass("ui-slider-range ui-widget-header" + ((o.range === "min" || o.range === "max") ? " ui-slider-range-" + o.range : ""));
            }
        };
        wijslider.prototype._pre_set_values = function (values) {
            var self = this, o = self.options, newHandleLen = 1, value;
            newHandleLen = values && values.length ? values.length : 1;
            if(o.range === true) {
                if(!values || (values && values.length === 0)) {
                    value = self._valueMin();
                    values = [
                        value, 
                        value
                    ];
                } else if(values.length && values.length !== 2) {
                    value = values[0];
                    values = [
                        value, 
                        value
                    ];
                }
                newHandleLen = 2;
            }
            self._refresh_handle(newHandleLen);
            self._re_createRange();
            return values;
        };
        wijslider.prototype._refresh_handle = function (newHandleLen) {
            var self = this, handleLen = self.handles.length, handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handles = [], i;
            if(handleLen !== newHandleLen) {
                if(newHandleLen > handleLen) {
                    for(i = handleLen; i < newHandleLen; i++) {
                        handles.push(handle);
                    }
                    self.element.append(handles.join(""));
                } else {
                    self.element.find(".ui-slider-handle").eq(newHandleLen - 1).nextAll().remove();
                }
                self.handles = self.element.find(".ui-slider-handle");
            }
        };
        wijslider.prototype._initState = function () {
            this._dragFillTarget = false;
            this._dragFillStart = 0;
            this._rangeValue = 0;
            this._oldValue1 = 0;
            this._oldValue2 = 0;
            this._oldX = 0;
            this._oldY = 0;
        };
        wijslider.prototype._create = function () {
            ///	<summary>
            ///		Creates Slider DOM elements and binds interactive events.
            ///	</summary>
                        var self = this, element = self.element, o = self.options, jqElement, val, vals, idx, len, ctrlWidth, ctrlHeight, container, decreBtn, increBtn, thumb;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            this._initState();
            self._oriStyle = element.attr("style");
            if(element.is(":input")) {
                if(o.orientation === "horizontal") {
                    jqElement = $("<div></div>").width(element.width()).appendTo(document.body);
                } else {
                    jqElement = $("<div></div>").height(element.height()).appendTo(document.body);
                }
                val = element.val();
                if(val !== "") {
                    try  {
                        vals = val.split(";");
                        len = vals.length;
                        if(len > 0) {
                            for(idx = 0; idx < len; idx++) {
                                vals[idx] = parseInt(vals[idx], 10);
                            }
                            if(len === 1) {
                                o.value = vals[0];
                            } else {
                                o.values = vals;
                            }
                        }
                    } catch (e) {
                    }
                }
                element.data(self.widgetName, jqElement.wijslider(o)).after($(document.body).children("div:last")).hide();
                //Add for support disabled option at 2011/7/8
                if(o.disabledState) {
                    var dis = o.disabled;
                    self.disable();
                    o.disabled = dis;
                }
                //end for disabled option
                return;
            }
            _super.prototype._create.call(this);
            element.data("originalStyle", element.attr("style"));
            element.data("originalContent", element.html());
            ctrlWidth = element.width();
            ctrlHeight = element.height();
            container = $("<div></div>");
            if(o.orientation === "horizontal") {
                container.addClass("wijmo-wijslider-horizontal");
            } else {
                container.addClass("wijmo-wijslider-vertical");
            }
            container.width(ctrlWidth).height(ctrlHeight);
            decreBtn = $("<a class=\"wijmo-wijslider-decbutton\"><span></span></a>");
            increBtn = $("<a class=\"wijmo-wijslider-incbutton\"><span></span></a>");
            element.wrap(container).before(decreBtn).after(increBtn);
            self._container = element.parent();
            self._attachClass();
            thumb = element.find(".ui-slider-handle");
            self._adjustSliderLayout(decreBtn, increBtn, thumb);
            //Add for support disabled option at 2011/7/8
            if(o.disabledState) {
                var dis = o.disabled;
                self.disable();
                o.disabled = dis;
            }
            //end for disabled option
            //update for visibility change
            if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    self._refreshSlider();
                    if(self.element.wijRemoveVisibilityObserver) {
                        self.element.wijRemoveVisibilityObserver();
                    }
                }, "wijslider");
            }
            self._bindEvents();
        };
        wijslider.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                self.disabledDiv.appendTo("body");
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
            }
        };
        wijslider.prototype._createDisabledDiv = function (outerEle) {
            var self = this, ele = //Change your outerelement here
            outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
            return $("<div></div>").addClass("ui-disabled").css({
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top
            });
        };
        wijslider.prototype.refresh = function () {
            /// <summary>
            /// Refresh the wijslider widget.
            /// </summary>
            // note: when the original element's width is setted by percent
            // it's hard to adjust the position and size, so first destroy then
            // recreate
            //this._refresh();
                        var widgetObject = this.element.data("wijslider"), wijmoWidgetObject = this.element.data("wijmoWijslider");
            this.destroy();
            this.element.data("wijslider", widgetObject);
            this.element.data("wijmoWijslider", wijmoWidgetObject);
            this._create();
        };
        wijslider.prototype._refreshSlider = function () {
            var self = this, increBtn, decreBtn, thumb;
            //			self.destroy();
            //			self._create();
            decreBtn = self._container.find(".wijmo-wijslider-decbutton");
            increBtn = self._container.find(".wijmo-wijslider-incbutton");
            thumb = self._container.find(".ui-slider-handle");
            self._adjustSliderLayout(decreBtn, increBtn, thumb);
            self._refreshValue();
        };
        wijslider.prototype._adjustSliderLayout = function (decreBtn, increBtn, thumb) {
            var self = this, element = self.element, o = self.options, ctrlWidth, ctrlHeight, decreBtnWidth, decreBtnHeight, increBtnWidth, increBtnHeight, thumbWidth, thumbHeight, dbtop, ibtop, dbleft, ibleft;
            ctrlWidth = self._container.width();
            ctrlHeight = self._container.height();
            decreBtnWidth = decreBtn.outerWidth();
            decreBtnHeight = decreBtn.outerHeight();
            increBtnWidth = increBtn.outerWidth();
            increBtnHeight = increBtn.outerHeight();
            thumbWidth = thumb.outerWidth();
            thumbHeight = thumb.outerHeight();
            if(o.orientation === "horizontal") {
                dbtop = ctrlHeight / 2 - decreBtnHeight / 2;
                decreBtn.css("top", dbtop).css("left", 0);
                ibtop = ctrlHeight / 2 - increBtnHeight / 2;
                increBtn.css("top", ibtop).css("right", 0);
                element.css("left", decreBtnWidth + thumbWidth / 2 - 1).css("top", ctrlHeight / 2 - element.outerHeight() / 2).width(ctrlWidth - decreBtnWidth - increBtnWidth - thumbWidth - 2);
            } else {
                dbleft = ctrlWidth / 2 - decreBtnWidth / 2;
                decreBtn.css("left", dbleft).css("top", 0);
                ibleft = ctrlWidth / 2 - increBtnWidth / 2;
                increBtn.css("left", ibleft).css("bottom", 0);
                element.css("left", ctrlWidth / 2 - element.outerWidth() / 2).css("top", decreBtnHeight + thumbHeight / 2 + 1).height(ctrlHeight - decreBtnHeight - increBtnHeight - thumbHeight - 2);
            }
        };
        wijslider.prototype.destroy = function () {
            ///	<summary>
            ///	Remove the slider functionality completely.
            /// This will return the element back to its pre-init state.
            ///	</summary>
                        var self = this, decreBtn, increBtn;
            decreBtn = this._getDecreBtn();
            increBtn = this._getIncreBtn();
            decreBtn.unbind('.' + self.widgetName);
            increBtn.unbind('.' + self.widgetName);
            _super.prototype.destroy.call(this);
            //update for destroy by wh at 2011/11/11
            //this.element.parent().removeAttr("class");
            //this.element.parent().html("");
            $("a", self.element.parent()).remove();
            self.element.unbind('.' + self.widgetName);
            self.element.unwrap();
            if(self._oriStyle === undefined) {
                self.element.removeAttr("style");
            } else {
                self.element.attr("style", self._oriStyle);
            }
            self.element.removeData(self.widgetName).removeData("originalStyle").removeData("originalContent");
            //end
            //Add for support disabled option at 2011/7/8
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            //end for disabled option
                    };
        wijslider.prototype._slide = function (event, index, newVal) {
            var self = this, o = self.options, minRange = o.minRange, newValue = newVal, values;
            if(o.range === true) {
                values = self.values();
                if(index === 0 && values[1] - minRange < newVal) {
                    newValue = values[1] - minRange;
                } else if(index === 1 && values[0] + minRange > newVal) {
                    newValue = values[0] + minRange;
                }
            }
            _super.prototype._slide.call(this, event, index, newValue);
        };
        wijslider.prototype._getDecreBtn = function () {
            var decreBtn = this.element.parent().find(".wijmo-wijslider-decbutton");
            return decreBtn;
        };
        wijslider.prototype._getIncreBtn = function () {
            var increBtn = this.element.parent().find(".wijmo-wijslider-incbutton");
            return increBtn;
        };
        wijslider.prototype._attachClass = function () {
            this._getDecreBtn().addClass("ui-corner-all ui-state-default").attr("role", "button");
            this._getIncreBtn().addClass("ui-corner-all ui-state-default").attr("role", "button");
            this.element.parent().attr("role", "slider").attr("aria-valuemin", this.options.min).attr("aria-valuenow", "0").attr("aria-valuemax", this.options.max);
            if(this.options.orientation === "horizontal") {
                this.element.parent().addClass("wijmo-wijslider-horizontal");
                this._getDecreBtn().find("> span").addClass("ui-icon ui-icon-triangle-1-w");
                this._getIncreBtn().find("> span").addClass("ui-icon ui-icon-triangle-1-e");
            } else {
                this.element.parent().addClass("wijmo-wijslider-vertical");
                this._getDecreBtn().find("> span").addClass("ui-icon ui-icon-triangle-1-n");
                this._getIncreBtn().find("> span").addClass("ui-icon ui-icon-triangle-1-s");
            }
        };
        wijslider.prototype._bindEvents = function () {
            var self = this, decreBtn, increBtn, ele;
            decreBtn = this._getDecreBtn();
            increBtn = this._getIncreBtn();
            ele = self.element;
            //
            decreBtn.bind('click.' + self.widgetName, self, self._decreBtnClick);
            increBtn.bind('click.' + self.widgetName, self, self._increBtnClick);
            //
            decreBtn.bind('mouseover.' + self.widgetName, self, self._decreBtnMouseOver);
            decreBtn.bind('mouseout.' + self.widgetName, self, self._decreBtnMouseOut);
            decreBtn.bind('mousedown.' + self.widgetName, self, self._decreBtnMouseDown);
            decreBtn.bind('mouseup.' + self.widgetName, self, self._decreBtnMouseUp);
            increBtn.bind('mouseover.' + self.widgetName, self, self._increBtnMouseOver);
            increBtn.bind('mouseout.' + self.widgetName, self, self._increBtnMouseOut);
            increBtn.bind('mousedown.' + self.widgetName, self, self._increBtnMouseDown);
            increBtn.bind('mouseup.' + self.widgetName, self, self._increBtnMouseUp);
            ele.bind('mouseup.' + self.widgetName, self, self._elementMouseupEvent);
        };
        wijslider.prototype._decreBtnMouseOver = function (e) {
            var self = e.data, data, decreBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "decreButton"
            };
            self._trigger('buttonMouseOver', e, data);
            //
            decreBtn = self._getDecreBtn();
            decreBtn.addClass("ui-state-hover");
        };
        wijslider.prototype._increBtnMouseOver = function (e) {
            var self = e.data, data, increBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "increButton"
            };
            self._trigger('buttonMouseOver', e, data);
            //
            increBtn = self._getIncreBtn();
            increBtn.addClass("ui-state-hover");
        };
        wijslider.prototype._decreBtnMouseOut = function (e) {
            var self = e.data, data, decreBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "decreButton"
            };
            self._trigger('buttonMouseOut', e, data);
            //
            decreBtn = self._getDecreBtn();
            decreBtn.removeClass("ui-state-hover ui-state-active");
        };
        wijslider.prototype._increBtnMouseOut = function (e) {
            var self = e.data, data, increBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "increButton"
            };
            self._trigger('buttonMouseOut', e, data);
            //
            increBtn = self._getIncreBtn();
            increBtn.removeClass("ui-state-hover ui-state-active");
        };
        wijslider.prototype._decreBtnMouseDown = function (e) {
            var self = e.data, data, decreBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "decreButton"
            };
            self._trigger('buttonMouseDown', e, data);
            //
            decreBtn = self._getDecreBtn();
            decreBtn.addClass("ui-state-active");
            //if the mouse release util the mouse out, the track still take effect.
            //added by wuhao 2011/7/16
            $(document).bind("mouseup." + self.widgetName, {
                self: self,
                ele: decreBtn
            }, self._documentMouseUp);
            if(self._intervalID !== null) {
                window.clearInterval(self._intervalID);
                self._intervalID = null;
            }
            //end for mouse release
            self._intervalID = window.setInterval(function () {
                self._decreBtnHandle(self);
            }, 200);
        };
        wijslider.prototype._documentMouseUp = function (e) {
            var self = e.data.self, ele = e.data.ele;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            ele.removeClass("ui-state-active");
            if(self._intervalID !== null) {
                window.clearInterval(self._intervalID);
                self._intervalID = null;
            }
            $(document).unbind("mouseup." + self.widgetName, self._documentMouseUp);
        };
        wijslider.prototype._increBtnMouseDown = function (e) {
            var self = e.data, data, increBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "increButton"
            };
            self._trigger('buttonMouseDown', e, data);
            //
            increBtn = self._getIncreBtn();
            increBtn.addClass("ui-state-active");
            //if the mouse release util the mouse out, the track still take effect.
            //added by wuhao 2011/7/16
            $(document).bind("mouseup." + self.widgetName, {
                self: self,
                ele: increBtn
            }, self._documentMouseUp);
            if(self._intervalID !== null) {
                window.clearInterval(self._intervalID);
                self._intervalID = null;
            }
            //end for mouse release
            self._intervalID = window.setInterval(function () {
                self._increBtnHandle(self);
            }, 200);
        };
        wijslider.prototype._decreBtnMouseUp = function (e) {
            var self = e.data, data, decreBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "decreButton"
            };
            self._trigger('buttonMouseUp', e, data);
            //
            decreBtn = self._getDecreBtn();
            decreBtn.removeClass("ui-state-active");
            window.clearInterval(self._intervalID);
        };
        wijslider.prototype._increBtnMouseUp = function (e) {
            var self = e.data, data, increBtn;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            data = {
                buttonType: "increButton"
            };
            self._trigger('buttonMouseUp', e, data);
            //
            increBtn = self._getIncreBtn();
            increBtn.removeClass("ui-state-active");
            window.clearInterval(self._intervalID);
        };
        wijslider.prototype._decreBtnHandle = function (sender) {
            if(sender.options.orientation === "horizontal") {
                sender._decre();
            } else {
                sender._incre();
            }
        };
        wijslider.prototype._decreBtnClick = function (e) {
            var self = e.data, data;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            //note: step1: slide the slider btn, the change event has fired;
            //step2: then click the decre button, the change event don't fired.
            self._mouseSliding = false;
            //end
            self._decreBtnHandle(self);
            data = {
                buttonType: "decreButton",
                value: self.value()
            };
            self._trigger('buttonClick', e, data);
        };
        wijslider.prototype._increBtnHandle = function (sender) {
            if(sender.options.orientation === "horizontal") {
                sender._incre();
            } else {
                sender._decre();
            }
        };
        wijslider.prototype._increBtnClick = function (e) {
            var self = e.data, data;
            if(self.options.disabledState || self.options.disabled) {
                return;
            }
            //note: step1: slide the slider btn, the change event has fired;
            //step2: then click the decre button, the change event don't fired.
            self._mouseSliding = false;
            //end
            self._increBtnHandle(self);
            data = {
                buttonType: "increButton",
                value: self.value()
            };
            self._trigger('buttonClick', e, data);
        };
        wijslider.prototype._decre = function () {
            var self = this, curVal = self.value(), o = self.options, min = o.min, step = o.step;
            //
            if(o.values && o.values.length) {
                curVal = self.values(0);
                if(curVal <= min) {
                    self.values(0, min);
                } else {
                    self.values(0, curVal - step);
                }
            } else {
                curVal = self.value();
                if(curVal <= min) {
                    self.value(min);
                } else {
                    self.value(curVal - step);
                }
            }
            //
            self.element.parent().attr("aria-valuenow", self.value());
        };
        wijslider.prototype._incre = function () {
            var self = this, curVal = self.value(), o = self.options, max = o.max, step = o.step, index;
            //
            if(o.values && o.values.length) {
                index = o.values.length === 1 ? 0 : 1;
                curVal = self.values(index);
                if(curVal >= max) {
                    self.values(index, max);
                } else {
                    self.values(index, curVal + step);
                }
            } else {
                curVal = self.value();
                if(curVal >= max) {
                    self.value(max);
                } else {
                    self.value(curVal + step);
                }
            }
            //
            self.element.parent().attr("aria-valuenow", self.value());
        };
        wijslider.prototype._elementMouseupEvent = function (e) {
            var self = e.data;
            if(self.options.dragFill && self.options.range) {
                if(self._dragFillStart > 0) {
                    self._dragFillStart = 0;
                } else {
                    $.ui.slider.prototype._mouseCapture.apply(self, arguments);
                }
            }
        };
        wijslider.prototype._mouseCapture = function (event) {
            this.element.parent().attr("aria-valuenow", this.value());
            //
            if(this.options.dragFill) {
                if(event.target.className === "ui-slider-range ui-widget-header") {
                    this.elementSize = {
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight()
                    };
                    this.elementOffset = this.element.offset();
                    return true;
                } else {
                    try  {
                        return $.ui.slider.prototype._mouseCapture.apply(this, arguments);
                    } catch (e) {
                    }
                }
            } else {
                try  {
                    return $.ui.slider.prototype._mouseCapture.apply(this, arguments);
                } catch (e) {
                }
            }
        };
        wijslider.prototype._mouseStart = function (event) {
            if(this.options.dragFill) {
                if(event.target) {
                    if(event.target.className === "ui-slider-range ui-widget-header") {
                        this._dragFillTarget = true;
                        this._rangeValue = this.values(1) - this.values(0);
                        this._oldValue1 = this.values(0);
                        this._oldValue2 = this.values(1);
                        this._oldX = event.pageX;
                        this._oldY = event.pageY;
                        return true;
                    }
                }
                this._dragFillTarget = false;
            }
            return true;
        };
        wijslider.prototype._mouseDrag = function (event) {
            var distance, eleLength, movValue, v, v0, v1;
            if(this.options.dragFill) {
                distance = event.pageX - this._oldX;
                //var position = { x: event.pageX, y: event.pageY };
                //var movValue = this._normValueFromMouse(position);
                eleLength = this.element.outerWidth();
                if(this.options.orientation === "vertical") {
                    eleLength = this.element.outerHeight();
                    distance = -(event.pageY - this._oldY);
                }
                movValue = (this.options.max - this.options.min) / eleLength * distance;
                //document.title = distanceX + "|" + movValue;
                if(this._dragFillTarget) {
                    if(this.options.orientation === "vertical") {
                        $(document.documentElement).css("cursor", "s-resize");
                    } else {
                        $(document.documentElement).css("cursor", "w-resize");
                    }
                    if(this._dragFillStart > 0) {
                        v = this._rangeValue;
                        /* if (normValue + v >= this.options.max) {
                        this.values(0, this.options.max - v);
                        this.values(1, this.options.max);
                        }
                        else {
                        }*/
                        this.values(0, this._oldValue1 + movValue);
                        this.values(1, this._oldValue1 + movValue + v);
                        v0 = this.values(0);
                        v1 = this.values(1);
                        if(v0 + v > this.options.max) {
                            this.values(0, this.options.max - v);
                        }
                        if(v1 - v < this.options.min) {
                            this.values(1, this.options.min + v);
                        }
                    }
                    this._dragFillStart++;
                    return false;
                } else {
                    return $.ui.slider.prototype._mouseDrag.apply(this, arguments);
                }
            } else {
                return $.ui.slider.prototype._mouseDrag.apply(this, arguments);
            }
        };
        wijslider.prototype._mouseStop = function (event) {
            var returnVal = $.ui.slider.prototype._mouseStop.apply(this, arguments);
            if(this.options.dragFill) {
                $(document.documentElement).css("cursor", "default");
                window.setTimeout(function () {
                    this._dragFillTarget = false;
                    this._dragFillStart = 0;
                }, 500);
            }
            return returnVal;
        };
        return wijslider;
    })(JQueryUISlider);
    wijmo.wijslider = wijslider;    
    wijslider.prototype.widgetEventPrefix = "wijslider";
    wijslider.prototype.options = $.extend(true, {
    }, $.Widget.prototype.options, {
        buttonMouseOver: /// <summary>
        /// Raised when the mouse is over the decrement button or increment button.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the buttonMouseOver event:
        /// $("#element").wijslider({ buttonMouseOver: function (e, args) {
        /// alert(args.buttonType); } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsliderbuttonMouseOver", function(e, args) {
        /// alert(args.buttonType); });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// An object that contains all the button infos.
        /// data.buttonType: A string value that indicates the type name of button.
        /// </param>
        null,
        buttonMouseOut: /// <summary>
        /// Raised when the mouse leaves the decrement button or increment button.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the buttonMouseOut event:
        /// $("#element").wijslider({ buttonMouseOut: function (e, args) {
        /// alert(args.buttonType); } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsliderbuttonMouseOut", function(e, args) {
        /// alert(args.buttonType); });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// An object that contains all the button infos.
        /// data.buttonType: A string value that indicates the type name of button.
        /// </param>
        null,
        buttonMouseDown: /// <summary>
        /// Raised when the mouse is down on the decrement button or decrement button.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the buttonMouseDown event:
        /// $("#element").wijslider({ buttonMouseDown: function (e, args) {
        /// alert(args.buttonType); } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsliderbuttonMouseDown", function(e, args) {
        /// alert(args.buttonType); });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// An object that contains all the button infos.
        /// data.buttonType: A string value that indicates the type name of button.
        /// </param>
        null,
        buttonMouseUp: /// <summary>
        /// Raised when the mouse is up on the decrement button or increment button.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the buttonMouseUp event:
        /// $("#element").wijslider({ buttonMouseUp: function (e, args) {
        /// alert(args.buttonType); } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsliderbuttonMouseUp", function(e, args) {
        /// alert(args.buttonType); });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// An object that contains all the button infos.
        /// data.buttonType: A string value that indicates the type name of button.
        /// </param>
        null,
        buttonClick: /// <summary>
        /// Raised when the decrement or increment button is clicked.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the buttonClick event:
        /// $("#element").wijslider({ buttonClick: function (e, args) {
        /// alert(args.buttonType); } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsliderbuttonClick", function(e, args) {
        /// alert(args.buttonType); });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// An object that contains all the button infos.
        /// data.buttonType: A string value that indicates the type name of button.
        /// </param>
        null,
        dragFill: /// <summary>
        /// Determines whether the user is able to
        /// drag the fill between the buttons.
        /// Default: true.
        /// Type: Boolean.
        /// Code example:
        ///  $("#selector").wijslider({
        ///      dragFill: false
        ///  });
        /// </summary>
        true,
        minRange: /// <summary>
        /// A value prevent the two range handles from being placed on top of
        /// one another.
        /// Default: 0.
        /// Type: Number.
        /// Code example:
        ///  $("#selector").wijslider({
        ///      minRange: 25
        ///  });
        /// </summary>
        0
    });
    if($.ui && $.ui.slider) {
        $.wijmo.registerWidget(widgetName, $.ui.slider, wijslider.prototype);
    }
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*globals window,document,jQuery*/
/*
* Depends:
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jquery.ui.resizable.js
*	jquery.ui.mouse.js
*	jquery.wijmo.wijutil.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijsplitter";
    var WijSplitter = (function (_super) {
        __extends(WijSplitter, _super);
        function WijSplitter() {
            _super.apply(this, arguments);

        }
        WijSplitter.prototype._setFullSplit = function (value) {
            var self = this, fields = self._fields, width = value ? "100%" : fields.width, height = value ? "100%" : fields.height;
            self.element.css("width", width).css("height", height);
        };
        WijSplitter.prototype._setOption = function (key, value) {
            var self = this, o = self.options, expander, oldValue = $.extend({
            }, o[key]);
            if(key === "fullSplit") {
                self._setFullSplit(value);
            } else if($.isPlainObject(o[key])) {
                if(key === "panel1" && value.collapsed !== undefined) {
                    //if(value.collapsed) { o.panel2.collapsed = false; }
                    self._setPanel1Collapsed(value.collapsed);
                } else if(key === "panel2" && value.collapsed !== undefined) {
                    //if(value.collapsed) { o.panel1.collapsed = false; }
                    self._setPanel2Collapsed(value.collapsed);
                }
                o[key] = $.extend(true, o[key], value);
                return;
            }
            $.Widget.prototype._setOption.apply(self, arguments);
            if(oldValue !== value) {
                if(key === "orientation") {
                    self.refresh();
                } else if(key === "collapsingPanel") {
                    self.refresh();
                } else if(key === "fullSplit") {
                    self.refresh(true, false);
                } else if(key === "splitterDistance") {
                    self.refresh(false, false);
                    self._trigger("sized");
                } else if(key === "showExpander") {
                    expander = self._fields.expander;
                    if(expander && expander.length) {
                        expander.css("display", value ? "" : "none");
                    }
                }
            }
            //Add for support disabled option at 2011/7/8
            if(key === "disabled") {
                self._handleDisabledOption(value, self.element);
            }
            //end for disabled option
                    };
        WijSplitter.prototype._create = function () {
            var self = this, element = self.element, o = self.options, minSize;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(o.splitterDistance == 100) {
                minSize = this.element.width() - o.panel2.minSize;
                if(o.panel1.minSize > o.splitterDistance) {
                    o.splitterDistance = o.panel1.minSize;
                } else if(minSize < o.splitterDistance) {
                    o.splitterDistance = minSize;
                }
            }
            self._fields = {
                width: element.width(),
                height: element.height()
            };
            if(o.fullSplit) {
                self._setFullSplit(true);
            }
            self._splitterify();
            self._updateElementsCss();
            self._updateElements();
            self._bindEvents();
            self._initResizer();
            //Add for support disabled option at 2011/7/8
            if(o.disabled) {
                self.disable();
            }
            //end for disabled option
            //fixed bug 28059
            if(self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    if(o.fullSplit) {
                        self.refresh();
                        self._updateElements();
                        self._initResizer();
                    }
                }, "wijsplitter");
            }
            self._trigger("load", null, self);
        };
        WijSplitter.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                self.disabledDiv.appendTo("body");
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
            }
        };
        WijSplitter.prototype.destroy = function () {
            var self = this, o = self.options, element = self.element, fields = self._fields, wrapper = fields.wrapper, expander = fields.expander, bar = fields.bar, panel1 = fields.panel1, panel2 = fields.panel2, originalStyle = fields.originalStyle, widgetName = self.widgetName, oriPnl1Content = fields.oriPnl1Content, oriPnl2Content = fields.oriPnl2Content, oriPnl1ContentStyle = fields.oriPnl1ContentStyle, oriPnl2ContentStyle = fields.oriPnl2ContentStyle, css = o.wijCSS, vSplitterCSS = css.vSplitterCss, vSplitterPre = css.vSplitterCssPrefix, hSplitterCSS = css.hSplitterCss, hSplitterPre = css.hSplitterCssPrefix, panelCss = css.panelCss;
            if($.fn.resizable) {
                if(panel1 && panel1.n.is(":ui-resizable")) {
                    panel1.n.resizable('destroy');
                }
            }
            if(oriPnl1Content) {
                oriPnl1Content.removeClass(vSplitterPre + panel1.contentCss + " " + o.wijCSS.hSplitterCssPrefix + panel1.contentCss + " " + o.wijCSS.content);
                if(oriPnl1ContentStyle === undefined) {
                    oriPnl1Content.removeAttr("style");
                } else {
                    oriPnl1Content.attr("style", oriPnl1ContentStyle);
                }
                oriPnl1Content.appendTo(element);
            }
            if(oriPnl2Content) {
                oriPnl2Content.removeClass(vSplitterPre + panel2.contentCss + " " + o.wijCSS.hSplitterCssPrefix + panel2.contentCss + " " + o.wijCSS.content);
                if(oriPnl2ContentStyle === undefined) {
                    oriPnl2Content.removeAttr("style");
                } else {
                    oriPnl2Content.attr("style", oriPnl2ContentStyle);
                }
                oriPnl2Content.appendTo(element);
            }
            panel1.n.unbind('.' + widgetName);
            expander.unbind('.' + widgetName);
            bar.unbind('.' + widgetName);
            $(window).unbind('.' + widgetName);
            wrapper.remove();
            element.removeClass(vSplitterCSS + " " + hSplitterCSS);
            if(originalStyle === undefined) {
                element.removeAttr("style");
            } else {
                element.attr("style", originalStyle);
            }
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            self._fields = null;
        };
        WijSplitter.prototype.refresh = function (size, state) {
            /// <summary>
            /// Forces the widget to recreate the splitter.
            /// </summary>
            /// <param name="size" type="Boolean">
            /// A boolean value to indicate whether the refresh is triggered
            /// because the size of widget is changed.
            /// </param>
            /// <param name="state" type="Boolean">
            /// A boolean value to indicate whether the refresh is triggered
            /// because the state of expander is changed(expanded/collapsed).
            /// </param>
                        var self = this, fields = self._fields, panel1 = fields.panel1;
            if(fields._isResizing) {
                return;
            }
            if(state || state === undefined) {
                self._updateElementsCss();
            }
            self._updateElements();
            if(size || size === undefined) {
                if(!$.fn.resizable) {
                    return;
                }
                if(panel1 && panel1.n.is(":ui-resizable")) {
                    panel1.n.resizable('destroy');
                }
                self._initResizer();
            }
        };
        WijSplitter.prototype._createDisabledDiv = function (outerEle) {
            var self = this, ele = //Change your outerelement here
            outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight(), css = {
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top
            };
            if($.browser.msie) {
                $.extend(css, {
                    "background-color": "#fff",
                    opacity: 0.1
                });
            }
            return $("<div></div>").addClass("ui-disabled").css(css);
        };
        WijSplitter.prototype._splitterify = function () {
            var self = this, element = self.element, o = self.options, fields = self._fields, wrapper, bar, expander, icon, pnl1 = {
                n: undefined,
                content: element.find(">div:eq(0)")
            }, pnl2 = {
                n: undefined,
                content: element.find(">div:eq(1)")
            };
            fields.originalStyle = element.attr("style");
            //create wrapper
            wrapper = $("<div></div>").appendTo(element);
            //create panel1
            pnl1.n = $("<div></div>").appendTo(wrapper);
            //create panel1 content if needed.
            if(pnl1.content.length === 0) {
                pnl1.content = $("<div></div>");
            } else {
                fields.oriPnl1Content = pnl1.content;
                fields.oriPnl1ContentStyle = pnl1.content.attr("style");
            }
            pnl1.content.appendTo(pnl1.n);
            //create bar.
            bar = $("<div></div>").appendTo(wrapper);
            if(o.barZIndex !== -1) {
                bar.css("z-index", o.barZIndex);
            }
            //create expander.
            expander = $("<div></div>").appendTo(bar).attr("role", "button");
            //create icon.
            icon = $("<span></span>").appendTo(expander);
            //create panel2
            pnl2.n = $("<div></div>").appendTo(wrapper);
            //create panel2 content if needed.
            if(pnl2.content.length === 0) {
                pnl2.content = $("<div></div>");
            } else {
                fields.oriPnl2Content = pnl2.content;
                fields.oriPnl2ContentStyle = pnl2.content.attr("style");
            }
            pnl2.content.appendTo(pnl2.n);
            fields.wrapper = wrapper;
            fields.panel1 = pnl1;
            fields.panel2 = pnl2;
            fields.bar = bar;
            fields.expander = expander;
            fields.icon = icon;
        };
        WijSplitter.prototype._updateElementsCss = function () {
            var self = this, element = self.element, o = self.options, isVertical = o.orientation === "vertical", fields = self._fields, wrapper = fields.wrapper, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', bar = fields.bar, expander = fields.expander, icon = fields.icon, css = o.wijCSS, vSplitterCSS = css.vSplitterCss, vSplitterPre = css.vSplitterCssPrefix, hSplitterCSS = css.hSplitterCss, hSplitterPre = css.hSplitterCssPrefix, panelCss = css.panelCss;
            //add class to the outmost markup.
            //add comments by RyanWu@20110817.
            //For fixing the issue#16391.
            //			element.removeClass(vSplitterCss + " " + hSplitterCss +
            //				" " + vSplitterCssPrefix + css.expandedCss +
            //				" " + vSplitterCssPrefix + collapsedCss +
            //				" " + hSplitterCssPrefix + css.expandedCss +
            //				" " + hSplitterCssPrefix + css.collapsedCss)
            //				.addClass(isVertical ? vSplitterCss : hSplitterCss);
            element.removeClass(vSplitterCSS + " " + hSplitterCSS).addClass(isVertical ? vSplitterCSS : hSplitterCSS);
            //end by RyanWu@20110817.
            //add class to wrapper
            wrapper.attr("class", css.wrapperCss);
            //add class to panel1
            fields[collapsingPanel].n.removeClass(vSplitterPre + panelCss[collapsingPanel].n + " " + hSplitterPre + panelCss[collapsingPanel].n).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[collapsingPanel].n);
            //add class to panel1 content.
            fields[collapsingPanel].content.removeClass(vSplitterPre + panelCss[collapsingPanel].content + " " + hSplitterPre + panelCss[collapsingPanel].content + " " + css.content).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[collapsingPanel].content + " " + css.content);
            //add class to bar.
            bar.attr("class", (isVertical ? vSplitterPre : hSplitterPre) + css.barCss + " " + css.header).css("width", "").css("height", "");
            //add class to expander.
            expander.attr("class", css.cornerCssPrefix + (isVertical ? "bl " + vSplitterPre : "tr " + hSplitterPre) + css.expanderCss + " " + css.stateDefault).css("left", "").css("top", "");
            //add class to icon.
            icon.attr("class", css.icon + " " + (isVertical ? css.iconArrowLeft : css.iconArrowUp));
            //add class to panel2
            fields[otherPanel].n.removeClass(vSplitterPre + panelCss[otherPanel].n + " " + hSplitterPre + panelCss[otherPanel].n).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[otherPanel].n);
            //add class to panel2 content.
            fields[otherPanel].content.removeClass(vSplitterPre + panelCss[otherPanel].content + " " + hSplitterPre + panelCss[otherPanel].content + " " + css.content).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[otherPanel].content + " " + css.content);
            // if panel1.collapsed = true, then we need update
            // the expander icon's css.
            self._updateExpanderCss();
        };
        WijSplitter.prototype._updateExpanderCss = function () {
            var self = this, o = self.options, fields = self._fields, expander = fields.expander, icon = fields.icon, css = o.wijCSS, cornerPre = css.cornerCssPrefix, isVertical = o.orientation === "vertical", panel2IsCollapsing = o.collapsingPanel !== "panel1", cssPrefix = isVertical ? css.vSplitterCssPrefix : css.hSplitterCssPrefix, ovalue = (isVertical ? 1 : 0) * 2 + (panel2IsCollapsing ? 1 : 0), collapsedExpCorner1Css = [
                "bl", 
                "tr", 
                "tr", 
                "bl"
            ][ovalue], collapsedExpCorner2Css = [
                "br", 
                "tl"
            ][+panel2IsCollapsing], collapsedIconCss = [
                css.iconArrowDown, 
                css.iconArrowUp, 
                css.iconArrowRight, 
                css.iconArrowLeft
            ][ovalue], expandedExpCorner1Css = [
                "tr", 
                "bl", 
                "bl", 
                "tr"
            ][ovalue], expandedExpCorner2Css = [
                "tl", 
                "br"
            ][+panel2IsCollapsing], expandedIconCss = [
                css.iconArrowUp, 
                css.iconArrowDown, 
                css.iconArrowLeft, 
                css.iconArrowRight
            ][ovalue];
            expander.removeClass(cssPrefix + o.collapsingPanel + "-" + css.expandedCss + " " + cssPrefix + o.collapsingPanel + "-" + css.collapsedCss + " " + cornerPre + collapsedExpCorner1Css + " " + cornerPre + collapsedExpCorner2Css + " " + cornerPre + expandedExpCorner1Css + " " + cornerPre + expandedExpCorner2Css);
            icon.removeClass(collapsedIconCss + " " + expandedIconCss);
            if(o.panel1.collapsed || o.panel2.collapsed) {
                //element.addClass(cssPrefix + css.collapsedCss);
                expander.addClass(cornerPre + collapsedExpCorner1Css + " " + cornerPre + collapsedExpCorner2Css + " " + cssPrefix + o.collapsingPanel + "-" + css.collapsedCss);
                icon.addClass(collapsedIconCss);
            } else {
                //element.addClass(cssPrefix + css.expandedCss);
                expander.addClass(cornerPre + expandedExpCorner1Css + " " + cornerPre + expandedExpCorner2Css + " " + cssPrefix + o.collapsingPanel + "-" + css.expandedCss);
                icon.addClass(expandedIconCss);
            }
        };
        WijSplitter.prototype._updateElements = function () {
            var self = this, element = self.element, o = self.options, distance = o.splitterDistance, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', fields = self._fields, wrapper = fields.wrapper, pnl1 = fields.panel1, pnl2 = fields.panel2, bar = fields.bar, expander = fields.expander, width = element.width(), height = element.height(), barW, barH;
            wrapper.height(height);
            self._setPanelsScrollMode();
            if(o.orientation === "vertical") {
                barW = bar.outerWidth(true);
                if(distance > width - barW) {
                    distance = width - barW;
                }
                //fixed bug 29981
                //To prevent panel2 be a new line by the css "float:left"
                wrapper.width(width * 2);
                if(o.panel1.collapsed) {
                    if(collapsingPanel === "panel1") {
                        expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel1" + "-" + o.wijCSS.collapsedCss);
                    }
                    fields.panel1.n.css("display", "none");
                    fields.panel2.n.css("display", "");
                    distance = 0;
                } else {
                    if(collapsingPanel === "panel1") {
                        expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel1" + "-" + o.wijCSS.expandedCss);
                    }
                    fields.panel1.n.css("display", "");
                    fields.panel2.n.css("display", o.panel2.collapsed ? "none" : "");
                }
                if(o.panel2.collapsed) {
                    if(collapsingPanel === "panel2") {
                        expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel2" + "-" + o.wijCSS.collapsedCss);
                    }
                    fields.panel2.n.css("display", "none");
                    distance = (collapsingPanel === "panel1") ? width - barW : width;
                } else {
                    if(collapsingPanel === "panel2") {
                        expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel2" + "-" + o.wijCSS.expandedCss);
                    }
                    fields.panel2.n.css("display", "");
                }
                if(!o.panel1.collapsed && !o.panel2.collapsed) {
                    expander.addClass(o.wijCSS.vSplitterCssPrefix + o.collapsingPanel + "-" + o.wijCSS.expandedCss);
                }
                if(collapsingPanel === "panel1") {
                    fields.panel1.n.height(height).width(distance);
                    fields.panel2.n.height(height).width(width - distance - barW);
                } else {
                    fields.panel1.n.height(height).width(distance - barW);
                    fields.panel2.n.height(height).width(width - distance);
                    //fields.panel2.content.width(width - distance);
                                    }
                fields.panel1.content.outerHeight(height, true);
                bar.outerHeight(height, true);
                fields.panel2.content.outerHeight(height, true);
                expander.css("cursor", "pointer").css("top", height / 2 - expander.outerHeight(true) / 2);
            } else {
                barH = bar.outerHeight(true);
                if(distance > height - barH) {
                    distance = height - barH;
                }
                if(o.panel1.collapsed) {
                    if(collapsingPanel === "panel1") {
                        expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel1" + "-" + o.wijCSS.collapsedCss);
                    }
                    fields.panel1.n.css("display", "none");
                    fields.panel2.n.css("display", "");
                    distance = 0;
                } else {
                    if(collapsingPanel === "panel1") {
                        expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel1" + "-" + o.wijCSS.expandedCss);
                    }
                    fields.panel1.n.css("display", "");
                    fields.panel2.n.css("display", o.panel2.collapsed ? "none" : "");
                }
                if(o.panel2.collapsed) {
                    if(collapsingPanel === "panel2") {
                        expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel2" + "-" + o.wijCSS.collapsedCss);
                    }
                    fields.panel2.n.css("display", "none");
                    distance = (collapsingPanel === "panel1") ? height - barH : height;
                } else {
                    if(collapsingPanel === "panel2") {
                        expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel2" + "-" + o.wijCSS.expandedCss);
                    }
                    fields.panel2.n.css("display", "");
                }
                if(collapsingPanel === "panel1") {
                    fields.panel1.n.width(width).height(distance);
                    fields.panel2.n.width(width).height(height - distance - barH);
                    fields.panel1.content.outerHeight(distance, true);
                    fields.panel2.content.outerHeight(height - distance - barH, true);
                } else {
                    fields.panel1.n.width(width).height(distance - barH);
                    fields.panel2.n.width(width).height(height - distance);
                    fields.panel1.content.outerHeight(distance - barH, true);
                    fields.panel2.content.outerHeight(height - distance, true);
                }
                expander.css("cursor", "pointer").css("left", width / 2 - expander.outerWidth(true) / 2);
            }
            expander.css("display", o.showExpander ? "" : "none");
        };
        WijSplitter.prototype._bindEvents = function () {
            var self = this, o = self.options, fields = self._fields, bar = fields.bar, expander = fields.expander, widgetName = self.widgetName;
            expander.bind("mouseover." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                expander.addClass(o.wijCSS.stateHover);
            }).bind("mouseout." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                expander.removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateActive);
            }).bind("mousedown." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                expander.addClass(o.wijCSS.stateActive);
            }).bind("mouseup." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                expander.removeClass(o.wijCSS.stateActive);
                if(o.collapsingPanel === 'panel1') {
                    self._setPanel1Collapsed(!o.panel1.collapsed, e);
                } else {
                    self._setPanel2Collapsed(!o.panel2.collapsed, e);
                }
            });
            bar.bind("mouseover." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                bar.addClass(o.wijCSS.stateHover);
            }).bind("mouseout." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                bar.removeClass(o.wijCSS.stateHover);
            });
            fields.panel1.n.bind("animating." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                self._adjustLayout(self);
                self._trigger("sizing", e, null);
            }).bind("animated." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                self._adjustLayout(self);
                self._trigger("sized", e, null);
            });
            self.element.on("mouseover." + widgetName, ".ui-resizable-handle", function (e) {
                if(o.disabled) {
                    return;
                }
                bar.addClass(o.wijCSS.stateHover);
            }).on("mouseout." + widgetName, ".ui-resizable-handle", function (e) {
                if(o.disabled) {
                    return;
                }
                bar.removeClass(o.wijCSS.stateHover);
            });
            $(window).bind("resize." + widgetName, function (e) {
                if(o.disabled) {
                    return;
                }
                if(o.fullSplit && self.element.is(":visible")) {
                    //self.refresh();
                    self._updateElements();
                    self._initResizer();
                }
            });
        };
        WijSplitter.prototype._setPanel1Collapsed = function (collapsed, e) {
            var self = this, o = self.options, oldCollapsed = o.panel1.collapsed, resizableHandle = $(".ui-resizable-handle", self.element);
            if(oldCollapsed === collapsed) {
                return;
            }
            if(o.collapsingPanel === 'panel1') {
                if(!self._trigger(oldCollapsed ? "expand" : "collapse", e, null)) {
                    return;
                }
            }
            o.panel1.collapsed = collapsed;
            if(collapsed) {
                o.panel2.collapsed = false;
                if(o.collapsingPanel === 'panel2') {
                    resizableHandle.hide();
                }
            } else {
                resizableHandle.show();
            }
            self._updateElements();
            self._updateExpanderCss();
            if(o.collapsingPanel === 'panel1') {
                self._trigger(collapsed ? "collapsed" : "expanded", e, null);
            }
        };
        WijSplitter.prototype._setPanel2Collapsed = function (collapsed, e) {
            var self = this, o = self.options, oldCollapsed = o.panel2.collapsed, resizableHandle = $(".ui-resizable-handle", self.element);
            if(oldCollapsed === collapsed) {
                return;
            }
            if(o.collapsingPanel === 'panel2') {
                if(!self._trigger(oldCollapsed ? "expand" : "collapse", e, null)) {
                    return;
                }
            }
            o.panel2.collapsed = collapsed;
            if(collapsed) {
                o.panel1.collapsed = false;
                if(o.collapsingPanel === 'panel1') {
                    resizableHandle.hide();
                }
            } else {
                resizableHandle.show();
            }
            self._updateElements();
            self._updateExpanderCss();
            if(o.collapsingPanel === 'panel2') {
                self._trigger(collapsed ? "collapsed" : "expanded", e, null);
            }
        };
        WijSplitter.prototype._initResizer = function () {
            var self = this, element = self.element, o = self.options, fields = self._fields, bar = fields.bar, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', resizeSettings = o.resizeSettings, animation = resizeSettings.animationOptions, duration = animation.disabled ? 0 : animation.duration, width = element.width(), height = element.height(), barW, maxW, minW, barH, maxH, minH, resizableHandle;
            if(!$.fn.resizable) {
                return;
            }
            if(o.orientation === "vertical") {
                barW = bar.outerWidth(true);
                maxW = width - barW - o[otherPanel].minSize;
                minW = o[collapsingPanel].minSize;
                if(minW < 2) {
                    minW = 2;
                }
                fields.panel1.n.resizable({
                    wijanimate: true,
                    minWidth: minW,
                    maxWidth: maxW,
                    handles: 'e',
                    helper: o.wijCSS.vSplitterCssPrefix + o.wijCSS.resizeHelperCss,
                    animateDuration: duration,
                    animateEasing: animation.easing,
                    ghost: resizeSettings.ghost,
                    start: function () {
                        fields._isResizing = true;
                    },
                    stop: function () {
                        fields._isResizing = false;
                    }
                });
            } else {
                barH = bar.outerHeight(true);
                maxH = height - barH - o[otherPanel].minSize;
                minH = o[collapsingPanel].minSize;
                if(minH < 2) {
                    minH = 2;
                }
                fields.panel1.n.resizable({
                    wijanimate: true,
                    minHeight: minH,
                    maxHeight: maxH,
                    handles: 's',
                    helper: o.wijCSS.hSplitterCssPrefix + o.wijCSS.resizeHelperCss,
                    animateDuration: duration,
                    animateEasing: animation.easing,
                    ghost: resizeSettings.ghost,
                    start: function () {
                        fields._isResizing = true;
                    },
                    stop: function () {
                        fields._isResizing = false;
                    }
                });
            }
            resizableHandle = $(".ui-resizable-handle", element);
            if(o[otherPanel].collapsed) {
                resizableHandle.hide();
            } else {
                resizableHandle.show();
            }
            if($.browser.msie && (parseInt($.browser.version) < 7)) {
                if(o.orientation === "vertical") {
                    resizableHandle.height(element.height());
                }
            }
        };
        WijSplitter.prototype._adjustLayout = function (self) {
            var o = self.options, fields = self._fields, panel1 = fields.panel1, distance = o.orientation === "vertical" ? panel1.n.width() : panel1.n.height();
            if(o.splitterDistance === distance) {
                return;
            }
            o.splitterDistance = distance;
            self._updateElements();
        };
        WijSplitter.prototype._setPanelsScrollMode = function () {
            var self = this, fields = self._fields, o = self.options, pnlScrollBars = [
                o.panel1.scrollBars, 
                o.panel2.scrollBars
            ];
            $.each([
                fields.panel1, 
                fields.panel2
            ], function (idx, pnl) {
                if(pnlScrollBars[idx] === "auto") {
                    pnl.content.css("overflow", "auto");
                } else if(pnlScrollBars[idx] === "both") {
                    pnl.content.css("overflow", "scroll");
                } else if(pnlScrollBars[idx] === "none") {
                    pnl.content.css("overflow", "hidden");
                } else if(pnlScrollBars[idx] === "horizontal") {
                    pnl.content.css("overflow-x", "scroll").css("overflow-y", "hidden");
                } else if(pnlScrollBars[idx] === "vertical") {
                    pnl.content.css("overflow-x", "hidden").css("overflow-y", "scroll");
                }
            });
        };
        return WijSplitter;
    })(wijmo.wijmoWidget);
    wijmo.WijSplitter = WijSplitter;    
    WijSplitter.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijsplitter')",
        sizing: /// <summary>
        /// Gets or sets the javascript function name that
        /// would be called at client side when dragging the splitter.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the sizing event:
        /// $("#element").wijsplitter({ sizing: function () { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplittersizing", function () { });
        /// </summary>
        null,
        sized: /// <summary>
        /// Gets or sets the javascript function name that
        /// would be called at client side when finish dragging the splitter.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the sized event:
        /// $("#element").wijsplitter({ sized: function () { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplittersized", function () { });
        /// </summary>
        null,
        expand: /// <summary>
        /// Gets or sets the javascript function name that
        /// would be called before panel1 is expanded out.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the expand event:
        /// $("#element").wijsplitter({ expand: function () { return false; } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplitterexpand", function () { return false; });
        /// </summary>
        null,
        collapse: /// <summary>
        /// Gets or sets the javascript function name that
        /// would be called before panel1 is collapsed.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the collapse event:
        /// $("#element").wijsplitter({ collapse: function () { return false; } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplittercollapse", function () { return false; });
        /// </summary>
        null,
        expanded: /// <summary>
        /// Gets or sets the javascript function name that would be called
        /// when panel1 is expanded out by clicking the collapse/expand image.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the expanded event:
        /// $("#element").wijsplitter({ expanded: function () { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplitterexpanded", function () { });
        /// </summary>
        null,
        collapsed: /// <summary>
        /// Gets or sets the javascript function name that would be called
        /// when panel1 is collapsed by clicking the collapse/expand image.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the collapsed event:
        /// $("#element").wijsplitter({ collapsed: function () { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijsplittercollapsed", function () { });
        /// </summary>
        null,
        barZIndex: /// <summary>
        /// A value indicates the z-index of Splitter bar.
        /// Default: -1.
        /// Type: Number.
        /// </summary>
        -1,
        showExpander: /// <summary>
        /// A value determines whether the expander of Splitter
        /// is allowed to be shown.
        /// Default: true.
        /// Type: Boolean.
        /// </summary>
        true,
        splitterDistance: ///	<summary>
        ///	A value indicates the location of the splitter, in pixels,
        /// from the left or top edge of the splitter.
        /// Default: 100.
        /// Type: Number.
        ///	</summary>
        100,
        orientation: ///	<summary>
        ///	A value indicating the horizontal or vertical orientation
        /// of the splitter panels.
        /// Default: 'vertical'.
        /// Type: String.
        ///	</summary>
        'vertical',
        fullSplit: ///	<summary>
        ///	A value that indicates whether or not the control is full of document.
        /// Default: false.
        /// Type: Boolean.
        ///	</summary>
        false,
        resizeSettings: ///	<summary>
        ///	A value defines the animation while the bar of splitter
        /// is beeing dragged.
        /// Default: {}.
        /// Type: Object.
        ///	</summary>
        {
            animationOptions: {
                duration: ///	<summary>
                ///	Define how long (in milliseconds) the animation of
                /// the sliding will run.
                /// Default: 100.
                /// Type: Number.
                ///	</summary>
                100,
                easing: ///	<summary>
                ///	The easing that is applied to the animation.
                /// Default: 'swing'.
                /// Type: String.
                ///	</summary>
                "swing",
                disabled: ///	<summary>
                ///	A value that determines whether use the animation.
                /// Default: false.
                /// Type: Boolean.
                ///	</summary>
                false
            },
            ghost: ///	<summary>
            ///	A value that determines whether an outline of
            /// the element is sized.
            /// Default: false.
            /// Type: Boolean.
            ///	</summary>
            false
        },
        panel1: ///	<summary>
        ///	Defines the information for top or left panel of splitter.
        /// Default: {}.
        /// Type: Object.
        ///	</summary>
        {
            minSize: ///	<summary>
            ///	Gets or sets the minimum distance in pixels when
            /// resizing the splitter.
            /// Default: 1.
            /// Type: Number.
            ///	</summary>
            1,
            collapsed: ///	<summary>
            ///	A value determining whether splitter panel is
            /// collapsed or expanded.
            /// Default: false.
            /// Type: Boolean.
            ///	</summary>
            false,
            scrollBars: ///	<summary>
            ///	Gets or sets the type of scroll bars to display
            /// for splitter panel.
            /// Default: 'auto'.
            /// Type: String.
            ///	</summary>
            "auto"
        },
        panel2: ///	<summary>
        ///	Defines the information for bottom or right panel of splitter.
        /// Default: {}.
        /// Type: Object.
        ///	</summary>
        {
            minSize: ///	<summary>
            ///	Gets or sets the minimum distance in pixels when
            /// resizing the splitter.
            /// Default: 1.
            /// Type: Number.
            ///	</summary>
            1,
            collapsed: ///	<summary>
            ///	Gets or sets a value determining whether splitter
            /// panel is collapsed or expanded.
            /// Default: false.
            /// Type: Boolean.
            ///	</summary>
            false,
            scrollBars: ///	<summary>
            ///	Gets or sets the type of scroll bars to display for splitter panel.
            /// Default: 'auto'.
            /// Type: String.
            ///	</summary>
            "auto"
        },
        collapsingPanel: /// <summary>
        /// Specifies which panel should be collapsed after clicking the expander of splitter.
        /// Possible values are: "panel1" & "panel2".
        /// Default: "panel1".
        /// Type: String.
        /// </summary>
        "panel1",
        wijCSS: /// <summary>
        /// All CSS classes used in widgets.
        /// </summary>
        {
            cornerCssPrefix: "ui-corner-",
            arrowCssPrefix: "ui-icon-triangle-1-",
            panelCss: {
                panel1: {
                    n: "panel1",
                    content: "panel1-content"
                },
                panel2: {
                    n: "panel2",
                    content: "panel2-content"
                }
            },
            wrapperCss: "wijmo-wijsplitter-wrapper",
            hSplitterCss: "wijmo-wijsplitter-horizontal",
            vSplitterCss: "wijmo-wijsplitter-vertical",
            hSplitterCssPrefix: "wijmo-wijsplitter-h-",
            vSplitterCssPrefix: "wijmo-wijsplitter-v-",
            collapsedCss: "collapsed",
            expandedCss: "expanded",
            resizeHelperCss: "resize-helper",
            barCss: "bar",
            expanderCss: "expander"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body ui-body-c",
            stateDefault: "ui-btn-up-c"
        }
    });
    $.wijmo.registerWidget("wijsplitter", WijSplitter.prototype);
    if($.ui != null && $.ui.plugin != null) {
        $.ui.plugin.add("resizable", "wijanimate", {
            stop: function (event, ui) {
                var self = $(this).data("uiResizable"), o = self.options, element = self.element, pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : self.sizeDiff.height, soffsetw = ista ? 0 : self.sizeDiff.width, style, left, top;
                element.css("width", self.originalSize.width).css("height", self.originalSize.height);
                style = {
                    width: (self.size.width - soffsetw),
                    height: (self.size.height - soffseth)
                };
                left = (parseInt(element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null;
                top = (parseInt(element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;
                element.animate($.extend(style, top && left ? {
                    top: top,
                    left: left
                } : {
                }), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function () {
                        var data = {
                            width: parseInt(element.css('width'), 10),
                            height: parseInt(element.css('height'), 10),
                            top: parseInt(element.css('top'), 10),
                            left: parseInt(element.css('left'), 10)
                        };
                        if(pr && pr.length) {
                            $(pr[0]).css({
                                width: data.width,
                                height: data.height
                            });
                        }
                        // propagating resize, and updating values for each animation step
                        self._updateCache(data);
                        self._propagate("resize", event);
                        element.trigger("animating");
                    },
                    complete: function () {
                        element.trigger("animated");
                    }
                });
            }
        });
    }
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*globals setTimeout jQuery*/
/*
* Wijmo ProgressBar Widget
*
* Depends:
*	Jquery-1.4.2.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*
*Optional dependence for effect settings:
*	jquery.effects.core.js
*	jquery.effects.blind.js
*	jquery.effects.bounce.js
*	jquery.effects.clip.js
*	jquery.effects.drop.js
*	jquery.effects.explode.js
*	jquery.effects.fold.js
*	jquery.effects.hightlight.js
*	jquery.effects.pulsate.js
*	jquery.effects.scale.js
*	jquery.effects.shake.js
*	jquery.effects.slide.js
*	jquery.effects.transfer.js
* HTML:
*  <div id="progressbar" style="width:***;height:***"></div>
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery;
    var wijpbCss = "wijmo-wijprogressbar", pbCss = "ui-progressbar", pbLabelCss = pbCss + "-label", lblAlignPrefixCss = wijpbCss + "-lb-", cornerPrefixCss = "ui-corner-", cornerLeftCss = cornerPrefixCss + "left", cornerRightCss = cornerPrefixCss + "right", cornerTopCss = cornerPrefixCss + "top", cornerBottomCss = cornerPrefixCss + "bottom";
    var wijprogressbar = (function (_super) {
        __extends(wijprogressbar, _super);
        function wijprogressbar() {
            _super.apply(this, arguments);

        }
        wijprogressbar.prototype._setOption = function (key, value) {
            var self = this, o = self.options, val;
            switch(key) {
                case "value":
                    o[key] = parseInt(value, 10);
                    self._refreshValue();
                    return;
                case "maxValue":
                    o.max = value;
                case "minValue":
                    val = parseInt(value, 10);
                    o[key] = val;
                    self[key === "maxValue" ? "max" : "min"] = val;
                    self._refreshValue(true);
                    return;
                case "labelFormatString":
                case "toolTipFormatString":
                    o[key] = value;
                    self._refreshValue(true);
                    return;
                case "fillDirection":
                case "labelAlign":
                case "indicatorImage":
                    o[key] = value;
                    self._updateElementsCss();
                    return;
                default:
                    break;
            }
            $.Widget.prototype._setOption.apply(self, arguments);
            //Add for support disabled option at 2011/7/8
            if(key === "disabled") {
                self._handleDisabledOption(value, self.element);
            }
            //end for disabled option
                    };
        wijprogressbar.prototype._create = function () {
            var self = this, o = self.options, element = self.element;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            self.directions = {
                east: "left",
                west: "right",
                north: "bottom",
                south: "top"
            };
            self.min = o.minValue;
            //self.max = o.maxValue;
            self.max = o.max = o.maxValue//fixed bug when jui update to 1.8.18
            ;
            element.addClass(wijpbCss);
            $.ui.progressbar.prototype._create.apply(self, arguments);
            self.label = $("<span>").addClass(pbLabelCss).appendTo(element);
            self._updateElementsCss();
            self._isInit = true;
            //Add for support disabled option
            if(o.disabled) {
                self.disable();
            }
            //end for disabled option
            self._refreshValue();
        };
        wijprogressbar.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                self.disabledDiv.appendTo("body");
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
            }
        };
        wijprogressbar.prototype._createDisabledDiv = function (outerEle) {
            var self = this, ele = //Change your outerelement here
            outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight(), css = {
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top
            };
            if($.browser.msie) {
                $.extend(css, {
                    "background-color": "#fff",
                    opacity: 0.1
                });
            }
            return $("<div></div>").addClass("ui-disabled").css(css);
        };
        wijprogressbar.prototype._triggerEvent = function (eventName, oldValue, newValue, isFireEvent) {
            if(!isFireEvent) {
                return;
            }
            return this._trigger(eventName, null, {
                oldValue: oldValue,
                newValue: newValue
            }) === false;
        };
        wijprogressbar.prototype._refreshValue = function (forced) {
            var self = this, o = self.options, isFireEvent, animationOptions = o.animationOptions, indicatorIncrement = o.indicatorIncrement, element = self.element, value, percent, oldValue;
            if(!self._isInit) {
                return;
            }
            oldValue = element.attr("aria-valuenow");
            value = self.value();
            percent = (value - self.min) / (self.max - self.min) * 100;
            isFireEvent = parseInt(oldValue) != value;
            if(self._triggerEvent("beforeProgressChanging", oldValue, value, isFireEvent)) {
                return;
            }
            if(!animationOptions.disabled && animationOptions.duration > 0) {
                setTimeout(function () {
                    $.wijmo.wijprogressbar.animations.progress({
                        content: self.valueDiv,
                        complete: function () {
                            if(indicatorIncrement !== 1) {
                                self._refreshProgress(percent, value, isFireEvent);
                                if(o.labelAlign === "running") {
                                    self._updateRunningLabelCss(percent);
                                }
                            }
                            self._triggerEvent("progressChanged", oldValue, value, isFireEvent);
                            self._lastStep = percent;
                        },
                        step: function (ovalue) {
                            self._performAnimating(ovalue, forced, isFireEvent);
                        },
                        progressValue: value * 100
                    }, animationOptions);
                }, o.animationDelay);
            } else {
                self._refreshProgress(Math.round(percent));
                if(o.labelAlign === "running") {
                    self._updateRunningLabelCss(percent);
                }
                self._lastStep = percent;
                self._triggerEvent("progressChanged", oldValue, value, isFireEvent);
            }
        };
        wijprogressbar.prototype._refreshProgress = function (percent, curValue, isFireEvent) {
            var self = this, o = self.options, fillDirection = o.fillDirection, element = self.element;
            if(curValue === undefined) {
                curValue = $.wijmo.wijprogressbar.mul(percent, (self.max - self.min)) / 100 + self.min;
            }
            if(self._triggerEvent("progressChanging", element.attr("aria-valuenow"), curValue, isFireEvent)) {
                return;
            }
            if(self._isHorizontal()) {
                self.valueDiv.toggleClass(fillDirection === "east" ? cornerRightCss : cornerLeftCss, curValue === self.max).width(percent + "%");
            } else {
                self.valueDiv.toggleClass(fillDirection === "south" ? cornerBottomCss : cornerTopCss, curValue === self.max).height(percent + "%");
            }
            self.label.html(self._getFormatString(o.labelFormatString, percent, curValue));
            element.attr("aria-valuenow", curValue).attr("title", self._getFormatString(o.toolTipFormatString, percent, curValue));
        };
        wijprogressbar.prototype._isHorizontal = function () {
            var fillDirection = this.options.fillDirection;
            return fillDirection === "west" || fillDirection === "east";
        };
        wijprogressbar.prototype._getRotateTextOffset = function (label) {
            var width, height;
            label.css("width", "auto");
            width = label.outerWidth();
            height = label.outerHeight();
            label.css("width", "");
            return Math.max(width - height - 4, 0);
        };
        wijprogressbar.prototype._updateElementsCss = function () {
            var self = this, o = self.options, element = self.element, fillDirection = o.fillDirection;
            element.removeClass(wijpbCss + "-west " + wijpbCss + "-east " + wijpbCss + "-north " + wijpbCss + "-south").addClass(wijpbCss + "-" + fillDirection);
            //pb progress
            self._updateProgressCss();
            //pb label
            self._updateLabelCss();
        };
        wijprogressbar.prototype._updateLabelCss = function () {
            var self = this, o = self.options, element = self.element, labelAlign = o.labelAlign, label = self.label, lastStep = self._lastStep, height = element.height();
            label.removeClass(lblAlignPrefixCss + "west " + lblAlignPrefixCss + "east " + lblAlignPrefixCss + "south " + lblAlignPrefixCss + "north " + lblAlignPrefixCss + "center " + lblAlignPrefixCss + "running").addClass(lblAlignPrefixCss + labelAlign).css({
                left: "",
                right: "",
                top: "",
                bottom: "",
                width: "",
                "text-align": "",
                "line-height": ""
            });
            if(labelAlign !== "north" && labelAlign !== "south" && !(labelAlign === "running" && !self._isHorizontal())) {
                label.css("line-height", height + "px");
            }
            if(labelAlign === "running") {
                self._updateRunningLabelCss(lastStep);
            } else if(!self._isHorizontal() && !$.browser.msie) {
                //Add comments by RyanWu@20110325.
                //Because nonIE brownser will rotate the text,
                //I use a hack to set the text-align:right and
                //width:100%, then rotate it to the north.
                if(labelAlign === "north") {
                    label.css("width", "100%").css("text-align", "right");
                } else if(labelAlign === "south") {
                    label.css("width", "100%").css("text-align", "left");
                }
                //end by RyanWu@20110325.
                            }
        };
        wijprogressbar.prototype._updateRunningLabelCss = function (step) {
            var self = this, o = self.options, fillDirection = o.fillDirection, element = self.element, label = self.label, valueDiv = self.valueDiv, isHorizontal = self._isHorizontal(), pbLen, lblLen, pgLen, pos;
            pbLen = element[isHorizontal ? "width" : "height"]();
            lblLen = label[isHorizontal ? "outerWidth" : "outerHeight"]();
            pgLen = valueDiv[isHorizontal ? "outerWidth" : "outerHeight"]();
            //TODO:
            //Because the text will be rotated, we need calculate
            //the correct lengh of the rotated text.
            if(!isHorizontal && !$.browser.msie) {
                lblLen += self._getRotateTextOffset(label);
            }
            pos = pbLen === pgLen ? pbLen - lblLen : step * pbLen / 100 - lblLen + lblLen * (pbLen - pgLen) / pbLen;
            label.css(self.directions[fillDirection], pos);
        };
        wijprogressbar.prototype._updateProgressCss = function () {
            var self = this, o = self.options, fillDirection = o.fillDirection, indicatorImage = o.indicatorImage, valueDiv = self.valueDiv, lastStep = self._lastStep;
            if(indicatorImage !== "") {
                valueDiv.css("background", "transparent url(" + indicatorImage + ") repeat fixed");
            }
            valueDiv.removeClass(cornerLeftCss + " " + cornerRightCss + " " + cornerTopCss + " " + cornerBottomCss).addClass(cornerPrefixCss + self.directions[fillDirection]);
            if(typeof lastStep === "number") {
                if(self._isHorizontal()) {
                    valueDiv.css("width", lastStep + "%").css("height", "");
                } else {
                    valueDiv.css("height", lastStep + "%").css("width", "");
                }
            } else {
                valueDiv.css({
                    width: "",
                    height: ""
                });
            }
        };
        wijprogressbar.prototype._performAnimating = function (step, forced, isFireEvent) {
            var self = this, o = self.options, indicatorIncrement = o.indicatorIncrement, curValue = step / 100, percent = $.wijmo.wijprogressbar.div((curValue - self.min), (self.max - self.min)) * 100, ln = 0, arrP, base, resultPrecision = 2;
            if(indicatorIncrement) {
                //arrP = percent.toString().split(".");
                //if (arrP.length === 2) {
                //	ln = arrP[1].length;
                //	resultPrecision = ln;
                //}
                //base = Math.pow(10, ln);
                if(indicatorIncrement !== 1) {
                    percent = Math.floor(percent / indicatorIncrement) * indicatorIncrement;
                } else {
                    percent = Math.round(percent);
                    resultPrecision = 0;
                }
                self.pointNumber = ln;
                if(self._lastStep === percent && !forced) {
                    return;
                }
            }
            //self._lastStep = percent;
            self._refreshProgress(Number(percent.toFixed(resultPrecision)), Number(curValue.toFixed(resultPrecision)), isFireEvent);
            if(o.labelAlign === "running") {
                self._updateRunningLabelCss(percent);
            }
        };
        wijprogressbar.prototype._getFormatString = function (format, percent, value) {
            var self = this, remainingProgress = self.max - value, percentageRemaining = 100 - percent, r = /\{0\}/g;
            format = format.replace(r, value.toString());
            r = /\{ProgressValue\}/g;
            format = format.replace(r, value.toString());
            r = /\{1\}/g;
            format = format.replace(r, percent.toString());
            r = /\{PercentProgress\}/g;
            format = format.replace(r, percent.toString());
            r = /\{2\}/g;
            format = format.replace(r, remainingProgress.toString());
            r = /\{RemainingProgress\}/g;
            format = format.replace(r, remainingProgress.toString());
            r = /\{3\}/g;
            format = format.replace(r, percentageRemaining.toString());
            r = /\{PercentageRemaining\}/g;
            format = format.replace(r, percentageRemaining.toString());
            r = /\{4\}/g;
            format = format.replace(r, self.min);
            r = /\{Min\}/g;
            format = format.replace(r, self.min);
            r = /\{5\}/g;
            format = format.replace(r, self.max);
            r = /\{Max\}/g;
            format = format.replace(r, self.max);
            return format;
        };
        wijprogressbar.prototype.destroy = function () {
            var self = this, element = self.element;
            element.attr("title", "").removeClass(wijpbCss + " " + wijpbCss + "-east " + wijpbCss + "-west " + wijpbCss + "-north " + wijpbCss + "-south");
            if(self.label) {
                self.label.remove();
            }
            //Add for support disabled option at 2011/7/8
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            //end for disabled option
            $.ui.progressbar.prototype.destroy.apply(this, arguments);
        };
        return wijprogressbar;
    })(wijmo.JQueryUIWidget);
    wijmo.wijprogressbar = wijprogressbar;    
    if($.ui && $.ui.progressbar) {
        wijprogressbar.prototype.options = $.extend(true, {
        }, $.ui.progressbar.prototype.options, {
            labelAlign: /// <summary>
            ///The label's alignment on the progress bar. The value should be "east",
            /// "west", "center", "north", "south" or "running".
            ///Default:"center".
            ///Type:String.
            ///Code sample:$('.selector').wijprogressbar('option','labelAlign','center').
            ///</summary>
            "center",
            maxValue: /// <summary>
            ///The value of the progress bar,the type should be numeric.
            ///Default:0.
            ///Type:Number.
            ///Code sample:$('.selector').wijprogressbar('option','value',60).
            ///</summary>
            100,
            minValue: /// <summary>
            ///The minimum value of the progress bar,the type should be numeric.
            ///Default:0.
            ///Type:Number.
            ///Code sample:$('.selector').wijprogressbar('option','minValue',0).
            ///</summary>
            0,
            fillDirection: /// <summary>
            ///The fill direction of the progress bar.the value should be "east",
            ///"west", "north" or "south".
            ///Default:"east".
            ///Type:String.
            ///Code sample:$('.selector').wijprogressbar('option','fillDirection','east').
            ///</summary>
            "east",
            labelFormatString: /// <summary>
            ///The progressbar's orientation.the value should be 'horizontal'
            /// or 'vertical'.
            ///Default:"horizontal".
            ///Type:String.
            ///Code sample:$('selector').wijprogressbar('option','orientation',
            ///'horizontal').
            ///</summary>
            ///orientation: "horizontal",
            /// <summary>
            ///Sets the format of the label text.The available formats are as follows:
            ///{0} or {ProgressValue} express the current progress Value.
            ///{1} or {PercentProgress} express the current percent of the progress bar.
            ///{2} or {RemainingProgress} express the remaining progress of the
            ///progress bar.
            ///{3} or {PercentageRemaining} express the remaining percent of
            ///the progress bar.
            ///{4} or {Min} express the min Vlaue of the progress bar.
            ///{5} or {Max} express the max Value of the progress bar.
            ///Default:"{1}%".
            ///Type:String.
            ///Code sample:$('.selector').wijprogressbar('option','labelFormatString'
            ///,'{0}%').
            ///</summary>
            "{1}%",
            toolTipFormatString: /// <summary>
            ///Set the format of the ToolTip of the progress bar,the expression of the
            ///format like the labelFormatString.
            ///Default:"{1}%".
            ///Type:String.
            ///Code sample:$('.selector').wijprogressbar('option','toolTipFormatString'
            ///,'{1}%').
            ///</summary>
            "{1}%",
            indicatorIncrement: /// <summary>
            ///The increment of the progress bar's indicator.
            ///Default:1.
            ///Type:Number.
            ///</summary>
            ///Code sample:$('.selector').wijprogressbar('option',
            ///'indicatorIncrement',10).
            1,
            indicatorImage: /// <summary>
            ///The Image's url of the indicator.
            ///Default:"".
            ///Type:String.
            ///Code sample:$('.selector').wijprogressbar('option','indicatorImage',
            ///'images/abc.png').
            ///</summary>
            "",
            animationDelay: /// <summary>
            ///The delay of the progressbar's animation.
            ///Default:0.
            ///Type:Number.
            ///Code sample:$('.selector').wijprogressbar('option',
            ///</summary>
            0,
            animationOptions: /// <summary>
            ///The options parameter of the jQuery's animation.
            ///Default:"{animated:'progress', duration:500, disabled:false}".
            ///Type:Options.
            ///Code sample:$('.selector').wijprogressbar('option','animationOptions',
            ///{animated:'progress',duration:600}).
            ///</summary>
            {
                disabled: false,
                easing: null,
                duration: 500
            },
            progressChanging: /// <summary>
            /// Fire upon running the progress.
            /// Default: null.
            /// Type: Function
            /// Code example: $(".selector").wijprogressbar("progressChanging",
            /// function(e, data){})
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object
            /// </param>
            /// <param name="data" type="Object">
            /// data.oldValue: The old value of the progressbar.
            /// data.newValue: The new value of the progressbar.
            ///</param>
            /// <returns type="Boolean" >
            /// return false to cancel the event.
            /// </returns>
            null,
            beforeProgressChanging: /// <summary>
            /// Fires before running the progress.
            /// Default: null.
            /// Type: Function
            /// Code example: $(".selector").wijprogressbar("beforeProgressChanging",
            /// function(e, data){})
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// data.oldValue: The old value of the progressbar.
            /// data.newValue: The new value of the progressbar.
            /// </param>
            /// <returns type="Boolean">
            /// Return false to cancel the event.
            /// </returns>
            null,
            progressChanged: /// <summary>
            /// Fires when the progress changes.
            /// Default: null.
            /// Type: Function
            /// Code example: $(".selector").wijprogressbar("progressChanged",
            /// function(e, data){})
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// data.oldValue: The old value of the progressbar.
            /// data.newValue: The new value of the progressbar.
            /// </param>
            null
        });
        $.wijmo.registerWidget("wijprogressbar", $.ui.progressbar, wijprogressbar.prototype);
        $.extend($.wijmo.wijprogressbar, {
            animations: {
                progress: function (options, additions) {
                    options = $.extend({
                        easing: "swing",
                        duration: 1000
                    }, options, additions);
                    options.content.stop(true, true).animate({
                        pgvalue: //Because jquery's animation needs an
                        //attribute or css style to do the animation,
                        //here we use a temporary attribute to
                        //do the animation on the value div element.
                        options.progressValue
                    }, options);
                }
            },
            add: function (arg1, arg2) {
                var r1 = 0, r2 = 0, m;
                try  {
                    r1 = arg1.toString().split(".")[1].length;
                } catch (e) {
                }
                try  {
                    r2 = arg2.toString().split(".")[1].length;
                } catch (e1) {
                }
                m = Math.pow(10, Math.max(r1, r2));
                return (arg1 * m + arg2 * m) / m;
            },
            mul: function (arg1, arg2) {
                var m = 0, s1 = arg1.toString(), s2 = arg2.toString();
                try  {
                    m += s1.split(".")[1].length;
                } catch (e) {
                }
                try  {
                    m += s2.split(".")[1].length;
                } catch (e1) {
                }
                return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
            },
            div: function (arg1, arg2) {
                var t1 = 0, t2 = 0, r1, r2;
                try  {
                    t1 = arg1.toString().split(".")[1].length;
                } catch (e) {
                }
                try  {
                    t2 = arg2.toString().split(".")[1].length;
                } catch (e1) {
                }
                r1 = Number(arg1.toString().replace(".", ""));
                r2 = Number(arg2.toString().replace(".", ""));
                return (r1 / r2) * Math.pow(10, t2 - t1);
            }
        });
    }
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*globals window,document,jQuery*/
/*
* Depends:
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jquery.ui.resizable.js
*	jquery.ui.mouse.js
*	jquery.wijmo.wijutil.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijdialog", uiStateHover = "ui-state-hover", zonCSS = "wijmo-wijdialog-defaultdockingzone";
    var WijDialog = (function (_super) {
        __extends(WijDialog, _super);
        function WijDialog() {
            _super.apply(this, arguments);

        }
        WijDialog.prototype._create = function () {
            var self = this, o = self.options;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            //Add support for jUICE!
            if($.isArray(o.buttons)) {
                $.each(o.buttons, function (idx, value) {
                    var c = value.click;
                    if(c && (typeof c === "string") && window[c]) {
                        value.click = window[c];
                    }
                });
            }
            //end
            self.form = self.element.closest("form[id]")// for asp.net
            ;
            $.ui.dialog.prototype._create.apply(self, arguments);
            self.uiDialog.addClass("wijmo-wijdialog");
            self._initWijWindow();
            self._bindWindowResize();
            self._attachDraggableResizableEvent();
            self._originalPosition = o.position;
            self.isPin = false;
            if(self.form.length) {
                self.uiDialog.appendTo(self.form);
            }
        };
        WijDialog.prototype._init = function () {
            $.ui.dialog.prototype._init.apply(this, arguments);
        };
        WijDialog.prototype._makeDraggable = function () {
            $.ui.dialog.prototype._makeDraggable.apply(this, arguments);
            this.uiDialog.draggable("option", "cancel", ".wijmo-wijdialog-captionbutton");
        };
        WijDialog.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv();
                }
                self.disabledDiv.appendTo("body");
                if($.browser.msie) {
                    self.uiDialog.draggable("disable");
                }
            } else if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
                if($.browser.msie) {
                    self.uiDialog.draggable("enable");
                }
            }
        };
        WijDialog.prototype._createDisabledDiv = function () {
            var self = this, div, ele = //Change your outerelement here
            self.uiDialog, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
            div = $("<div></div>").addClass("ui-disabled").css({
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top
            });
            if($.browser.msie) {
                div.css("background-color", "white");
                if($.browser.version === "9.0") {
                    div.css("opacity", "0.1");
                }
            }
            return div;
        };
        WijDialog.prototype.destroy = function () {
            var self = this;
            //Add for support disabled option at 2011/7/8
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            //end for disabled option
            $.ui.dialog.prototype._destroy.apply(self, arguments);
            self.element.unbind(".wijdialog").removeData('wijdialog');
        };
        WijDialog.prototype._attachDraggableResizableEvent = function () {
            var self = this, uiDialog = self.uiDialog, o = self.options;
            if(o.draggable && uiDialog.draggable) {
                uiDialog.bind("dragstop", function (event, ui) {
                    self._saveNormalState();
                    self._destoryIframeMask();
                }).bind("dragstart", function (event, ui) {
                    self._createIframeMask();
                });
            }
            if(o.resizable && uiDialog.resizable) {
                uiDialog.bind("resizestop", function (event, ui) {
                    self._saveNormalState();
                    self._destoryIframeMask();
                }).bind("resizestart", function (event, ui) {
                    self._createIframeMask();
                });
            }
        };
        WijDialog.prototype._createIframeMask = //fixed iframe bug.
        function () {
            var self = this;
            if(self.innerFrame) {
                self.mask = $("<div style='width:100%;height:100%;position:absolute;" + "top:0px;left:0px;z-index:" + ($.ui.dialog.maxZ + 1) + "'></div>").appendTo(self.uiDialog);
            }
        };
        WijDialog.prototype._destoryIframeMask = function () {
            var self = this;
            if(self.innerFrame && self.mask) {
                self.mask.remove();
                self.mask = undefined;
            }
        };
        WijDialog.prototype._initWijWindow = function () {
            var self = this, isIn = true;
            self._createCaptionButtons();
            self._checkUrl();
            //self.uiDialogButtonPane = $(".ui-dialog-buttonpane", self.uiDialog);
            self.uiDialog.bind("mousedown", function (event) {
                var el = event.target;
                if(!$.contains(self.element[0], el)) {
                    self.uiDialog.focus();
                }
            }).bind("mouseenter", function (event) {
                isIn = true;
            }).bind("mouseleave", function (event) {
                isIn = false;
            }).bind("focusout", function (event) {
                if(!isIn) {
                    self._trigger("blur", event, {
                        el: self.element
                    });
                }
            });
        };
        WijDialog.prototype._checkUrl = function () {
            var self = this, o = self.options, url = o.contentUrl, innerFrame = $('<iframe style="width:100%;height:99%;" frameborder="0"></iframe>');
            if(typeof url === "string" && url.length > 0) {
                self.element.addClass("wijmo-wijdialog-hasframe");
                //innerFrame.attr("src", url);
                self.element.append(innerFrame);
                self.innerFrame = innerFrame;
            }
            self.contentWrapper = self.element;
        };
        WijDialog.prototype._setOption = function (key, value) {
            var self = this;
            $.ui.dialog.prototype._setOption.apply(self, arguments);
            //			if (key === "captionButtons") {
            //				// self._createCaptionButtons();
            //				// todo: reset captionButtons
            //			}
            //			//Add for support disabled option at 2011/7/8
            //			else
            if(key === "disabled") {
                self._handleDisabledOption(value, self.element);
            } else //end for disabled option
            if(key === "contentUrl") {
                if(self.innerFrame) {
                    self.innerFrame.attr("src", value);
                } else {
                    self._checkUrl();
                }
            } else if(key = "captionButtons") {
                self._createCaptionButtons();
            }
        };
        WijDialog.prototype._createCaptionButtons = function () {
            var captionButtons = [], self = this, o = self.options, i, buttons = {
                pin: {
                    visible: true,
                    click: self.pin,
                    iconClassOn: "ui-icon-pin-w",
                    iconClassOff: "ui-icon-pin-s"
                },
                refresh: {
                    visible: true,
                    click: self.refresh,
                    iconClassOn: "ui-icon-refresh"
                },
                toggle: {
                    visible: true,
                    click: self.toggle,
                    iconClassOn: "ui-icon-carat-1-n",
                    iconClassOff: "ui-icon-carat-1-s"
                },
                hint: {
                    visible: true,
                    click: self.hint,
                    message: "",
                    iconClassOn: "ui-icon-lightbulb"
                },
                minimize: {
                    visible: true,
                    click: self.minimize,
                    iconClassOn: "ui-icon-minus"
                },
                maximize: {
                    visible: true,
                    click: self.maximize,
                    iconClassOn: "ui-icon-extlink"
                },
                close: {
                    visible: true,
                    click: self.close,
                    iconClassOn: "ui-icon-close"
                }
            }, oCaptionButtons = o.captionButtons, uiDialogTitlebar = self.uiDialogTitlebar;
            uiDialogTitlebar.children(".ui-dialog-titlebar-close, .wijmo-wijdialog-captionbutton").remove();
            $.each(buttons, function (name, value) {
                if(oCaptionButtons && oCaptionButtons[name]) {
                    $.extend(value, oCaptionButtons[name]);
                }
                captionButtons.push({
                    button: name,
                    info: value
                });
            });
            self._trigger("buttonCreating", null, captionButtons);
            for(i = 0; i < captionButtons.length; i++) {
                self._createCaptionButton(captionButtons[i], uiDialogTitlebar);
            }
        };
        WijDialog.prototype._createCaptionButton = function (buttonHash, uiDialogTitlebar, notAppendToHeader) {
            var self = this, buttonObject, buttonCSS = "wijmo-wijdialog-titlebar-" + buttonHash.button, button = uiDialogTitlebar.children("." + buttonCSS), info = buttonHash.info, buttonIcon = $("<span></span>");
            if(info.visible) {
                if(button.size() === 0) {
                    buttonIcon.addClass("ui-icon " + info.iconClassOn).text(info.text || buttonHash.button);
                    buttonObject = $('<a href="#"></a>').append(buttonIcon).addClass(buttonCSS + " ui-corner-all wijmo-wijdialog-captionbutton").attr("role", "button").hover(function () {
                        buttonObject.addClass(uiStateHover);
                    }, function () {
                        buttonObject.removeClass(uiStateHover);
                    }).click(function (event) {
                        if(buttonIcon.hasClass(info.iconClassOff)) {
                            buttonIcon.removeClass(info.iconClassOff);
                        } else {
                            buttonIcon.addClass(info.iconClassOff);
                        }
                        if($.isFunction(info.click)) {
                            info.click.apply(self, arguments);
                        }
                        return false;
                    });
                    if(notAppendToHeader) {
                        return buttonObject;
                    } else {
                        buttonObject.appendTo(uiDialogTitlebar);
                    }
                }
                self[buttonHash.button + "Button"] = buttonObject;
            } else {
                button.remove();
            }
        };
        WijDialog.prototype.pin = function () {
            ///	<summary>
            ///		Pins the wijdialog instance so that it could not be moved.
            ///	</summary>
                        var drag = this.isPin, buttonIcon = this.pinButton.children("span");
            if(!drag) {
                if(buttonIcon.length) {
                    if(!buttonIcon.hasClass("ui-icon-pin-s")) {
                        buttonIcon.addClass("ui-icon-pin-s");
                    }
                }
            } else {
                buttonIcon.removeClass("ui-icon-pin-s");
            }
            this._enableDisableDragger(!drag);
            this.isPin = !drag;
        };
        WijDialog.prototype.refresh = function () {
            ///	<summary>
            ///		Refreshes the iframe content in wijdialog.
            ///	</summary>
            var fr = this.innerFrame;
            if(fr !== undefined) {
                fr.attr("src", fr.attr("src"));
            }
        };
        WijDialog.prototype.toggle = function () {
            var self = this, buttonIcon = self.toggleButton.children("span");
            // TODO : toggle animation and event invoking.
            if(!self.minimized) {
                if(self.collapsed === undefined || !self.collapsed) {
                    self.collapsed = true;
                    if(!buttonIcon.hasClass("ui-icon-carat-1-s")) {
                        buttonIcon.addClass("ui-icon-carat-1-s");
                    }
                    self._collapseDialogContent(true);
                } else {
                    self.collapsed = false;
                    if(buttonIcon.hasClass("ui-icon-carat-1-s")) {
                        buttonIcon.removeClass("ui-icon-carat-1-s");
                    }
                    self._expandDialogContent(true);
                }
            }
        };
        WijDialog.prototype._expandDialogContent = function (fireEvent) {
            var self = this, o = self.options, animationSetting = o.expandingAnimation;
            self.uiDialog.height("auto");
            if(fireEvent && animationSetting !== null) {
                self.contentWrapper.show(animationSetting.animated, animationSetting.options, animationSetting.duration, function (e) {
                    self.uiDialog.css("height", self._toggleHeight);
                    if($.isFunction(animationSetting.callback)) {
                        animationSetting.callback(e);
                    }
                    if(o.resizable) {
                        self._enableDisableResizer(false);
                    }
                });
            } else {
                self.contentWrapper.show();
                if(o.resizable) {
                    self._enableDisableResizer(false);
                }
                self.uiDialog.css("height", self.toggleHeight);
            }
        };
        WijDialog.prototype._collapseDialogContent = function (fireEvent) {
            var self = this, o = self.options, animationSetting = o.collapsingAnimation;
            if(o.resizable) {
                self._enableDisableResizer(true);
            }
            self._toggleHeight = self.uiDialog[0].style.height;
            self.uiDialog.height("auto");
            if(fireEvent && animationSetting !== null) {
                self.contentWrapper.hide(animationSetting.animated, animationSetting.options, animationSetting.duration);
            } else {
                self.contentWrapper.hide();
            }
            self._enableDisableDragger(self.isPin);
        };
        WijDialog.prototype._enableDisableResizer = function (disabled) {
            var dlg = this.uiDialog;
            if(!this.options.resizable) {
                return;
            }
            dlg.resizable({
                disabled: disabled
            });
            if(disabled) {
                dlg.removeClass("ui-state-disabled");
            }
        };
        WijDialog.prototype._enableDisableDragger = function (disabled) {
            var dlg = this.uiDialog;
            if(!this.options.draggable) {
                return;
            }
            dlg.draggable({
                disabled: disabled
            });
            if(disabled) {
                dlg.removeClass("ui-state-disabled");
            }
        };
        WijDialog.prototype.minimize = function () {
            ///	<summary>
            ///		Minimizes wijdialog.
            ///	</summary>
                        var self = this, dlg = self.uiDialog, o = self.options, miniZone = null, $from = $("<div></div>"), $to = $("<div></div>"), defaultZone, scrollTop, top, originalPosition, originalSize = {
                width: undefined,
                height: undefined
            }, position, size = {
                width: undefined,
                height: undefined
            }, content = "uiDialog", originalState;
            //content has 2 value 'uiDialog' for normal content,'copy' for iframe
            //to resolve the issue that iframe reload when minimize.
            //Only minimize from normal,maximized state
            if(!self.minimized) {
                originalPosition = self.uiDialog.position();
                originalSize.width = self.uiDialog.width();
                originalSize.height = self.uiDialog.height();
                originalState = self.getState();
                if(self.maximized) {
                    self.maximized = false;
                    self.restoreButton.remove();
                    //fixed bug can't minimize window when it's maximized
                    $(window).unbind(".onWinResize");
                } else {
                    // minimize from normal state
                    if(self.collapsed) {
                        self._expandDialogContent(false);
                    }
                    self._saveNormalState();
                }
                // disable resizer
                self._enableDisableResizer(true);
                //hide content
                if(self.collapsed) {
                    self._collapseDialogContent(false);
                }
                $from.appendTo(document.body).css({
                    top: self.uiDialog.offset().top,
                    left: self.uiDialog.offset().left,
                    height: self.uiDialog.innerHeight(),
                    width: self.uiDialog.innerWidth(),
                    position: "absolute"
                });
                self.contentWrapper.hide();
                if(self.uiDialogButtonPane.length) {
                    self.uiDialogButtonPane.hide();
                }
                // remove size restriction
                dlg.height("auto");
                dlg.width("auto");
                self._doButtonAction(self.minimizeButton, "hide");
                self._restoreButton(true, self.minimizeButton, "After");
                self._doButtonAction(self.pinButton, "hide");
                self._doButtonAction(self.refreshButton, "hide");
                self._doButtonAction(self.toggleButton, "hide");
                self._doButtonAction(self.maximizeButton, "show");
                if($.browser.webkit) {
                    $(".wijmo-wijdialog-captionbutton", self.uiDialog).css("float", "left");
                }
                if(self.innerFrame) {
                    content = "copy";
                    self[content] = self.uiDialog.clone();
                    self[content].empty();
                    self.uiDialogTitlebar.appendTo(self[content]);
                }
                if(o.minimizeZoneElementId.length > 0) {
                    miniZone = $("#" + o.minimizeZoneElementId);
                }
                if(miniZone !== null && miniZone.size() > 0) {
                    miniZone.append(self[content]);
                } else {
                    defaultZone = $("." + zonCSS);
                    if(defaultZone.size() === 0) {
                        defaultZone = $('<div class="' + zonCSS + '"></div>');
                        $(document.body).append(defaultZone);
                    }
                    defaultZone.append(self[content]).css("z-index", dlg.css("z-index"));
                }
                self[content].css("position", "static");
                self[content].css("float", "left");
                if($.browser.msie && $.browser.version === '6.0') {
                    scrollTop = $(document).scrollTop();
                    top = document.documentElement.clientHeight - defaultZone.height() + scrollTop;
                    defaultZone.css({
                        position: 'absolute',
                        left: "0px",
                        top: top
                    });
                }
                $to.appendTo(document.body).css({
                    top: self[content].offset().top,
                    left: self[content].offset().left,
                    height: self[content].innerHeight(),
                    width: self[content].innerWidth(),
                    position: "absolute"
                });
                self.uiDialog.hide();
                if(self.innerFrame) {
                    self[content].hide();
                }
                $from.effect("transfer", {
                    to: $to,
                    className: "ui-widget-content"
                }, 100, function () {
                    $from.remove();
                    $to.remove();
                    self[content].show();
                    self.minimized = true;
                    position = self.uiDialog.position();
                    size.width = self.uiDialog.width();
                    size.height = self.uiDialog.height();
                    self._enableDisableDragger(true);
                    self._trigger('resize', null, {
                        originalPosition: originalPosition,
                        originalSize: originalSize,
                        position: position,
                        size: size
                    });
                    self._trigger("stateChanged", null, {
                        originalState: originalState,
                        state: "minimized"
                    });
                });
            }
        };
        WijDialog.prototype._doButtonAction = function (button, action) {
            if(button !== undefined) {
                button.removeClass(uiStateHover);
                button[action]();
            }
        };
        WijDialog.prototype.maximize = function () {
            var self = this, w = $(window), originalPosition, originalSize = {
                width: undefined,
                height: undefined
            }, position, size = {
                width: undefined,
                height: undefined
            }, state;
            if(!self.maximized) {
                self._enableDisableDragger(false);
                originalPosition = self.uiDialog.position();
                originalSize.width = self.uiDialog.width();
                originalSize.height = self.uiDialog.height();
                // maximized from minimized state
                if(self.minimized) {
                    self.restore()//bug in IE when minimize -> maximize -> restore
                    ;
                } else {
                    if(self.collapsed) {
                        self._expandDialogContent(false);
                    }
                    self._saveNormalState();
                    state = "normal";
                }
                self.maximized = true;
                if(self.maximizeButton !== undefined) {
                    self.maximizeButton.hide();
                    self._restoreButton(true, self.maximizeButton, "Before");
                }
                if($.browser.webkit) {
                    $(".wijmo-wijdialog-captionbutton").css("float", "");
                }
                self._onWinResize(self, w);
                if(self.collapsed) {
                    self._collapseDialogContent(false);
                }
                /// TODO : bind resize event.
                if(!self.collapsed) {
                    self._enableDisableDragger(true);
                }
                self._enableDisableResizer(true);
                position = self.uiDialog.position();
                size.width = self.uiDialog.width();
                size.height = self.uiDialog.height();
                self._trigger('resize', null, {
                    originalPosition: originalPosition,
                    originalSize: originalSize,
                    position: position,
                    size: size
                });
                if(state === "normal") {
                    self._trigger("stateChanged", null, {
                        originalState: "normal",
                        state: "maximized"
                    });
                }
            }
        };
        WijDialog.prototype._bindWindowResize = function () {
            var self = this, w = $(window), top, scrollTop, defaultZone;
            w.resize(function () {
                if(self.maximized) {
                    self._onWinResize(self, w);
                }
            });
            //fixed ie 6 position:fixed
            if($.browser.msie && $.browser.version === '6.0') {
                w.bind("scroll.wijdialog resize.wijdialog", function () {
                    if(self.minimized) {
                        scrollTop = $(document).scrollTop();
                        defaultZone = self.uiDialog.parent();
                        top = document.documentElement.clientHeight - defaultZone.height() + scrollTop;
                        defaultZone.css({
                            top: top
                        });
                    }
                });
            }
        };
        WijDialog.prototype._saveNormalState = function () {
            var self = this, dialog = self.uiDialog, ele = self.element;
            if(!self.maximized) {
                self.normalWidth = dialog.css("width");
                self.normalLeft = dialog.css("left");
                self.normalTop = dialog.css("top");
                self.normalHeight = dialog.css("height");
                self.normalInnerHeight = ele.css("height");
                self.normalInnerWidth = ele.css("width");
                self.normalInnerMinWidth = ele.css("min-width");
                self.normalInnerMinHeight = ele.css("min-height");
            }
        };
        WijDialog.prototype._onWinResize = function (self, w) {
            self.uiDialog.css("top", w.scrollTop());
            self.uiDialog.css("left", w.scrollLeft());
            self.uiDialog.setOutWidth(w.width());
            self.uiDialog.setOutHeight(w.height());
            self.options.width = self.uiDialog.width();
            self.options.height = self.uiDialog.height();
            self._size();
            if(self.collapsed) {
                //fixed bug when resize on maxmize and collapse state.
                self.uiDialog.height("auto");
                self.contentWrapper.hide();
            }
        };
        WijDialog.prototype._restoreButton = function (show, button, position) {
            var self = this, buttonHash = {
                button: "restore",
                info: {
                    visible: show,
                    click: self.restore,
                    iconClassOn: "ui-icon-newwin"
                }
            }, restore = self._createCaptionButton(buttonHash, self.uiDialogTitlebar, true);
            if(show) {
                restore["insert" + position](button);
                self.restoreButton = restore;
            }
        };
        WijDialog.prototype._appendToBody = function (dlg) {
            if(!this.innerFrame) {
                dlg.appendTo(document.body);
            } else {
                this.uiDialogTitlebar.prependTo(dlg);
                dlg.show();
            }
        };
        WijDialog.prototype.restore = function () {
            /// <summary>
            ///		Restores wijdialog to normal size.
            /// </summary>
                        var self = this, dlg = self.uiDialog, originalPosition, originalSize = {
                width: undefined,
                height: undefined
            }, position, size = {
                width: undefined,
                height: undefined
            }, $from = $("<div></div>"), $to = $("<div></div>"), content = "uiDialog", state;
            //content has 2 value 'uiDialog' for normal content,'copy' for iframe
            //to resolve the issue that iframe reload when minimize on ff & webkit.
            // restore form minimized state.
            if(self.minimized) {
                self.minimized = false;
                //self._enableDisableDragger(false);
                if(self.innerFrame) {
                    content = "copy";
                    if(!self[content]) {
                        content = "uiDialog";
                    }
                }
                originalPosition = self[content].position();
                originalSize.width = self[content].width();
                originalSize.height = self[content].height();
                $from.appendTo(document.body).css({
                    top: self[content].offset().top,
                    left: self[content].offset().left,
                    height: self[content].innerHeight(),
                    width: self[content].innerWidth(),
                    position: "absolute"
                });
                dlg.css("position", "absolute");
                dlg.css("float", "");
                self._appendToBody(dlg);
                self._enableDisableResizer(false);
                if(!self.isPin) {
                    self._enableDisableDragger(false);
                }
                self._restoreToNormal();
                self.contentWrapper.show();
                if(self.uiDialogButtonPane.length) {
                    self.uiDialogButtonPane.show();
                }
                $to.appendTo(document.body).css({
                    top: self.uiDialog.offset().top,
                    left: self.uiDialog.offset().left,
                    height: self.uiDialog.innerHeight(),
                    width: self.uiDialog.innerWidth(),
                    position: "absolute"
                });
                self.uiDialog.hide();
                $from.effect("transfer", {
                    to: $to,
                    className: "ui-widget-content"
                }, 150, function () {
                    self.uiDialog.show();
                    position = self.uiDialog.position();
                    size.width = self.uiDialog.width();
                    size.height = self.uiDialog.height();
                    $from.remove();
                    $to.remove();
                    if(self.copy) {
                        self.copy.remove();
                    }
                    self._trigger('resize', null, {
                        originalPosition: originalPosition,
                        originalSize: originalSize,
                        position: position,
                        size: size
                    });
                    state = self.getState();
                    self._trigger("stateChanged", null, {
                        originalState: "minimized",
                        state: state
                    });
                });
                if(self.collapsed) {
                    self._collapseDialogContent();
                }
                self._doButtonAction(self.minimizeButton, "show");
                self._doButtonAction(self.restoreButton, "remove");
                self._doButtonAction(self.pinButton, "show");
                self._doButtonAction(self.refreshButton, "show");
                self._doButtonAction(self.toggleButton, "show");
                if($.browser.webkit) {
                    $(".wijmo-wijdialog-captionbutton").css("float", "");
                }
            } else if(self.maximized) {
                self.maximized = false;
                originalPosition = self.uiDialog.position();
                originalSize.width = self.uiDialog.width();
                originalSize.height = self.uiDialog.height();
                $(window).unbind(".onWinResize");
                if(self.collapsed) {
                    self._expandDialogContent();
                }
                self._enableDisableResizer(false);
                if(!self.isPin) {
                    self._enableDisableDragger(false);
                }
                self._restoreToNormal();
                self.contentWrapper.show();
                if(self.collapsed) {
                    self._collapseDialogContent();
                }
                if(self.maximizeButton !== undefined) {
                    self.maximizeButton.show();
                    self._restoreButton(false, self.maximizeButton, "before");
                }
                position = self.uiDialog.position();
                size.width = self.uiDialog.width();
                size.height = self.uiDialog.height();
                self._trigger('resize', null, {
                    originalPosition: originalPosition,
                    originalSize: originalSize,
                    position: position,
                    size: size
                });
                state = self.getState();
                self._trigger("stateChanged", null, {
                    originalState: "maximized",
                    state: state
                });
            }
        };
        WijDialog.prototype.getState = function () {
            /// <summary>
            ///		Gets the state of this dialog, the possible values are:
            //		"minimized", "maximized", "normal".
            /// </summary>
            var self = this;
            return self.minimized ? "minimized" : (self.maximized ? "maximized" : "normal");
        };
        WijDialog.prototype.hint = function () {
            var self = this, o = self.options;
            alert(o.message);
        };
        WijDialog.prototype.reset = function () {
            /// <summary>
            ///		Resets the properties ("width" ,"height", "position")
            ///     to their default values.
            /// </summary>
            var self = this;
            self.normalWidth = self.normalLeft = self.normalTop = self.normalHeight = self.normalInnerHeight = self.normalInnerWidth = self.normalInnerMinWidth = self.normalInnerMinHeight = undefined;
            self._setOption("position", self._originalPosition);
        };
        WijDialog.prototype.close = function () {
            var self = this, o = self.options;
            if($.ui.dialog.prototype.close.apply(self, arguments)) {
                if(self.innerFrame) {
                    self.innerFrame.attr("src", "");
                    if(self.minimized) {
                        self.uiDialogTitlebar.hide();
                    }
                }
                if(self.disabledDiv && o.disabled) {
                    self.disabledDiv.hide();
                }
            }
        };
        WijDialog.prototype.open = function () {
            var self = this, o = self.options;
            if((o.hide === "drop" || o.hide === "bounce") && $.browser.msie) {
                //fixed bug when effect "drop" on IE
                self.uiDialog.css("filter", "auto");
            }
            if(!self.innerFrame) {
                if(!self.minimized) {
                    $.ui.dialog.prototype.open.apply(self, arguments);
                    //					if (!self.maximized) {
                    //						self._restoreToNormal();
                    //					}
                                    } else {
                    self.uiDialog.show();
                    self._isOpen = true;
                }
                self.uiDialog.wijTriggerVisibility();
            } else {
                self.innerFrame.attr("src", o.contentUrl);
                if(!self.minimized) {
                    $.ui.dialog.prototype.open.apply(self, arguments);
                } else {
                    self.uiDialogTitlebar.show();
                    self._isOpen = true;
                }
            }
            if(self.collapsed) {
                self._collapseDialogContent();
            }
            if(o.disabled) {
                if(self.disabledDiv) {
                    self.disabledDiv.show();
                } else {
                    self.disable();
                }
            }
        };
        WijDialog.prototype.close = function () {
            var self = this, o = self.options;
            if($.ui.dialog.prototype.close.apply(self, arguments)) {
                if(self.innerFrame) {
                    self.innerFrame.attr("src", "");
                    if(self.minimized) {
                        self.uiDialogTitlebar.hide();
                    }
                }
                if(self.disabledDiv && o.disabled) {
                    self.disabledDiv.hide();
                }
            }
        };
        WijDialog.prototype._restoreToNormal = function () {
            var self = this, dialog = self.uiDialog, ele = self.element;
            dialog.css("width", self.normalWidth);
            dialog.css("left", self.normalLeft);
            dialog.css("top", self.normalTop);
            dialog.css("height", self.normalHeight);
            ele.css("height", self.normalInnerHeight);
            ele.css("width", self.normalInnerWidth);
            ele.css("min-width", self.normalInnerMinWidth);
            ele.css("min-height", self.normalInnerMinHeight);
            self.options.width = self.uiDialog.width();
            self.options.height = self.uiDialog.height();
        };
        return WijDialog;
    })(wijmo.JQueryUIWidget);
    wijmo.WijDialog = WijDialog;    
    if($.ui && $.ui.dialog) {
        $.extend($.ui.dialog.overlay, {
            create: function (dialog) {
                if(this.instances.length === 0) {
                    // prevent use of anchors and inputs
                    // we use a setTimeout in case the overlay is created from an
                    // event that we're going to be cancelling (see #2804)
                    setTimeout(function () {
                        // handle $(el).dialog().dialog('close') (see #4065)
                        if($.ui.dialog.overlay.instances.length) {
                            $(document).bind($.ui.dialog.overlay.events, function (event) {
                                // stop events if the z-index of the target is < the z-index of the overlay
                                // we cannot return true when we don't want to cancel the event (#3523)
                                if($(event.target).zIndex() < $.ui.dialog.overlay.maxZ && !$.contains(dialog.element[0], event.target)) {
                                    return false;
                                }
                            });
                        }
                    }, 1);
                    // allow closing by pressing the escape key
                    $(document).bind('keydown.dialog-overlay', function (event) {
                        if(dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                            dialog.close(event);
                            event.preventDefault();
                        }
                    });
                    // handle window resize
                    $(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
                }
                var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay')).appendTo(document.body).css({
                    width: this.width(),
                    height: this.height()
                });
                if($.fn.bgiframe) {
                    $el.bgiframe();
                }
                this.instances.push($el);
                return $el;
            },
            height: function () {
                var scrollHeight, offsetHeight;
                // handle IE 6
                if($.browser.msie) {
                    scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
                    offsetHeight = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight);
                    if(scrollHeight < offsetHeight) {
                        return $(window).height() + 'px';
                    } else {
                        return scrollHeight + 'px';
                    }
                    // handle "good" browsers
                                    } else {
                    return $(document).height() + 'px';
                }
            },
            width: function () {
                var scrollWidth, offsetWidth;
                // handle IE 6
                if($.browser.msie) {
                    scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
                    offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);
                    if(scrollWidth < offsetWidth) {
                        return $(window).width() + 'px';
                    } else {
                        return scrollWidth + 'px';
                    }
                    // handle "good" browsers
                                    } else {
                    return $(document).width() + 'px';
                }
            }
        });
        WijDialog.prototype.options = $.extend(true, {
        }, $.ui.dialog.prototype.options, {
            captionButtons: /// <summary>
            /// An object determines the caption buttons to show on wijdialog title bar.
            /// Type: Object.
            /// Default: {}
            /// </summary>
            /// <remarks>
            /// The default value for this option is:
            /// {
            /// pin: {visible: true, click: self.pin,
            /// iconClassOn: "ui-icon-pin-w", iconClassOff:"ui-icon-pin-s"},
            /// refresh: {visible: true, click: self.refresh,
            /// iconClassOn: "ui-icon-refresh"},
            /// toggle: {visible: true, click: self.toggle},
            /// minimize: {visible: true, click: self.minimize,
            /// iconClassOn: "ui-icon-minus"},
            /// maximize: {visible: true, click: self.maximize,
            /// iconClassOn: "ui-icon-extlink"},
            /// close: {visible: true, click: self.close,
            /// iconClassOn: "ui-icon-close"}
            /// };
            /// Each button is represented by an object in this object.
            /// property name: The name of the button.
            /// visible: A value specifies whether this button is visible.
            /// click: The event handler to handle the click event of this button.
            /// iconClassOn: Icon for normal state.
            /// iconClassOff: Icon after clicking.
            /// </remarks>
            {
            },
            collapsingAnimation: /// <summary>
            /// A value determines the settings of the animation effect
            /// to be used when the wijdialog is collapsed.
            /// Type: Object.
            /// Default: null.
            /// </summary>
            null,
            expandingAnimation: /// <summary>
            /// A value determines the settings of the animation effect
            /// to be used when the wijdialog is expanded.
            /// Type: Object.
            /// Default: null.
            /// </summary>
            null,
            contentUrl: /// <summary>
            /// A URL string specifies the URL for the iframe element inside wijdialog.
            /// Type: String.
            /// Default: "".
            /// </summary>
            "",
            minimizeZoneElementId: /// <summary>
            /// A string specifies the ID of the DOM element to
            /// dock to when wijdialog is minimized.
            /// Type: String.
            /// Default: "".
            /// </summary>
            "",
            buttonCreating: /// <summary>
            /// Buttoncreating event handler.
            /// A function gets called before the caption buttons are created.
            /// A user could use this event to change the array of the buttons to
            /// change, add, or remove buttons from title bar.
            /// The buttoncreating event handler is a function that gets called
            /// before the caption buttons are created.
            /// Type: Function
            /// Default: null
            /// Code example:
            /// Supply a function as an option.
            /// $(".selector").wijdialog({ buttonCreating: function (e, data) { } });
            /// Bind to the event by type: wijdialogbuttoncreating
            /// $(".selector").bind("wijdialogbuttoncreating", function(e, data) { } );
            /// </summary>
            /// Parameters:
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// Buttons array that will be created.
            null,
            stateChanged: /// <summary>
            /// The stateChanged event handler.
            /// A function called when the state ("minimized", "maximized", "normal")
            /// of this dialog is changed.
            /// Default: null
            /// Type: Function
            /// Code example:
            /// Supply a function as an option.
            /// $(".selector").wijdialog({ stateChanged: function (e, data) { } });
            /// Bind to the event by type: wijdialogstatechanged
            /// $(".selector").bind("wijdialogstatechanged", function(e, data) { } );
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data relates to this event.
            /// data.originalState:The original state of the dialog
            /// data.state:The current state of the dialog
            /// </param>
            null,
            blur: /// <summary>
            /// The stateChanged event handler.
            /// A function called when the dialog lose focus.
            /// Default: null
            /// Type: Function
            /// Code example:
            /// Supply a function as an option.
            /// $(".selector").wijdialog({ blur: function (e, data) { } });
            /// Bind to the event by type: wijdialogstatechanged
            /// $(".selector").bind("wijdialogblur", function(e, data) { } );
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data relates to this event.
            /// data.el: The DOM element of this dialog.
            /// </param>
            null,
            initSelector: ""
        });
        $.wijmo.registerWidget(widgetName, $.ui.dialog, WijDialog.prototype);
    }
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery,$,window,alert,document,confirm,location,setTimeout, Globalize,
amplify*/
/*jslint white: false */
/*jslint nomen: false*/
/*jslint browser: true*/
/*jslint continue: true*/
/*jslint devel: true*/
/*jslint forin: true*/
/*jslint maxlen: 110*/
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.widget.js
*  jquery.wijmo.wijutil.js
*  jquery.wijmo.wijaccordion.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijaccordion";
    var wijaccordion = (function (_super) {
        __extends(wijaccordion, _super);
        function wijaccordion() {
            _super.apply(this, arguments);

            this.widgetEventPrefix = "wijaccordion";
        }
        wijaccordion.prototype._setOption = function (key, value) {
            var o = this.options;
            if(o[key] !== value) {
                switch(key) {
                    case "selectedIndex":
                        this.activate(value);
                        break;
                    case "disabled":
                        if(value) {
                            this.element.addClass(o.wijCSS.stateDisabled);
                        } else {
                            this.element.removeClass(o.wijCSS.stateDisabled);
                        }
                        break;
                    case "event":
                        this._unbindLiveEvents();
                        this.options.event = value;
                        this._bindLiveEvents();
                        break;
                    case "header":
                        this._handleHeaderChange(value, o.header);
                        break;
                    case "animated":
                        break;
                    case "expandDirection":
                        this._onDirectionChange(value, true, o.expandDirection);
                        break;
                    default:
                        break;
                }
            }
            $.wijmo.widget.prototype._setOption.apply(this, arguments);
        };
        wijaccordion.prototype._handleHeaderChange = function (newHeaderSelector, prevHeaderSelector) {
            var prevHeaders = this.element.find(prevHeaderSelector);
            prevHeaders.removeClass("wijmo-wijaccordion-header ui-helper-reset " + this.options.wijCSS.stateActive + " " + this._triangleIconOpened).siblings(".wijmo-wijaccordion-content").removeClass("wijmo-wijaccordion-content ui-helper-reset " + this.options.wijCSS.content + " wijmo-wijaccordion-content-active");
            this._initHeaders(newHeaderSelector);
        };
        wijaccordion.prototype._initHeaders = function (selector) {
            if (typeof selector === "undefined") { selector = null; }
            var o = this.options, selector = selector ? selector : o.header, headers = this.element.find(selector);
            headers.each(jQuery.proxy(this._initHeader, this));
        };
        wijaccordion.prototype._initHeader = function (index, elem) {
            var o = this.options, rightToLeft = this.element.data("rightToLeft"), header = $(elem), content = $(header.next()[0]);
            if(rightToLeft) {
                header.remove();
                header.insertAfter(content);
            }
            header.addClass("wijmo-wijaccordion-header ui-helper-reset").attr("role", "tab");
            content.attr("role", "tabpanel");
            if(header.find("> a").length === 0) {
                header.wrapInner('<a href="#"></a>');
            }
            if(header.find("> .ui-icon").length === 0) {
                $('<span class="ui-icon"></span>').insertBefore($("> a", header)[0]);
            }
            if(index === o.selectedIndex) {
                header.addClass(this.options.wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                    "aria-expanded": "true",
                    tabIndex: 0
                }).find("> .ui-icon").addClass(this._triangleIconOpened);
                content.addClass("wijmo-wijaccordion-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
            } else {
                header.addClass(o.wijCSS.stateDefault + " ui-corner-all").attr({
                    "aria-expanded": "false",
                    tabIndex: -1
                }).find("> .ui-icon").addClass(this._triangleIconClosed);
                content.hide();
            }
            content.addClass("wijmo-wijaccordion-content ui-helper-reset " + this.options.wijCSS.content);
        };
        wijaccordion.prototype._create = function () {
            var o = this.options;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            this.element.addClass("wijmo-wijaccordion " + o.wijCSS.widget + " wijmo-wijaccordion-icons " + "ui-helper-reset ui-helper-clearfix");
            if(o.disabled) {
                this.element.addClass(o.wijCSS.stateDisabled);
            }
            this._onDirectionChange(o.expandDirection, false);
            this._initHeaders();
            this.element.attr("role", "tablist");
            //super._create(this, arguments);
            $.wijmo.widget.prototype._create.apply(this, arguments);
        };
        wijaccordion.prototype._init = function () {
            this._bindLiveEvents();
        };
        wijaccordion.prototype.destroy = function () {
            var o = this.options;
            this._unbindLiveEvents();
            this.element.removeClass("wijmo-wijaccordion " + o.wijCSS.widget + " ui-helper-reset wijmo-wijaccordion-icons").removeAttr("role");
            $.wijmo.widget.prototype.destroy.apply(this, arguments);
        };
        wijaccordion.prototype._getHeaders = function () {
            var o = this.options, rightToLeft = this.element.data("rightToLeft"), headersArr = [], i, hdr;
            var headers = this.element.find(o.header);
            if(headers.length > 0 && !$(headers[0]).hasClass("wijmo-wijaccordion-header") && $(headers[0]).hasClass("wijmo-wijaccordion-content")) {
                for(i = 0; i < headers.length; i += 1) {
                    // fix for 29695:
                    hdr = rightToLeft ? $(headers[i]).next(".wijmo-wijaccordion-header") : $(headers[i]).prev(".wijmo-wijaccordion-header");
                    if(hdr.length > 0) {
                        headersArr.push(hdr[0]);
                    }
                }
            } else {
                return headers;
            }
            return $(headersArr);
        };
        wijaccordion.prototype.activate = /// <summary>
        /// Activates the accordion content pane by its index.
        /// </summary>
        /// <param name="index" type="Number">
        ///	Index of the accordion pane to be activated.
        ///	</param>
        function (index) {
            var nextHeader, o = this.options, headers = this._getHeaders(), prevHeader, rightToLeft = this.element.data("rightToLeft"), newIndex, prevIndex, nextContent, prevContent, animOptions, proxied, proxiedDuration, animations, duration, easing;
            prevHeader = $(jQuery.grep(headers, function (a) {
                return $(a).hasClass(o.wijCSS.stateActive);
            }));
            if(typeof index === "number") {
                nextHeader = $(headers[index]);
            } else if(typeof index === "string") {
                index = parseInt(index, 0);
                nextHeader = $(headers[index]);
            } else {
                nextHeader = $(index);
                index = headers.index(index);
            }
            if(nextHeader.hasClass(o.wijCSS.stateDisabled)) {
                return false;
            }
            if(nextHeader.hasClass(o.wijCSS.stateActive)) {
                if(o.requireOpenedPane) {
                    // fix for
                    // [17869] Unable to select the desire panel
                    // after all the panels are open in certain scenarios
                    if(prevHeader.length === nextHeader.length && prevHeader.index() === nextHeader.index()) {
                        return false;
                    }
                } else {
                    prevHeader = nextHeader;
                    nextHeader = $(null);
                }
            } else if(!o.requireOpenedPane) {
                prevHeader = $(null);
            }
            // 29193 (fix for nested accordions):
            newIndex = headers.index(nextHeader);
            prevIndex = headers.index(prevHeader);
            nextContent = rightToLeft ? nextHeader.prev(".wijmo-wijaccordion-content") : nextHeader.next(".wijmo-wijaccordion-content");
            prevContent = rightToLeft ? prevHeader.prev(".wijmo-wijaccordion-content") : prevHeader.next(".wijmo-wijaccordion-content");
            if(prevHeader.length === 0 && nextHeader.length === 0) {
                return false;
            }
            if(!this._trigger("beforeSelectedIndexChanged", null, {
                newIndex: newIndex,
                prevIndex: prevIndex
            })) {
                return false;
            }
            prevHeader.removeClass(o.wijCSS.stateActive).removeClass(this._headerCornerOpened).addClass(o.wijCSS.stateDefault + " ui-corner-all").attr({
                "aria-expanded": "false",
                tabIndex: -1
            }).find("> .ui-icon").removeClass(this._triangleIconOpened).addClass(this._triangleIconClosed);
            nextHeader.removeClass(o.wijCSS.stateDefault + " ui-corner-all").addClass(o.wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                "aria-expanded": "true",
                tabIndex: 0
            }).find("> .ui-icon").removeClass(this._triangleIconClosed).addClass(this._triangleIconOpened);
            if(o.animated) {
                animOptions = {
                    toShow: nextContent,
                    toHide: prevContent,
                    complete: jQuery.proxy(function () {
                        prevContent.removeClass("wijmo-wijaccordion-content-active");
                        nextContent.addClass("wijmo-wijaccordion-content-active").wijTriggerVisibility();
                        prevContent.css('display', '');
                        nextContent.css('display', '');
                        if($.fn.wijlinechart) {
                            prevContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                            ;
                            nextContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                            ;
                        }
                        //prevContent.wijTriggerVisibility();
                        //nextContent.wijTriggerVisibility();
                        this._trigger("selectedIndexChanged", null, {
                            newIndex: newIndex,
                            prevIndex: prevIndex
                        });
                    }, this),
                    horizontal: this.element.hasClass("ui-helper-horizontal"),
                    rightToLeft: this.element.data("rightToLeft"),
                    down: (newIndex > prevIndex),
                    autoHeight: o.autoHeight || o.fillSpace
                };
                proxied = o.animated;
                proxiedDuration = o.duration;
                if($.isFunction(proxied)) {
                    o.animated = proxied(animOptions);
                }
                if($.isFunction(proxiedDuration)) {
                    o.duration = proxiedDuration(animOptions);
                }
                animations = $.wijmo.wijaccordion.animations;
                duration = o.duration;
                easing = o.animated;
                if(easing && !animations[easing] && !$.easing[easing]) {
                    easing = 'slide';
                }
                if(!animations[easing]) {
                    animations[easing] = function (options) {
                        this.slide(options, {
                            easing: easing,
                            duration: duration || 700
                        });
                    };
                }
                animations[easing](animOptions);
            } else {
                if(prevHeader.length > 0) {
                    prevContent.hide().removeClass("wijmo-wijaccordion-content-active");
                }
                if(nextHeader.length > 0) {
                    nextContent.show().addClass("wijmo-wijaccordion-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
                }
                if($.fn.wijlinechart) {
                    prevContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                    ;
                    nextContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                    ;
                }
                //prevContent.wijTriggerVisibility();
                //nextContent.wijTriggerVisibility();
                this._trigger("selectedIndexChanged", null, {
                    newIndex: newIndex,
                    prevIndex: prevIndex
                });
            }
            this.options.selectedIndex = newIndex;
        };
        wijaccordion.prototype._bindLiveEvents = /** Private methods */
        function () {
            var self = this;
            this.element.on(this.options.event + ".wijaccordion", ".wijmo-wijaccordion-header", jQuery.proxy(this._onHeaderClick, this)).on("keydown.wijaccordion", ".wijmo-wijaccordion-header", jQuery.proxy(this._onHeaderKeyDown, this)).on("mouseenter.wijaccordion", ".wijmo-wijaccordion-header", function () {
                $(this).addClass('ui-state-hover');
            }).on("mouseleave.wijaccordion", ".wijmo-wijaccordion-header", function () {
                $(this).removeClass('ui-state-hover');
            }).on("focus.wijaccordion", ".wijmo-wijaccordion-header", function () {
                $(this).addClass(self.options.wijCSS.stateFocus);
            }).on("blur.wijaccordion", ".wijmo-wijaccordion-header", function () {
                $(this).removeClass(self.options.wijCSS.stateFocus);
            });
        };
        wijaccordion.prototype._unbindLiveEvents = function () {
            this.element.off(".wijaccordion", ".wijmo-wijaccordion-header");
        };
        wijaccordion.prototype._onHeaderClick = function (e) {
            if(!this.options.disabled) {
                this.activate(e.currentTarget);
            }
            return false;
        };
        wijaccordion.prototype._onHeaderKeyDown = function (e) {
            if(this.options.disabled || e.altKey || e.ctrlKey) {
                return;
            }
            if(!$.ui) {
                return;
            }
            var keyCode = $.ui.keyCode, focusedHeader = this.element.find(".wijmo-wijaccordion-header." + this.options.wijCSS.stateFocus), focusedInd, headers = this._getHeaders();
            if(focusedHeader.length > 0) {
                focusedInd = $(".wijmo-wijaccordion-header", this.element).index(focusedHeader);
                switch(e.keyCode) {
                    case keyCode.RIGHT:
                    case keyCode.DOWN:
                        if(headers[focusedInd + 1]) {
                            headers[focusedInd + 1].focus();
                            return false;
                        }
                        break;
                    case keyCode.LEFT:
                    case keyCode.UP:
                        if(headers[focusedInd - 1]) {
                            headers[focusedInd - 1].focus();
                            return false;
                        }
                        break;
                    case keyCode.SPACE:
                    case keyCode.ENTER:
                        this.activate(e.currentTarget);
                        e.preventDefault();
                        break;
                }
            }
            return true;
        };
        wijaccordion.prototype._onDirectionChange = function (newDirection, allowDOMChange, prevDirection) {
            if (typeof prevDirection === "undefined") { prevDirection = null; }
            var rightToLeft, openedHeaders, openedContents, openedTriangles, closedTriangles, prevIsRightToLeft;
            var o = this.options;
            if(allowDOMChange) {
                openedHeaders = this.element.find(".wijmo-wijaccordion-header." + this._headerCornerOpened);
                openedHeaders.removeClass(this._headerCornerOpened);
                openedContents = this.element.find(".wijmo-wijaccordion-content." + this._contentCornerOpened);
                openedContents.removeClass(this._contentCornerOpened);
                openedTriangles = this.element.find("." + this._triangleIconOpened);
                closedTriangles = this.element.find("." + this._triangleIconClosed);
                openedTriangles.removeClass(this._triangleIconOpened);
                closedTriangles.removeClass(this._triangleIconClosed);
            }
            if(prevDirection !== null) {
                this.element.removeClass("wijmo-wijaccordion-" + prevDirection);
            }
            switch(newDirection) {
                case "top":
                    this._headerCornerOpened = "ui-corner-bottom";
                    this._contentCornerOpened = "ui-corner-top";
                    this._triangleIconOpened = o.wijCSS.iconArrowUp;
                    this._triangleIconClosed = o.wijCSS.iconArrowRight;
                    rightToLeft = true;
                    this.element.removeClass("ui-helper-horizontal");
                    this.element.addClass("wijmo-wijaccordion-top");
                    break;
                case "right":
                    this._headerCornerOpened = "ui-corner-left";
                    this._contentCornerOpened = "ui-corner-right";
                    this._triangleIconOpened = o.wijCSS.iconArrowRight;
                    this._triangleIconClosed = o.wijCSS.iconArrowDown;
                    rightToLeft = false;
                    this.element.addClass("ui-helper-horizontal");
                    this.element.addClass("wijmo-wijaccordion-right");
                    break;
                case "left":
                    this._headerCornerOpened = "ui-corner-right";
                    this._contentCornerOpened = "ui-corner-left";
                    this._triangleIconOpened = o.wijCSS.iconArrowLeft;
                    this._triangleIconClosed = o.wijCSS.iconArrowDown;
                    rightToLeft = true;
                    this.element.addClass("ui-helper-horizontal");
                    this.element.addClass("wijmo-wijaccordion-left");
                    break;
                default:
                    //bottom
                    this._headerCornerOpened = "ui-corner-top";
                    this._contentCornerOpened = "ui-corner-bottom";
                    this._triangleIconOpened = o.wijCSS.iconArrowDown;
                    this._triangleIconClosed = o.wijCSS.iconArrowRight;
                    rightToLeft = false;
                    this.element.removeClass("ui-helper-horizontal");
                    this.element.addClass("wijmo-wijaccordion-bottom");
                    break;
            }
            prevIsRightToLeft = this.element.data("rightToLeft");
            this.element.data("rightToLeft", rightToLeft);
            if(allowDOMChange) {
                openedTriangles.addClass(this._triangleIconOpened);
                closedTriangles.addClass(this._triangleIconClosed);
                openedHeaders.addClass(this._headerCornerOpened);
                openedContents.addClass(this._contentCornerOpened);
            }
            if(allowDOMChange && rightToLeft !== prevIsRightToLeft) {
                this.element.children(".wijmo-wijaccordion-header").each(function (index, elem) {
                    var header = $(this), content;
                    if(rightToLeft) {
                        content = header.next(".wijmo-wijaccordion-content");
                        header.remove();
                        header.insertAfter(content);
                    } else {
                        content = header.prev(".wijmo-wijaccordion-content");
                        header.remove();
                        header.insertBefore(content);
                    }
                });
            }
        };
        return wijaccordion;
    })(wijmo.wijmoWidget);
    wijmo.wijaccordion = wijaccordion;    
    ;
    wijaccordion.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body ui-body-c"
        },
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijaccordion')",
        animated: /// <summary>
        /// Sets the animation easing effect. Set this option to false in order to
        ///	disable animation. Easing effects require UI Effects Core.
        /// Options available for the animation function include:
        ///  down Ð²Ð‚â€œ If true, indicates that the index of the pane should be expanded
        ///			higher than the index of the pane that must be collapsed.
        ///  horizontal Ð²Ð‚â€œ If true, indicates that the accordion have a horizontal
        ///			orientation (when the expandDirection is left or right).
        ///  rightToLeft Ð²Ð‚â€œ If true, indicates that the content element is located
        ///			before the header element (top and left expand direction).
        ///  toShow Ð²Ð‚â€œ jQuery object that contains the content element(s) should be
        ///			shown.
        ///  toHide Ð²Ð‚â€œjQuery object that contains the content element(s) should be
        ///			hidden.
        /// Type: String
        /// Default: "slide"
        /// Code example:
        /// Create your own animation:
        /// jQuery.wijmo.wijaccordion.animations.custom1 = function (options) {
        ///     this.slide(options, {
        ///     easing: options.down ? "easeOutBounce" : "swing",
        ///     duration: options.down ? 1000 : 200
        ///   });
        /// }
        ///  $("#accordion3").wijaccordion({
        ///      expandDirection: "right",
        ///      animated: "custom1"
        ///  });
        /// </summary>
        'slide',
        duration: /// <summary>
        /// The animation duration in milliseconds. By default animation duration
        ///	value depends on an animation effect specified by the animation option.
        /// Type: Number
        /// Default: null
        /// Code example:
        ///  $("#accordion3").wijaccordion({
        ///      duration: 1000
        ///  });
        /// </summary>
        null,
        event: /// <summary>
        /// Determines the event that triggers the accordion.
        /// Type: String
        /// Default: "click"
        /// Code example:
        ///  $("#accordion3").wijaccordion({
        ///      event: "mouseover"
        ///  });
        /// </summary>
        "click",
        disabled: /// <summary>
        /// Determines whether the widget behavior is disabled.
        /// Type: Boolean
        /// Default: false
        /// Code example:
        ///   $(".selector").wijaccordion({ disabled: true });
        /// </summary>
        false,
        expandDirection: /// <summary>
        /// Determines the direction in which the content area expands. Available
        ///	values include: top, right, bottom, and left.
        /// Type: String
        /// Default: "bottom"
        /// Code example:
        ///    $("#element").wijaccordion({ expandDirection: "right" });
        /// </summary>
        "bottom",
        header: /// <summary>
        /// Selector for the header element. By using this option you can put
        ///	header/content elements inside LI tags or into any other more complex
        ///	html markup.
        /// Type: String
        /// Default: "> li > :first-child,> :not(li):even"
        /// Code example: $("#element").wijaccordion({ header: "h3" });
        /// </summary>
        "> li > :first-child,> :not(li):even",
        requireOpenedPane: /// <summary>
        /// Determines whether clicking the header will close the currently opened
        ///	pane (leaving all the accordion's panes closed).
        /// Type: Boolean
        /// Default: true
        /// Code example:
        ///    $("#element").wijaccordion({ requireOpenedPane: false });
        /// </summary>
        true,
        selectedIndex: /// <summary>
        /// Gets or sets the index of the currently expanded accordion pane.
        /// Type: Number
        /// Default: 0
        /// Code example:
        ///   $("#element").wijaccordion({ selectedIndex: 5 });
        /// </summary>
        0
    });
    /*
    Available Events:
    /// <summary>
    /// Occurs before an active accordion pane change.
    /// Return false or call event.preventDefault() in order to cancel event and
    ///	prevent the selectedIndex change.
    /// Type: Function
    /// Event type: wijaccordionbeforeselectedindexchanged
    /// Code example:
    /// Supply a callback function to handle the beforeSelectedIndexChanged
    ///	event as an option.
    /// $("#accordion").wijaccordion({
    ///		beforeSelectedIndexChanged: function (e, args) {
    ///			alert(args.prevIndex + "->" + args.newIndex);
    ///         ...
    /// }});
    /// Bind to the event by type: wijaccordionbeforeselectedindexchanged.
    /// $( "#accordion" ).bind( "wijaccordionbeforeselectedindexchanged", function(e, args) {
    ///			alert(args.prevIndex + "->" + args.newIndex);
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    /// <param name="args" type="Object">
    /// Event arguments:
    ///	args.newIndex - Index of a pane that will be expanded.
    ///	args.prevIndex - Index of a pane that will be collapsed.
    ///	</param>
    beforeSelectedIndexChanged(e, args)
    
    /// <summary>
    /// Occurs when an active accordion pane changed.
    /// Type: Function
    /// Event type: wijaccordionselectedindexchanged
    /// Code example:
    /// Supply a callback function to handle the selectedIndexChanged
    ///	event as an option.
    /// $("#accordion").wijaccordion({
    ///		selectedIndexChanged: function (e, args) {
    ///			alert(args.prevIndex + "->" + args.newIndex);
    ///         ...
    /// }});
    /// Bind to the event by type: wijaccordionselectedindexchanged.
    /// $( "#accordion" ).bind( "wijaccordionselectedindexchanged", function(e, args) {
    ///			alert(args.prevIndex + "->" + args.newIndex);
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    /// <param name="args" type="Object">
    /// Event arguments:
    ///	args.newIndex - Index of the activated pane.
    /// args.prevIndex - Index of the collapsed pane.
    ///	</param>
    selectedIndexChanged(e, args)
    
    */
    $.wijmo.registerWidget(widgetName, wijaccordion.prototype);
    $.extend($.wijmo.wijaccordion, {
        animations: {
            slide: function (options, additions) {
                options = $.extend({
                    easing: "swing",
                    duration: 300
                }, options, additions);
                var simpleShowOpts, simpleHideOpts;
                if(options.horizontal) {
                    simpleShowOpts = {
                        width: "show"
                    };
                    simpleHideOpts = {
                        width: "hide"
                    };
                } else {
                    simpleShowOpts = {
                        height: "show"
                    };
                    simpleHideOpts = {
                        height: "hide"
                    };
                }
                if(!options.toHide.size()) {
                    options.toShow.stop(true, true).animate(simpleShowOpts, options);
                    return;
                }
                if(!options.toShow.size()) {
                    options.toHide.stop(true, true).animate(simpleHideOpts, options);
                    return;
                }
                var overflow = options.toShow.css('overflow'), percentDone = 0, showProps = {
                }, hideProps = {
                }, toShowCssProps, fxAttrs = options.horizontal ? [
                    "width", 
                    "paddingLeft", 
                    "paddingRight"
                ] : [
                    "height", 
                    "paddingTop", 
                    "paddingBottom"
                ], originalWidth, s = options.toShow;
                // fix width/height before calculating height/width of hidden element
                if(options.horizontal) {
                    originalWidth = s[0].style.height;
                    s.height(parseInt(s.parent().height(), 10) - parseInt(s.css("paddingTop"), 10) - parseInt(s.css("paddingBottom"), 10) - (parseInt(s.css("borderTopWidth"), 10) || 0) - (parseInt(s.css("borderBottomWidth"), 10) || 0));
                } else {
                    originalWidth = s[0].style.width;
                    s.width(parseInt(s.parent().width(), 10) - parseInt(s.css("paddingLeft"), 10) - parseInt(s.css("paddingRight"), 10) - (parseInt(s.css("borderLeftWidth"), 10) || 0) - (parseInt(s.css("borderRightWidth"), 10) || 0));
                }
                $.each(fxAttrs, function (i, prop) {
                    hideProps[prop] = "hide";
                    var parts = ('' + $.css(options.toShow[0], prop)).match(/^([\d+-.]+)(.*)$/);
                    showProps[prop] = {
                        value: parts ? parts[1] : "0",
                        unit: parts ? (parts[2] || "px") : "px"
                    };
                });
                if(options.horizontal) {
                    toShowCssProps = {
                        width: 0,
                        overflow: "hidden"
                    };
                } else {
                    toShowCssProps = {
                        height: 0,
                        overflow: "hidden"
                    };
                }
                options.toShow.css(toShowCssProps).stop(true, true).show();
                options.toHide.filter(":hidden").each(options.complete).end().filter(":visible").stop(true, true).animate(hideProps, {
                    step: function (now, settings) {
                        var val;
                        if(settings.prop === options.horizontal ? "width" : "height") {
                            percentDone = (settings.end - settings.start === 0) ? 0 : (settings.now - settings.start) / (settings.end - settings.start);
                        }
                        val = (percentDone * showProps[settings.prop].value);
                        if(val < 0) {
                            //fix for 16943:
                            val = 0;
                        }
                        options.toShow[0].style[settings.prop] = val + showProps[settings.prop].unit;
                    },
                    duration: options.duration,
                    easing: options.easing,
                    complete: function () {
                        if(!options.autoHeight) {
                            options.toShow.css(options.horizontal ? "width" : "height", "");
                        }
                        options.toShow.css(options.horizontal ? "height" : "width", originalWidth);
                        options.toShow.css({
                            overflow: overflow
                        });
                        options.complete();
                    }
                });
            },
            bounceslide: function (options) {
                this.slide(options, {
                    easing: options.down ? "easeOutBounce" : "swing",
                    duration: options.down ? 1000 : 200
                });
            }
        }
    });
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.widget.js
*  jquery.ui.position.js
*
*/
$.fn.extend({
    getBounds: function () {
        return $.extend({
        }, $(this).offset(), {
            width: $(this).outerWidth(true),
            height: $(this).outerHeight(true)
        });
    },
    setBounds: function (bounds) {
        $(this).css({
            'left': bounds.left,
            'top': bounds.top
        }).width(bounds.width).height(bounds.height);
        return this;
    },
    getMaxZIndex: function () {
        var max = (($(this).css('z-index') == 'auto') ? 0 : $(this).css('z-index')) * 1;
        $(this).siblings().each(function (i, e) {
            max = Math.max(max, (($(e).css('z-index') == 'auto') ? 0 : $(e).css('z-index')) * 1);
        });
        return max;
    }
});
var wijmo;
(function (wijmo) {
    var WijPopUp = (function (_super) {
        __extends(WijPopUp, _super);
        function WijPopUp() {
            _super.apply(this, arguments);

        }
        WijPopUp.prototype._init = function () {
            if(!!this.options.ensureOutermost) {
                var root = $('form');
                if(root.length === 0) {
                    root = $(document.body);
                }
                this.element.appendTo(root);
            }
            this.element.data('visible.wijpopup', false);
            this.element.css('position', "absolute");
            this.element.position({
                of: $(document.body)
            });
            this.element.hide();
        };
        WijPopUp.prototype._setOption = function (key, value) {
            _super.prototype._setOption.call(this, key, value);
            if(key === 'autoHide') {
                var visible = this.isVisible();
                this.hide();
                if(visible) {
                    this.show();
                }
            }
        };
        WijPopUp.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            if(this.isVisible()) {
                this.hide();
            }
            if($.browser.msie && (parseInt($.browser.version) < 7)) {
                var jFrame = this.element.data('backframe.wijpopup');
                if(!jFrame) {
                    jFrame.remove();
                }
            }
            var self = this;
            this.element.unbind('.wijpopup');
            $.each([
                "visible", 
                "backframe", 
                "animating", 
                "width"
            ], function (i, prefix) {
                self.element.removeData(prefix + ".wijpopup");
            });
        };
        WijPopUp.prototype.isVisible = function () {
            /// <summary>Determines whether the element is visible.</summary>
            return (!!this.element.data('visible.wijpopup') && this.element.is(':visible'));
        };
        WijPopUp.prototype.isAnimating = function () {
            return !!this.element.data("animating.wijpopup");
        };
        WijPopUp.prototype.show = function (position) {
            /// <summary>Popups the element.  Position is an optional argument, it is the options object used in jquery.ui.position.</summary>
            this._setPosition(position);
            if(this.isVisible()) {
                return;
            }
            if(this._trigger('showing') === false) {
                return;
            }
            if(this.options.autoHide) {
                window.setTimeout(function () {
                    $(document.body).bind('mouseup.wijpopup', $.proxy(this._onDocMouseUp, this));
                }, 0);
            }
            var effect = this.options.showEffect || "show";
            var duration = this.options.showDuration || 300;
            var ops = this.options.showOptions || {
            };
            this.element.data("animating.wijpopup", true);
            if($.effects && $.effects.effect[effect]) {
                this.element.show(effect, ops, duration, $.proxy(this._showCompleted, this));
            } else {
                this.element[effect]((effect === 'show' ? null : duration), $.proxy(this._showCompleted, this));
            }
            if(!effect || !duration || effect === 'show' || duration <= 0) {
                this._showCompleted();
            }
        };
        WijPopUp.prototype._showCompleted = function () {
            this.element.removeData("animating.wijpopup");
            this.element.data('visible.wijpopup', true);
            this._trigger('shown');
        };
        WijPopUp.prototype.showAt = function (x, y) {
            /// <summary>Popups the element at specified absolute position related to document.</summary>
            this.show({
                my: //jquery 1.10: offset has removed
                //my: 'left top',
                'left+' + x + ' top+' + y,
                at: 'left top',
                of: document.body
            });
            //,
            //jquery 1.10: offset has removed
            //offset: '' + x + ' ' + y
                    };
        WijPopUp.prototype.hide = function () {
            /// <summary>Hides the element.</summary>
            if(!this.isVisible()) {
                return;
            }
            if(this._trigger('hiding') === false) {
                return;
            }
            $(document.body).unbind('mouseup.wijpopup');
            var effect = this.options.hideEffect || "hide";
            var duration = this.options.hideDuration || 300;
            var ops = this.options.hideOptions || {
            };
            this.element.data("animating.wijpopup", true);
            if($.effects && $.effects.effect[effect]) {
                this.element.hide(effect, ops, duration, $.proxy(this._hideCompleted, this));
            } else {
                this.element[effect]((effect === 'hide' ? null : duration), $.proxy(this._hideCompleted, this));
            }
            if(!effect || !duration || effect === 'hide' || duration <= 0) {
                this._hideCompleted();
            }
        };
        WijPopUp.prototype._hideCompleted = function () {
            if(this.element.data('width.wijpopup') !== undefined) {
                this.element.width(this.element.data('width.wijpopup'));
                this.element.removeData('width.wijpopup');
            }
            this.element.unbind('move.wijpopup');
            this.element.removeData("animating.wijpopup");
            if($.browser.msie && (parseInt($.browser.version) < 7)) {
                var jFrame = this.element.data('backframe.wijpopup');
                if(jFrame) {
                    jFrame.hide();
                }
            }
            this._trigger('hidden');
        };
        WijPopUp.prototype._onDocMouseUp = function (e) {
            var srcElement = e.target ? e.target : e.srcElement;
            if(this.isVisible() && !!this.options.autoHide) {
                if(srcElement != this.element.get(0) && $(srcElement).parents().index(this.element) < 0) {
                    this.hide();
                }
            }
        };
        WijPopUp.prototype._onMove = function (e) {
            var jFrame = this.element.data('backframe.wijpopup');
            if(jFrame) {
                this.element.before(jFrame);
                jFrame.css({
                    'top': this.element.css('top'),
                    'left': this.element.css('left')
                });
            }
        };
        WijPopUp.prototype._addBackgroundIFrame = function () {
            if($.browser.msie && (parseInt($.browser.version) < 7)) {
                var jFrame = this.element.data('backframe.wijpopup');
                if(!jFrame) {
                    jFrame = jQuery('<iframe/>').css({
                        'position': 'absolute',
                        'display': 'none',
                        'filter': 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                    }).attr({
                        'src': 'javascript:\'<html></html>\';',
                        'scrolling': 'no',
                        'frameborder': '0',
                        'tabIndex ': -1
                    });
                    this.element.before(jFrame);
                    this.element.data('backframe.wijpopup', jFrame);
                    this.element.bind('move.wijpopup', $.proxy(this._onMove, this));
                }
                jFrame.setBounds(this.element.getBounds());
                jFrame.css({
                    'display': 'block',
                    'left': this.element.css('left'),
                    'top': this.element.css('top'),
                    'z-index': this.element.css('z-index') - 1
                });
            }
        };
        WijPopUp.prototype._setZIndex = function (index) {
            this.element.css('z-index', index);
            var jFrame = this.element.data('backframe.wijpopup');
            if(jFrame) {
                jFrame.css('z-index', (this.element.css('z-index')) - 1);
            }
        };
        WijPopUp.prototype._setPosition = function (position) {
            var visible = this.element.is(':visible');
            this.element.show();
            this.element.position($.extend({
            }, this.options.position, position ? position : {
            }));
            if(!visible) {
                this.element.hide();
            }
            this._addBackgroundIFrame();
            var zIndex = 1000;
            if(this.options.position.of) {
                zIndex = Math.max(zIndex, $(this.options.position.of).getMaxZIndex());
            }
            this._setZIndex(zIndex + 10);
            this._trigger('posChanged');
        };
        return WijPopUp;
    })(wijmo.JQueryUIWidget);
    wijmo.WijPopUp = WijPopUp;    
    WijPopUp.prototype.options = $.extend(true, {
    }, wijmo.JQueryUIWidget.prototype.options, {
        ensureOutermost: ///	<summary>
        ///     Determines if the element's parent element is the outermost element.
        ///		If true, the element's parent element will be changed to the body or outermost form element.
        ///	</summary>
        false,
        showEffect: ///	<summary>
        ///     Specifies the effect to be used when the popup is shown.
        ///		Possible values: 'blind', 'clip', 'drop', 'fade', 'fold', 'slide', 'pulsate'.
        ///	</summary>
        'show',
        showOptions: ///	<summary>
        ///     Specified the object/hash including specific options for the show effect.
        ///	</summary>
        {
        },
        showDuration: ///	<summary>
        ///     Defines how long (in milliseconds) the animation duration for showing the popup will last.
        ///	</summary>
        300,
        hideEffect: ///	<summary>
        ///     Specifies the effect to be used when the popup is hidden.
        ///		Possible values: 'blind', 'clip', 'drop', 'fade', 'fold', 'slide', 'pulsate'.
        ///	</summary>
        'hide',
        hideOptions: ///	<summary>
        ///     Specified the object/hash including specific options for the hide effect.
        ///	</summary>
        {
        },
        hideDuration: ///	<summary>
        ///     Defines how long (in milliseconds) the animation duration for hiding the popup will last.
        ///	</summary>
        100,
        autoHide: ///	<summary>
        ///     Determines whether to automatically hide the popup when clicking outside the element.
        ///	</summary>
        false,
        position: ///	<summary>
        ///     Options for positioning the element, please see jquery.ui.position for possible options.
        ///	</summary>
        {
            at: 'left bottom',
            my: 'left top'
        },
        showing: /// <summary>
        /// The showing event handler. A function called before the element is shown. Cancellable.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijpopup({ showing: function (e, args) { } });
        /// </summary>
        null,
        shown: /// <summary>
        /// The shown event handler. A function called after the element is shown.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijpopup({ shown: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        hiding: /// <summary>
        /// The hiding event handler. A function called before the element is hidden. Cancellable.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijpopup({ hiding: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        hidden: /// <summary>
        /// The hidden event handler. A function called after the element is hidden.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijpopup({ hidden: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        posChanged: /// <summary>
        /// The posChanged event handler. A function called when the position of the element is changed.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijpopup({ posChanged: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null
    });
    $.wijmo.registerWidget("wijpopup", WijPopUp.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*globals window,document,jQuery*/
/*
* Depends:
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jquery.ui.resizable.js
*	jquery.ui.mouse.js
*	jquery.wijmo.wijutil.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery;
    var wijsuperpanel = (function (_super) {
        __extends(wijsuperpanel, _super);
        function wijsuperpanel() {
            _super.apply(this, arguments);

        }
        return wijsuperpanel;
    })(wijmo.wijmoWidget);
    wijmo.wijsuperpanel = wijsuperpanel;    
    if(!$.support.isTouchEnabled || !$.support.isTouchEnabled()) {
        var scrollerHandle = "wijmo-wijsuperpanel-handle", hbarContainerCSS = "wijmo-wijsuperpanel-hbarcontainer", vbarContainerCSS = "wijmo-wijsuperpanel-vbarcontainer", activeCss = "", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer'>" + "<div class='wijmo-wijsuperpanel-contentwrapper'>" + "<div class='wijmo-wijsuperpanel-templateouterwrapper'></div>" + "</div>" + "</div>", hbarHtml = "<div class='wijmo-wijsuperpanel-hbarcontainer {header}'>" + "<div class='wijmo-wijsuperpanel-handle {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconVGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonleft {stateDefault} {cornerBL}'>" + "<span class='{icon} {iconArrowLeft}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonright {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowRight}'></span></div>" + "</div>", vbarHtml = "<div class='wijmo-wijsuperpanel-vbarcontainer {header}'>" + "<div class='wijmo-wijsuperpanel-handle {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconHGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttontop {stateDefault} {cornerTR}'>" + "<span class='{icon} {iconArrowUp}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttonbottom {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowDown}'></span></div>" + "</div>", hButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button " + "wijmo-wijsuperpanel-buttonleft'><span class='{icon} {iconCaratLeft}'>" + "</span></div><div class='{stateDefault}" + " wijmo-wijsuperpanel-button wijmo-wijsuperpanel-buttonright'>" + "<span class='{icon} {iconCaratRight}'></span></div>", vButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button" + " wijmo-wijsuperpanel-buttontop'><span class='{icon} {iconCaratUp}'>" + "</span></div><div class='{stateDefault} wijmo-wijsuperpanel-button" + " wijmo-wijsuperpanel-buttonbottom'><span class='{icon} {iconCaratDown}'>" + " </span></div>";
        wijsuperpanel.prototype = $.extend(true, {
        }, $.Widget.prototype, {
            widgetEventPrefix: "wijsuperpanel",
            _setOption: function (key, value) {
                var self = this, o = self.options, f = self._fields(), hd = f.hbarDrag, vd = f.vbarDrag, r = f.resizer;
                // override existing
                if(key === "animationOptions") {
                    value = $.extend(o.animationOptions, value);
                } else if(key === "hScroller") {
                    if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                        self._autoHLarge = false;
                    }
                    value = $.extend(o.hScroller, value);
                    self.refresh();
                } else if(key === "vScroller") {
                    if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                        self._autoVLarge = false;
                    }
                    value = $.extend(o.vScroller, value);
                    self.refresh();
                } else if(key === "resizableOptions") {
                    value = $.extend(self.resizableOptions, value);
                }
                $.Widget.prototype._setOption.apply(self, arguments);
                if($.isPlainObject(value)) {
                    self.options[key] = value;
                }
                switch(key) {
                    case "allowResize":
                        self._initResizer();
                        break;
                    case "disabled":
                        if(value) {
                            if(hd !== undefined) {
                                hd.draggable("disable");
                            }
                            if(vd !== undefined) {
                                vd.draggable("disable");
                            }
                            if(r !== undefined) {
                                r.resizable("disable");
                            }
                        } else {
                            if(hd !== undefined) {
                                hd.draggable("enable");
                            }
                            if(vd !== undefined) {
                                vd.draggable("enable");
                            }
                            if(r !== undefined) {
                                r.resizable("enable");
                            }
                        }
                        break;
                    case "mouseWheelSupport":
                    case "keyboardSupport":
                        self._bindElementEvents(self, f, self.element, o);
                        break;
                }
                return self;
            },
            _create: function () {
                var self = this, o = self.options;
                o.vScroller.dir = "v";
                o.hScroller.dir = "h";
                self._initMarkup();
                //Add support for touch
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                self.paintPanel();
                self._initResizer();
                if(self.options.disabled) {
                    self.disable();
                }
                self._detectAutoRefresh();
                if(o.listenContentScroll) {
                    self._listenContentScroll();
                }
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                        self.refresh();
                    }, "wijsuperpanel");
                }
            },
            _initMarkup: function () {
                var css = this.options.wijCSS, reg = /\{(\w+?)\}/ig, callback = function (i, g1) {
                    return css[g1];
                };
                activeCss = css.stateActive;
                hbarHtml = hbarHtml.replace(reg, callback);
                vbarHtml = vbarHtml.replace(reg, callback);
                hButtons = hButtons.replace(reg, callback);
                vButtons = vButtons.replace(reg, callback);
            },
            _detectAutoRefresh: function () {
                // register with auto fresh.
                                var self = this, panels = $.wijmo.wijsuperpanel.panels;
                if(panels === undefined) {
                    panels = [];
                    $.wijmo.wijsuperpanel.panels = panels;
                }
                panels.push(self);
                // start timer to monitor content.
                if(self.options.autoRefresh) {
                    if(!$.wijmo.wijsuperpanel.setAutoRefreshInterval) {
                        $.wijmo.wijsuperpanel.setAutoRefreshInterval = self._setAutoRefreshInterval;
                        $.wijmo.wijsuperpanel.setAutoRefreshInterval();
                    }
                }
            },
            _setAutoRefreshInterval: function () {
                var interval = $.wijmo.wijsuperpanel.autoRereshInterval, panels = $.wijmo.wijsuperpanel.panels, intervalID = window.setInterval(function () {
                    window.clearInterval(intervalID);
                    var count = panels.length, toContinue = false, i, panel, mainElement, autoRefresh, ele, mark;
                    for(i = 0; i < count; i++) {
                        panel = panels[i];
                        mainElement = panel.element[0];
                        autoRefresh = panel.options.autoRefresh;
                        if(autoRefresh) {
                            toContinue = true;
                        }
                        ele = panel.getContentElement();
                        mark = panel._paintedMark;
                        if(panel.options.autoRefresh && ele.is(":visible") && (mark === undefined || mark.width !== ele[0].offsetWidth || mark.height !== ele[0].offsetHeight || mark.mainWidth !== mainElement.offsetWidth || mark.mainHeight !== mainElement.offsetHeight)) {
                            panel.paintPanel();
                        }
                    }
                    if(toContinue) {
                        window.setTimeout($.wijmo.wijsuperpanel.setAutoRefreshInterval, 0);
                    }
                }, interval === undefined ? 500 : interval);

            },
            destroy: function () {
                /// <summary>
                /// Destroys wijsuperpanel widget and reset the DOM element.
                /// </summary>
                                var self = this, f = self._fields(), ele = self.element, buttons, templateWrapper, wijCSS = self.options.wijCSS;
                // remove this widget from panels array.
                $.wijmo.wijsuperpanel.panels = $.grep($.wijmo.wijsuperpanel.panels, function (value) {
                    return value !== self;
                }, false);
                if(!f.initialized) {
                    return;
                }
                if(self._radiusKey) {
                    self.element.css(self._radiusKey, "");
                }
                if(f.intervalID !== undefined) {
                    window.clearInterval(f.intervalID);
                    f.intervalID = undefined;
                }
                // destory widgets
                if(f.resizer !== undefined) {
                    f.resizer.resizable("destroy");
                }
                if(f.hbarContainer !== undefined) {
                    f.hbarDrag.remove();
                    f.hbarContainer.unbind("." + self.widgetName);
                }
                if(f.vbarContainer !== undefined) {
                    f.vbarDrag.remove();
                    f.vbarContainer.unbind("." + self.widgetName);
                }
                ele.unbind("." + self.widgetName);
                f.contentWrapper.unbind("." + self.widgetName);
                buttons = f.stateContainer.find(">.wijmo-wijsuperpanel-button");
                buttons.unbind("." + self.widgetName);
                templateWrapper = f.templateWrapper;
                templateWrapper.contents().each(function (index, e) {
                    ele.append(e);
                });
                f.stateContainer.remove();
                if(f.tabindex) {
                    ele.removeAttr("tabindex");
                }
                ele.removeClass([
                    "wijmo-wijsuperpanel", 
                    wijCSS.widget, 
                    wijCSS.content, 
                    wijCSS.cornerAll
                ].join(' '));
                $.Widget.prototype.destroy.apply(self, arguments);
            },
            _fields: function () {
                var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                if(d === undefined) {
                    d = {
                    };
                    ele.data(key, d);
                    self._fieldsStore = d;
                }
                return d;
            },
            _hasMode: function (scroller, mode) {
                var modes = scroller.scrollMode.split(",");
                modes = $.map(modes, function (n) {
                    return $.trim(n).toLowerCase();
                });
                return $.inArray(mode.toLowerCase(), modes) > -1;
            },
            _bindElementEvents: function (self, f, ele, o) {
                // mouse move only edge mode is used.
                                var hEdge = self._hasMode(o.hScroller, "edge"), vEdge = self._hasMode(o.vScroller, "edge"), wn = self.widgetName;
                if(hEdge || vEdge) {
                    if(self._mousemoveBind === undefined) {
                        self._mousemoveBind = true;
                        ele.bind("mousemove." + wn, self, self._contentMouseMove);
                        ele.bind("mouseleave." + wn, null, function () {
                            self._clearInterval();
                        });
                    }
                } else {
                    ele.unbind("mousemove", self._contentMouseMove);
                    self._mousemoveBind = undefined;
                }
                if(o.mouseWheelSupport) {
                    if(self._mouseWheelBind === undefined) {
                        self._mouseWheelBind = true;
                        ele.bind("mousewheel." + wn, self, self._panelMouseWheel);
                    }
                } else {
                    self.element.unbind("mousewheel", self._panelMouseWheel);
                    self._mouseWheelBind = undefined;
                }
                if(o.keyboardSupport) {
                    if(self._keyboardBind === undefined) {
                        self._keyboardBind = true;
                        ele.bind("keydown." + wn, self, self._panelKeyDown);
                    }
                } else {
                    ele.unbind("keydown", self._panelKeyDown);
                    self._keyboardBind = undefined;
                }
            },
            _dragStop: function (e, self, dir) {
                // Handles mouse drag stop event of thumb button.
                var data = {
                    dragHandle: dir
                };
                self._trigger("dragStop", e, data);
            },
            _contentMouseMove: function (e) {
                // Handles mouse move event of content area.
                // Edge hover scrolling is handled in this method.
                                var self = e.data, o = self.options, hScroller, vScroller, contentWrapper, f, hMode, vMode, mousePagePosition, off, left, top, hEdge, vEdge, innerHeight, innerWidth, dir;
                if(o.disabled) {
                    return;
                }
                hScroller = o.hScroller;
                vScroller = o.vScroller;
                contentWrapper = $(e.currentTarget);
                f = self._fields();
                hMode = self._hasMode(hScroller, "edge");
                vMode = self._hasMode(vScroller, "edge");
                self._clearInterval();
                mousePagePosition = {
                    X: e.pageX,
                    Y: e.pageY
                };
                off = contentWrapper.offset();
                left = off.left;
                top = off.top;
                left = mousePagePosition.X - left;
                top = mousePagePosition.Y - top;
                hEdge = hScroller.hoverEdgeSpan;
                vEdge = vScroller.hoverEdgeSpan;
                innerHeight = contentWrapper.innerHeight();
                innerWidth = contentWrapper.innerWidth();
                dir = "";
                if(hMode) {
                    if(left < hEdge) {
                        dir = "left";
                    }
                    if(left > (innerWidth - hEdge)) {
                        dir = "right";
                    }
                }
                if(vMode) {
                    if(top < vEdge) {
                        dir = "top";
                    }
                    if(top > (innerHeight - vEdge)) {
                        dir = "bottom";
                    }
                }
                self._setScrollingInterval(f, dir, self, false);
            },
            _setScrollingInterval: function (f, dir, self, large) {
                var o = self.options;
                if(dir.length > 0) {
                    f.internalFuncID = window.setInterval(function () {
                        self._doScrolling(dir, self, large);
                    }, o.keyDownInterval);
                }
            },
            _scrollButtonMouseOver: function (e) {
                // Scroll buttons mouse over event handler.
                                var self = e.data, o = self.options, button;
                if(o.disabled) {
                    return;
                }
                button = $(e.currentTarget);
                if(!button.hasClass(o.wijCSS.stateDisabled)) {
                    button.bind("mouseout." + self.widgetName, self, self._buttonMouseOut).bind("mousedown." + self.widgetName, self, self._buttonMouseDown).bind("mouseup." + self.widgetName, self, self._buttonMouseUp).addClass(o.wijCSS.stateHover);
                    self._buttonScroll(button, self, "buttonshover");
                }
            },
            _buttonScroll: function (button, self, mode) {
                // Do button scroll.
                                var dir = "", o = self.options, f = self._fields(), hMode = self._hasMode(o.hScroller, mode), vMode = self._hasMode(o.vScroller, mode);
                if(button.hasClass("wijmo-wijsuperpanel-buttonleft") && hMode) {
                    dir = "left";
                } else if(button.hasClass("wijmo-wijsuperpanel-buttonright") && hMode) {
                    dir = "right";
                } else if(button.hasClass("wijmo-wijsuperpanel-buttontop") && vMode) {
                    dir = "top";
                } else if(button.hasClass("wijmo-wijsuperpanel-buttonbottom") && vMode) {
                    dir = "bottom";
                }
                if(dir.length > 0) {
                    self._clearInterval();
                    self._doScrolling(dir, self, true);
                    self._setScrollingInterval(f, dir, self, true);
                }
            },
            _listenContentScroll: function () {
                var self = this, o = self.options, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag, templateWrapper = f.templateWrapper, contentWrapper = f.contentWrapper, w = contentWrapper.width(), h = contentWrapper.height(), offset = templateWrapper && templateWrapper.offset(), ox = offset && offset.left, oy = offset && offset.top, contentWidth = f.contentWidth, contentHeight = f.contentHeight;
                contentWrapper.bind("scroll", function (event) {
                    var pos = templateWrapper.position(), x = pos.left, y = pos.top;
                    contentWrapper.scrollTop(0).scrollLeft(0);
                    templateWrapper.css({
                        left: x,
                        top: y
                    });
                    if(x <= 0 && x > w - contentWidth) {
                        o.hScroller.scrollValue = self.scrollPxToValue(-x, "h");
                        self._scrollDrag("h", hbarContainer, hbarDrag, true);
                    }
                    if(y <= 0 && y > h - contentHeight) {
                        o.vScroller.scrollValue = self.scrollPxToValue(-y, "v");
                        self._scrollDrag("v", vbarContainer, vbarDrag, true);
                    }
                });
            },
            _buttonMouseDown: function (e) {
                var self = e.data, button, wijCSS = self.options.wijCSS;
                if(self.options.disabled) {
                    return;
                }
                button = $(e.currentTarget);
                if(!button.hasClass(wijCSS.stateDisabled)) {
                    button.addClass(wijCSS.stateActive);
                    self._buttonScroll(button, self, "buttons");
                }
            },
            _buttonMouseUp: function (e) {
                var self = e.data, button = $(e.currentTarget);
                button.removeClass(self.options.wijCSS.stateActive);
                self._clearInterval();
            },
            _buttonMouseOut: function (e) {
                var self = e.data, wijCSS = self.options.wijCSS, button = $(e.currentTarget);
                button.unbind("mouseout", self._buttonMouseOut).unbind("mousedown", self._buttonMouseDown).unbind("mouseup", self._buttonMouseUp).removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive);
                self._clearInterval();
            },
            getKeyCodeEnum: function () {
                if($.ui && $.ui.keyCode) {
                    return $.ui.keyCode;
                }
                if($.mobile && $.mobile.keyCode) {
                    return $.mobile.keyCode;
                }
                throw "keyCode object is not found";
            },
            _panelKeyDown: function (e) {
                // Key down handler.
                                var self = e.data, o = self.options, shift, keycode, kCode = self.getKeyCodeEnum();
                if(!o.keyboardSupport || o.disabled) {
                    return;
                }
                shift = e.shiftKey;
                keycode = e.keyCode;
                if(keycode === kCode.LEFT) {
                    self._doScrolling("left", self, shift);
                } else if(keycode === kCode.RIGHT) {
                    self._doScrolling("right", self, shift);
                } else if(keycode === kCode.UP) {
                    self._doScrolling("top", self, shift);
                } else if(keycode === kCode.DOWN) {
                    self._doScrolling("bottom", self, shift);
                }
                e.stopPropagation();
                e.preventDefault();
            },
            _draggingInternal: function (data, self, scroller, originalElement) {
                var dir = scroller.dir, h = dir === "h", key = h ? "left" : "top", left = //the parameter from draggable widget is supposed to
                //be used instead of the style property of html element
                //left = parseFloat(originalElement[0].style[key].replace("px", "")) -
                data.position[key] - self._getScrollContainerPadding(key), track = self._getTrackLen(dir) - //originalElement[h ? "outerWidth" : "outerHeight"](),
                originalElement[h ? "outerWidth" : "outerHeight"](true), proportion = left / track, topValue = (scroller.scrollMax - scroller.scrollLargeChange + 1), v = proportion * topValue, arg, scrollValue, val;
                if(v < scroller.scrollMin) {
                    v = scroller.scrollMin;
                }
                if(v > topValue) {
                    v = topValue;
                }
                arg = {
                    oldValue: scroller.scrollValue,
                    newValue: v,
                    dir: dir
                };
                if(!self._scrolling(true, self, arg)) {
                    // event is canceled in scrolling.
                    return;
                }
                if(self.customScroll) {
                    val = Math.abs(self.customScroll);
                    scrollValue = self.scrollPxToValue(val, scroller.dir);
                }
                scroller.scrollValue = scrollValue || v;
                self.customScroll = undefined;
                self._setDragAndContentPosition(true, false, dir, "dragging");
            },
            _dragging: function (e, data, self) {
                var o = self.options, originalElement = $(e.target), p = originalElement.parent();
                if(p.hasClass(hbarContainerCSS)) {
                    self._draggingInternal(data, self, o.hScroller, originalElement);
                } else {
                    self._draggingInternal(data, self, o.vScroller, originalElement);
                }
            },
            _panelMouseWheel: function (e, delta) {
                var self = e.data, o = self.options, originalElement, dir, onHbar, hScroller, vScroller, scrollEnd;
                if(!o.mouseWheelSupport || o.disabled) {
                    return;
                }
                //var f = self._fields();
                //var scrollerWrapper = f.stateContainer;
                //var hbarContainer = f.hbarContainer;
                originalElement = $(e.srcElement || e.originalEvent.target);
                dir = "";
                onHbar = originalElement.closest("." + hbarContainerCSS, self.element).size() > 0;
                hScroller = o.hScroller;
                vScroller = o.vScroller;
                if(delta > 0) {
                    dir = onHbar ? "left" : "top";
                } else {
                    dir = onHbar ? "right" : "bottom";
                }
                if(dir.length > 0) {
                    self._doScrolling(dir, self);
                }
                scrollEnd = false;
                if(dir === "left") {
                    scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - hScroller.scrollMin) < 0.001;
                }
                if(dir === "right") {
                    scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - (hScroller.scrollMax - self._getHScrollBarLargeChange() + 1)) < 0.001;
                }
                if(dir === "top") {
                    scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - vScroller.scrollMin) < 0.001;
                }
                if(dir === "bottom") {
                    scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - (vScroller.scrollMax - self._getVScrollBarLargeChange() + 1)) < 0.001;
                }
                if(!scrollEnd || !o.bubbleScrollingEvent || dir === "left" || dir === "right") {
                    e.stopPropagation();
                    e.preventDefault();
                }
            },
            _documentMouseUp: function (e) {
                var self = e.data.self, o = self.options, ele = e.data.ele;
                ele.removeClass(o.wijCSS.stateActive);
                self._clearInterval();
                $(document).unbind("mouseup", self._documentMouseUp);
            },
            _scrollerMouseOver: function (e) {
                var self = e.data, o = self.options, originalElement, ele, addhover;
                if(o.disabled) {
                    return;
                }
                originalElement = $(e.srcElement || e.originalEvent.target);
                ele = null;
                addhover = false;
                if(originalElement.hasClass(o.wijCSS.stateDefault)) {
                    ele = originalElement;
                    addhover = true;
                } else if(originalElement.parent().hasClass(o.wijCSS.stateDefault)) {
                    ele = originalElement.parent();
                    addhover = true;
                } else if(originalElement.hasClass(vbarContainerCSS) || originalElement.hasClass(hbarContainerCSS)) {
                    ele = originalElement;
                }
                if(ele) {
                    if(addhover) {
                        ele.addClass(o.wijCSS.stateHover);
                    }
                    ele.bind("mouseout." + self.widgetName, self, self._elementMouseOut);
                    ele.bind("mousedown." + self.widgetName, self, self._elementMouseDown);
                    ele.bind("mouseup." + self.widgetName, self, self._elementMouseUp);
                }
            },
            _elementMouseUp: function (e) {
                var ele = $(e.currentTarget);
                //var self = e.data;
                ele.removeClass(activeCss);
            },
            _elementMouseDown: function (e) {
                var ele = $(e.currentTarget), self = e.data, scrollDirection, large, active, hbarDrag, pos, vbarDrag, pos2, f;
                if(self.options.disabled || e.which !== 1) {
                    return;
                }
                scrollDirection = "";
                large = false;
                active = false;
                if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttontop")) {
                    scrollDirection = "top";
                    active = true;
                } else if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttonbottom")) {
                    scrollDirection = "bottom";
                    active = true;
                } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonleft")) {
                    scrollDirection = "left";
                    active = true;
                } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonright")) {
                    scrollDirection = "right";
                    active = true;
                } else if(ele.hasClass(scrollerHandle)) {
                    ele.addClass(activeCss);
                    return;
                } else if(ele.hasClass(hbarContainerCSS)) {
                    hbarDrag = ele.find("." + scrollerHandle);
                    pos = hbarDrag.offset();
                    if(e.pageX < pos.left) {
                        scrollDirection = "left";
                    } else {
                        scrollDirection = "right";
                    }
                    large = true;
                } else if(ele.hasClass(vbarContainerCSS)) {
                    vbarDrag = ele.find("." + scrollerHandle);
                    pos2 = vbarDrag.offset();
                    if(e.pageY < pos2.top) {
                        scrollDirection = "top";
                    } else {
                        scrollDirection = "bottom";
                    }
                    large = true;
                }
                self._clearInterval();
                self._doScrolling(scrollDirection, self, large);
                f = self._fields();
                self._setScrollingInterval(f, scrollDirection, self, large);
                if(active) {
                    ele.addClass(activeCss);
                }
                $(document).bind("mouseup." + self.widgetName, {
                    self: self,
                    ele: ele
                }, self._documentMouseUp);
            },
            doScrolling: function (dir, large) {
                /// <summary>
                /// Do scrolling.
                /// </summary>
                /// <param name="dir" type="string">
                ///   Scrolling direction. Options are: "left", "right", "top" and "bottom".
                /// </param>
                /// <param name="large" type="Boolean">
                /// Whether to scroll a large change.
                /// </param>
                this._doScrolling(dir, this, large);
            },
            _setScrollerValue: function (dir, scroller, smallChange, largeChange, isAdd, isLarge, self) {
                //var o = self.options;
                                var vMin = scroller.scrollMin, change = isLarge ? largeChange : smallChange, value = scroller.scrollValue, t, vTopValue, firstStepChangeFix, data, scrollValue, val;
                if(!value) {
                    value = vMin;
                }
                t = 0;
                if(isAdd) {
                    vTopValue = scroller.scrollMax - largeChange + 1;
                    if(Math.abs(value - vTopValue) < 0.001) {
                        self._clearInterval();
                        return false;
                    }
                    firstStepChangeFix = scroller.firstStepChangeFix;
                    t = value + change;
                    if(!isLarge && Math.abs(value - vMin) < 0.0001 && !isNaN(firstStepChangeFix)) {
                        t += firstStepChangeFix;
                    }
                    if(t > vTopValue) {
                        t = vTopValue;
                    }
                } else {
                    if(Math.abs(value - vMin) < 0.001) {
                        self._clearInterval();
                        return false;
                    }
                    t = value - change;
                    if(t < 0) {
                        t = vMin;
                    }
                }
                data = {
                    oldValue: scroller.scrollValue,
                    newValue: t,
                    direction: dir,
                    dir: scroller.dir
                };
                if(!self._scrolling(true, self, data)) {
                    return false;
                }
                if(self.customScroll) {
                    val = Math.abs(self.customScroll);
                    scrollValue = self.scrollPxToValue(val, scroller.dir);
                }
                scroller.scrollValue = scrollValue || t;
                self.customScroll = undefined;
                return true;
            },
            _doScrolling: function (dir, self, large) {
                // Does wijsuperpanel scrolling.
                // <param name="dir" type="String">
                // Scroll direction.
                // Options are: "left", "right", "top" and "bottom".
                // </param>
                // <param name="self" type="jQuery">
                // Pointer to the wijsuperpanel widget instance.
                // </param>
                // <param name="large" type="Boolean">
                // Whether to scroll a large change.
                // </param>
                                var o = self.options, vScroller = o.vScroller, hScroller = o.hScroller, vSmall = self._getVScrollBarSmallChange(), vLarge = self._getVScrollBarLargeChange(), hLarge = self._getHScrollBarLargeChange(), hSmall = self._getHScrollBarSmallChange();
                if(dir === "top" || dir === "bottom") {
                    if(!self._setScrollerValue(dir, vScroller, vSmall, vLarge, dir === "bottom", large, self)) {
                        return;
                    }
                    dir = "v";
                } else if(dir === "left" || dir === "right") {
                    if(!self._setScrollerValue(dir, hScroller, hSmall, hLarge, dir === "right", large, self)) {
                        return;
                    }
                    dir = "h";
                }
                self._setDragAndContentPosition(true, true, dir);
            },
            _disableButtonIfNeeded: function (self) {
                // Disables scrolling buttons.
                                var f = self._fields(), o, buttonLeft, buttonRight, buttonTop, buttonBottom, hLargeChange, hMax, hValue, hScrollMin, vLargeChange, vMax, vValue, vScrollMin;
                if(f.intervalID > 0) {
                    window.clearInterval(f.intervalID);
                }
                o = self.options;
                buttonLeft = f.buttonLeft;
                buttonRight = f.buttonRight;
                buttonTop = f.buttonTop;
                buttonBottom = f.buttonBottom;
                if(buttonLeft !== undefined) {
                    hLargeChange = self._getHScrollBarLargeChange();
                    hMax = o.hScroller.scrollMax - hLargeChange + 1;
                    hValue = o.hScroller.scrollValue;
                    hScrollMin = o.hScroller.scrollMin;
                    if(hValue === undefined) {
                        hValue = hScrollMin;
                    }
                    if(Math.abs(hValue - hScrollMin) < 0.001 || !f.hScrolling) {
                        buttonLeft.addClass(o.wijCSS.stateDisabled);
                    } else {
                        buttonLeft.removeClass(o.wijCSS.stateDisabled);
                    }
                    if(Math.abs(hValue - hMax) < 0.001 || !f.hScrolling) {
                        buttonRight.addClass(o.wijCSS.stateDisabled);
                    } else {
                        buttonRight.removeClass(o.wijCSS.stateDisabled);
                    }
                }
                if(buttonTop !== undefined) {
                    vLargeChange = self._getVScrollBarLargeChange();
                    vMax = o.vScroller.scrollMax - vLargeChange + 1;
                    vValue = o.vScroller.scrollValue;
                    vScrollMin = o.vScroller.scrollMin;
                    if(vValue === undefined) {
                        vValue = vScrollMin;
                    }
                    if(Math.abs(vValue - vScrollMin) < 0.001 || !f.vScrolling) {
                        buttonTop.addClass(o.wijCSS.stateDisabled);
                    } else {
                        buttonTop.removeClass(o.wijCSS.stateDisabled);
                    }
                    if(Math.abs(vValue - vMax) < 0.001 || !f.vScrolling) {
                        buttonBottom.addClass(o.wijCSS.stateDisabled);
                    } else {
                        buttonBottom.removeClass(o.wijCSS.stateDisabled);
                    }
                }
            },
            _clearInterval: function () {
                var f = this._fields(), intervalID = f.internalFuncID;
                if(intervalID > 0) {
                    window.clearInterval(intervalID);
                    f.internalFuncID = -1;
                }
            },
            _elementMouseOut: function (event) {
                var ele = $(event.currentTarget), self = event.data;
                ele.unbind("mouseout", self._elementMouseOut);
                ele.unbind("mousedown", self._elementMouseDown);
                ele.unbind("mouseup", self._elementMouseUp);
                ele.removeClass(self.options.wijCSS.stateHover);
            },
            _getScrollOffset: function (child1) {
                var child = $(child1), f, cWrapper, tempWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = // left, top,
                {
                    left: null,
                    top: null
                };
                if(child.length === 0) {
                    return result;
                }
                f = this._fields();
                cWrapper = f.contentWrapper;
                tempWrapper = f.templateWrapper;
                childOffset = child.offset();
                templateOffset = tempWrapper.offset();
                childOffset.leftWidth = childOffset.left + child.outerWidth();
                childOffset.topHeight = childOffset.top + child.outerHeight();
                cWrapperOffset = cWrapper.offset();
                cWrapperOffset.leftWidth = cWrapperOffset.left + cWrapper.outerWidth();
                cWrapperOffset.topHeight = cWrapperOffset.top + cWrapper.outerHeight();
                lDistance = childOffset.left - templateOffset.left;
                if(childOffset.left < cWrapperOffset.left) {
                    result.left = lDistance;
                } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                    rDistance = childOffset.leftWidth - templateOffset.left - cWrapper.innerWidth();
                    if(lDistance < rDistance) {
                        result.left = lDistance;
                    } else {
                        result.left = rDistance;
                    }
                }
                tDistance = childOffset.top - templateOffset.top;
                if(childOffset.top < cWrapperOffset.top) {
                    result.top = tDistance;
                } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                    bDistance = childOffset.topHeight - templateOffset.top - cWrapper.innerHeight();
                    if(tDistance < bDistance) {
                        result.top = tDistance;
                    } else {
                        result.top = bDistance;
                    }
                }
                return result;
            },
            _scrollDrag: function (dir, hbarContainer, hbarDrag, fireScrollEvent) {
                var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, hMin = scroller.scrollMin, hMax = scroller.scrollMax, hValue = scroller.scrollValue === undefined ? hMin : (scroller.scrollValue - hMin), hLargeChange = self._getLargeChange(dir), max = hMax - hMin - hLargeChange + 1, dragleft = -1, track, drag, padding;
                if(hValue > max) {
                    hValue = max;
                }
                if(hbarContainer !== undefined) {
                    track = self._getTrackLen(dir);
                    drag = hbarDrag[v ? "outerHeight" : "outerWidth"]();
                    padding = self._getScrollContainerPadding(v ? "top" : "left");
                    dragleft = (hValue / max) * (track - drag) + padding;
                }
                if(dragleft >= 0) {
                    hbarDrag.css(v ? "top" : "left", dragleft + "px");
                }
                self._scrollEnd(fireScrollEvent, self, dir);
            },
            needToScroll: function (child1) {
                /// <summary>
                /// Determine whether scoll the child DOM element to view
                /// need to scroll the scroll bar
                /// </summary>
                /// <param name="child" type="DOMElement/JQueryObj">
                /// The child to scroll to.
                /// </param>
                var offset = this._getScrollOffset(child1);
                return offset.top !== null || offset.left !== null;
            },
            scrollChildIntoView: function (child1) {
                /// <summary>
                /// Scroll children DOM element to view.
                /// </summary>
                /// <param name="child" type="DOMElement/JQueryObj">
                /// The child to scroll to.
                /// </param>
                                var offset = this._getScrollOffset(child1), left = offset.left, top = offset.top;
                if(left !== null) {
                    this.hScrollTo(left);
                }
                if(top !== null) {
                    this.vScrollTo(top);
                }
            },
            hScrollTo: function (x) {
                /// <summary>
                /// Scroll to horizontal position.
                /// </summary>
                /// <param name="x" type="Number">
                /// The position to scroll to.
                /// </param>
                var o = this.options;
                //var f = this._fields();
                o.hScroller.scrollValue = this.scrollPxToValue(x, "h");
                //this._setDragAndContentPosition(false, true, "h", "nonestop");
                this._setDragAndContentPosition(true, true, "h", "nonestop");
            },
            vScrollTo: function (y) {
                /// <summary>
                /// Scroll to vertical position.
                /// </summary>
                /// <param name="y" type="Number">
                /// The position to scroll to.
                /// </param>
                var o = this.options;
                o.vScroller.scrollValue = this.scrollPxToValue(y, "v");
                //this._setDragAndContentPosition(false, true, "v", "nonestop");
                this._setDragAndContentPosition(true, true, "v", "nonestop");
            },
            scrollPxToValue: function (px, dir) {
                /// <summary>
                /// Convert pixel to scroll value.
                /// For example, wijsuperpanel scrolled 50px
                ///which is value 1 after conversion.
                /// </summary>
                /// <param name="px" type="Number">
                /// Length of scrolling.
                /// </param>
                /// <param name="dir" type="String">
                /// Scrolling direction. Options are: "h" and "v".
                /// </param>
                                var o = this.options, m = (dir === "h" ? "outerWidth" : "outerHeight"), m1 = (dir === "h" ? "contentWidth" : "contentHeight"), scroller = (dir === "h" ? "hScroller" : "vScroller"), f = this._fields(), cWrapper = f.contentWrapper, size = //var tempWrapper = f.templateWrapper;
                f[m1], contentHeight = cWrapper[m](), vMin = o[scroller].scrollMin, vMax = o[scroller].scrollMax, vRange = vMax - vMin, vLargeChange = (dir === "h" ? this._getHScrollBarLargeChange() : this._getVScrollBarLargeChange()), maxv = vRange - vLargeChange + 1, ret = maxv * (px / (size - contentHeight));
                if(ret < vMin) {
                    ret = vMin;
                }
                if(ret > maxv) {
                    ret = maxv;
                }
                return ret;
            },
            scrollTo: function (x, y) {
                /// <summary>
                /// Refreshes wijsuperpanel.
                /// Needs to be called after content being changed.
                /// </summary>
                /// <param name="x" type="Number">
                /// Horizontal position to scroll to.
                /// </param>
                /// <param name="y" type="Number">
                /// Vertical position to scroll to.
                /// </param>
                this.hScrollTo(x);
                this.vScrollTo(y);
            },
            refresh: function () {
                /// <summary>
                /// Refreshes wijsuperpanel.
                /// Needs to be called after content being changed.
                /// </summary>
                /// <returns type="Boolean">
                /// Returns true if it is successful, else returns false.
                /// </returns>
                this.paintPanel();
            },
            paintPanel: function (unfocus) {
                /// <summary>
                /// Refreshes wijsuperpanel.
                /// Needs to be called after content being changed.
                /// </summary>
                /// <returns type="Boolean">
                /// Returns true if painting is successful, else returns false.
                /// </returns>
                                var self = this, ele = self.element, focused, o, f, templateWrapper;
                if(ele.is(":visible")) {
                    focused = typeof document.activeElement != 'unknown' ? document.activeElement : undefined;
                    o = self.options;
                    f = self._fields();
                    if(!f.initialized) {
                        self._initialize(f, ele, self);
                    }
                    self._resetLargeChange(self, f, o);
                    self._bindElementEvents(self, f, ele, o);
                    templateWrapper = f.templateWrapper;
                    templateWrapper.css({
                        "float": "left",
                        left: "0px",
                        top: "0px",
                        width: "auto",
                        height: "auto"
                    });
                    // hide and show wrapper div to force the width to change
                    // for some browser.
                    templateWrapper.hide();
                    templateWrapper.show();
                    f.contentWidth = templateWrapper.width();
                    f.contentHeight = templateWrapper.height();
                    templateWrapper.css("float", "");
                    self._setRounder(self, ele);
                    self._setInnerElementsSize(f, ele);
                    if(self._testScroll(self, f, o) === false) {
                        return false;
                    }
                    self._initScrollBars(self, f, o);
                    self._initScrollButtons(self, f, o);
                    self._trigger("painted");
                    self._paintedMark = {
                        date: new Date(),
                        mainWidth: ele[0].offsetWidth,
                        mainHeight: ele[0].offsetHeight,
                        width: f.contentWidth,
                        height: f.contentWidth
                    };
                    if(focused !== undefined && !unfocus) {
                        $(focused).focus();
                    }
                    return true;
                }
                return false;
            },
            _resetLargeChange: function (self, f, o) {
                var handle;
                if(self._autoVLarge) {
                    o.vScroller.scrollLargeChange = null;
                }
                if(self._autoHLarge) {
                    o.hScroller.scrollLargeChange = null;
                }
                f.vTrackLen = undefined;
                f.hTrackLen = undefined;
                if(f.vbarContainer) {
                    // fixed bug when the original draggable element removed when it's being dragged.
                    // use detach to keep the events to be fired(IE).
                    handle = f.vbarContainer.children("." + scrollerHandle + ":eq(0)");
                    handle.detach();
                    f.vbarContainer.remove();
                    f.vbarContainer = undefined;
                }
                if(f.hbarContainer) {
                    handle = f.hbarContainer.children("." + scrollerHandle + ":eq(0)");
                    handle.detach();
                    f.hbarContainer.remove();
                    f.hbarContainer = undefined;
                }
            },
            _initialize: function (f, ele, self) {
                var wijCSS = self.options.wijCSS;
                f.initialized = true;
                // ensure width and height
                ele.addClass([
                    "wijmo-wijsuperpanel", 
                    wijCSS.widget, 
                    wijCSS.content
                ].join(' '));
                f.oldHeight = ele.css("height");
                var old = ele.css("overflow");
                ele.css("overflow", "");
                // set height to element
                ele.height(ele.height());
                ele.css("overflow", old);
                self._createAdditionalDom(self, f, ele);
            },
            getContentElement: function () {
                /// <summary>
                /// Gets the content element of wijsuperpanel.
                /// </summary>
                /// <returns type="JQueryObj" />
                return this._fields().templateWrapper;
            },
            _setButtonPosition: function (self, o, scroller, dir, target, f, state) {
                var h = dir === "h", mouseoverkey = "mouseover." + self.widgetName, decKey = h ? "buttonLeft" : "buttonTop", incKey = h ? "buttonRight" : "buttonBottom", decButton = f[decKey], incButton = f[incKey], html, buttons, defaultPosition;
                if(self._hasMode(scroller, "buttons") || self._hasMode(scroller, "buttonshover")) {
                    html = h ? hButtons : vButtons;
                    if(decButton === undefined) {
                        buttons = $(html).appendTo(state);
                        buttons.bind(mouseoverkey, self, self._scrollButtonMouseOver);
                        f[decKey] = decButton = state.children(h ? ".wijmo-wijsuperpanel-buttonleft" : ".wijmo-wijsuperpanel-buttontop");
                        f[incKey] = incButton = state.children(h ? ".wijmo-wijsuperpanel-buttonright" : ".wijmo-wijsuperpanel-buttonbottom");
                    }
                    defaultPosition = {
                        my: h ? "left" : "top",
                        of: target,
                        at: h ? "left" : "top",
                        collision: "none"
                    };
                    $.extend(defaultPosition, scroller.decreaseButtonPosition);
                    decButton.position(defaultPosition);
                    defaultPosition = {
                        my: h ? "right" : "bottom",
                        of: target,
                        at: h ? "right" : "bottom",
                        collision: "none"
                    };
                    $.extend(defaultPosition, scroller.increaseButtonPosition);
                    incButton.position(defaultPosition);
                } else if(decButton !== undefined) {
                    decButton.remove();
                    incButton.remove();
                    f[decKey] = f[incKey] = undefined;
                }
            },
            _initScrollButtons: function (self, f, o) {
                var a = f.contentWrapper, state = f.stateContainer;
                self._setButtonPosition(self, o, o.hScroller, "h", a, f, state);
                self._setButtonPosition(self, o, o.vScroller, "v", a, f, state);
            },
            _getVScrollBarSmallChange: function () {
                var o = this.options, va;
                if(!o.vScroller.scrollSmallChange) {
                    va = this._getVScrollBarLargeChange();
                    o.vScroller.scrollSmallChange = va / 2;
                }
                return o.vScroller.scrollSmallChange;
            },
            _getVScrollBarLargeChange: function () {
                return this._getLargeChange("v");
            },
            _getLargeChange: function (dir) {
                var self = this, o = self.options, f = self._fields(), v = dir === "v", scroller = v ? o.vScroller : o.hScroller, clientKey = //clientKey = v ? "clientHeight" : "clientWidth",
                v ? "innerHeight" : "innerWidth", offsetKey = v ? "contentHeight" : "contentWidth", autoKey = v ? "_autoVLarge" : "_autoHLarge", hMax, hMin, hRange, content, contentWidth, wrapperWidth, percent, large;
                if(scroller.scrollLargeChange) {
                    return scroller.scrollLargeChange;
                }
                // calculate large change if empty
                hMax = scroller.scrollMax;
                hMin = scroller.scrollMin;
                hRange = hMax - hMin;
                content = f.contentWrapper;
                //contentWidth = content[0][clientKey];
                contentWidth = content[clientKey]();
                wrapperWidth = f[offsetKey];
                percent = contentWidth / (wrapperWidth - contentWidth);
                large = ((hRange + 1) * percent) / (1 + percent);
                if(isNaN(large)) {
                    large = 0;
                }
                scroller.scrollLargeChange = large;
                self[autoKey] = true;
                return scroller.scrollLargeChange;
            },
            _getHScrollBarSmallChange: function () {
                var o = this.options, va;
                if(!o.hScroller.scrollSmallChange) {
                    va = this._getHScrollBarLargeChange();
                    o.hScroller.scrollSmallChange = va / 2;
                }
                return o.hScroller.scrollSmallChange;
            },
            _getHScrollBarLargeChange: function () {
                return this._getLargeChange("h");
            },
            _initScrollBars: function (self, f, o) {
                // Set scroll bar initial position.
                                var hScroller = o.hScroller, hMax = hScroller.scrollMax, hMin = hScroller.scrollMin, hRange = hMax - hMin, vScroller = o.vScroller, vMax = vScroller.scrollMax, vMin = vScroller.scrollMin, vRange = vMax - vMin, hbarDrag = f.hbarDrag, vbarDrag = f.vbarDrag, hLargeChange, track, dragLen, difference, icon, vLargeChange, track1, dragLen1, difference1, icon1;
                if(self.hNeedScrollBar && hbarDrag.is(":visible")) {
                    hLargeChange = self._getHScrollBarLargeChange();
                    track = self._getTrackLen("h");
                    dragLen = self._getDragLength(hRange, hLargeChange, track, o.hScroller.scrollMinDragLength);
                    hbarDrag.width(dragLen);
                    //difference = hbarDrag.outerWidth() - hbarDrag.width();
                    difference = hbarDrag.outerWidth(true) - hbarDrag.width();
                    hbarDrag.width(dragLen - difference);
                    icon = hbarDrag.children("span");
                    icon.css("margin-left", (hbarDrag.width() - icon[0].offsetWidth) / 2);
                    //if (track <= hbarDrag.outerWidth()) {
                    if(track <= hbarDrag.outerWidth(true)) {
                        hbarDrag.hide();
                    } else {
                        hbarDrag.show();
                    }
                    //fixed bug the dragger will be reset after refresh
                    if(self._isDragging == true) {
                        $(document).trigger("mouseup");
                        self._isDragging = false;
                    }
                }
                if(self.vNeedScrollBar && vbarDrag.is(":visible")) {
                    vLargeChange = self._getVScrollBarLargeChange();
                    track1 = self._getTrackLen("v");
                    dragLen1 = self._getDragLength(vRange, vLargeChange, track1, o.vScroller.scrollMinDragLength);
                    vbarDrag.height(dragLen1);
                    //difference1 = vbarDrag.outerHeight() - vbarDrag.height();
                    difference1 = vbarDrag.outerHeight(true) - vbarDrag.height();
                    vbarDrag.height(dragLen1 - difference1);
                    icon1 = vbarDrag.children("span");
                    icon1.css("margin-top", (vbarDrag.height() - icon1[0].offsetHeight) / 2);
                    //if (track1 <= vbarDrag.outerHeight()) {
                    if(track1 <= vbarDrag.outerHeight(true)) {
                        vbarDrag.hide();
                    } else {
                        vbarDrag.show();
                    }
                    //fixed bug the dragger will be reset after refresh
                    if(self._isDragging == true) {
                        $(document).trigger("mouseup");
                        self._isDragging = false;
                    }
                }
                self._setDragAndContentPosition(false, false, "both");
            },
            _getTrackLen: function (dir) {
                // Get the length of the track.
                // <param name="dir" type="String">
                // Options are: "v" and "h".
                // "v" - Vertical scroll track.
                // "h" - Horizontal scroll track.
                // </param>
                                var self = this, f = self._fields(), key = //var o = self.options;
                dir + "TrackLen", hbarContainer, vbarContainer, track, padding;
                if(f[key] !== undefined) {
                    return f[key];
                }
                hbarContainer = f.hbarContainer;
                vbarContainer = f.vbarContainer;
                track = 0;
                padding = 0;
                if(dir === "h") {
                    padding = self._getScrollContainerPadding("h");
                    track = hbarContainer.innerWidth();
                }
                if(dir === "v") {
                    padding = self._getScrollContainerPadding("v");
                    track = vbarContainer.innerHeight();
                }
                f[key] = (track - padding);
                return f[key];
            },
            _getScrollContainerPadding: function (paddingType) {
                // Get the padding of the scroll bar container.
                                var self = this, f = self._fields(), padding = 0, container, key;
                if(paddingType === "h") {
                    padding = self._getScrollContainerPadding("left") + self._getScrollContainerPadding("right");
                } else if(paddingType === "v") {
                    padding = self._getScrollContainerPadding("top") + self._getScrollContainerPadding("bottom");
                } else {
                    if(paddingType === "left" || paddingType === "right") {
                        container = f.hbarContainer;
                    } else {
                        container = f.vbarContainer;
                    }
                    key = paddingType + "Padding";
                    if(f[key] !== undefined) {
                        padding = f[key];
                        return padding;
                    }
                    //padding = parseFloat(container.css("padding-" +
                    //paddingType).replace("px", ""));
                    if(container && container.css) {
                        padding = parseFloat(container.css("padding-" + paddingType));
                    }
                    f[key] = padding;
                }
                return padding;
            },
            _triggerScroll: function (contentLeft, dir, contentAnimationOptions) {
                var data = {
                    position: contentLeft,
                    dir: dir,
                    animationOptions: contentAnimationOptions
                };
                this._trigger("scroll", null, data);
            },
            _contentDragAnimate: function (dir, animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging) {
                var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, tempKey = v ? "outerHeight" : "outerWidth", wrapKey = v ? "innerHeight" : "innerWidth", contentKey = v ? "contentHeight" : "contentWidth", paddingKey = v ? "top" : "left", hMin = scroller.scrollMin, hMax = scroller.scrollMax, hRange = hMax - hMin, hValue = scroller.scrollValue === undefined ? hMin : (scroller.scrollValue - hMin), hLargeChange = self._getLargeChange(dir), max = hRange - hLargeChange + 1, f = self._fields(), cWrapper = f.contentWrapper, tempWrapper = f.templateWrapper, contentLeft, dragleft, track, drag, r, padding, dragAnimationOptions, properties, contentAnimationOptions, userComplete, properties1, key;
                if(hValue > max) {
                    hValue = max;
                }
                contentLeft = (f[contentKey] - cWrapper[wrapKey]()) * (hValue / max);
                if(Math.abs(contentLeft) < 0.001) {
                    contentLeft = 0;
                }
                contentLeft = Math.round(contentLeft);
                dragleft = -1;
                if(hbarContainer !== undefined) {
                    if(animated && hbarDrag.is(":animated") && stop !== "nonestop") {
                        hbarDrag.stop(true, false);
                    }
                    track = self._getTrackLen(dir);
                    //drag = hbarDrag[tempKey]();
                    drag = hbarDrag[tempKey](true);
                    r = track - drag;
                    padding = self._getScrollContainerPadding(paddingKey);
                    dragleft = (hValue / max) * r + padding;
                }
                if(animated && o.animationOptions && !o.animationOptions.disabled) {
                    if(dragleft >= 0 && dragging !== "dragging") {
                        dragAnimationOptions = $.extend({
                        }, o.animationOptions);
                        // not trigger scrolled when stop
                        dragAnimationOptions.complete = undefined;
                        if(v) {
                            properties = {
                                top: dragleft
                            };
                        } else {
                            properties = {
                                left: dragleft
                            };
                        }
                        hbarDrag.animate(properties, dragAnimationOptions);
                    }
                    contentAnimationOptions = $.extend({
                    }, o.animationOptions);
                    userComplete = o.animationOptions.complete;
                    contentAnimationOptions.complete = function () {
                        self._scrollEnd(fireScrollEvent, self, dir);
                        if($.isFunction(userComplete)) {
                            userComplete(arguments);
                        }
                    };
                    if(animated && tempWrapper.is(":animated") && stop !== "nonestop") {
                        tempWrapper.stop(true, false);
                    }
                    if(v) {
                        properties1 = {
                            top: -contentLeft
                        };
                    } else {
                        properties1 = {
                            left: -contentLeft
                        };
                    }
                    //console.log("content move1");
                    if(!o.customScrolling) {
                        tempWrapper.animate(properties1, contentAnimationOptions);
                    } else {
                        self._scrollEnd(fireScrollEvent, self, dir, hValue);
                    }
                    self._triggerScroll(contentLeft, dir, contentAnimationOptions);
                } else if(scroller.scrollBarVisibility !== "hidden") {
                    key = v ? "top" : "left";
                    if(dragleft >= 0 && dragging !== "dragging") {
                        hbarDrag[0].style[key] = dragleft + "px";
                    }
                    //console.log("content move2");
                    if(!o.customScrolling) {
                        tempWrapper[0].style[key] = -contentLeft + "px";
                    }
                    self._triggerScroll(contentLeft, dir);
                    self._scrollEnd(fireScrollEvent, self, dir, hValue);
                }
            },
            _setDragAndContentPosition: function (fireScrollEvent, animated, dir, stop, dragging) {
                var self = this, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag;
                if((dir === "both" || dir === "h") && f.hScrolling) {
                    self._contentDragAnimate("h", animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging);
                }
                if((dir === "both" || dir === "v") && f.vScrolling) {
                    self._contentDragAnimate("v", animated, vbarContainer, vbarDrag, stop, fireScrollEvent, dragging);
                }
                if(f.intervalID > 0) {
                    window.clearInterval(f.intervalID);
                }
                f.intervalID = window.setInterval(function () {
                    self._disableButtonIfNeeded(self);
                }, 500);
            },
            _scrolling: function (fireEvent, self, d) {
                var r = true;
                if(fireEvent) {
                    d.beforePosition = self.getContentElement().position();
                    self._beforePosition = d.beforePosition;
                    //console.log("scrolling:" + JSON.stringify(d));
                    r = self._trigger("scrolling", null, d);
                    self.customScroll = d.customScroll;
                }
                return r;
            },
            _scrollEnd: function (fireEvent, self, dir, newValue) {
                if(fireEvent) {
                    // use settimeout to return to caller immediately.
                    window.setTimeout(function () {
                        var content = self.getContentElement(), after, d;
                        if(!content.is(":visible")) {
                            return;
                        }
                        after = self.getContentElement().position();
                        d = {
                            dir: dir,
                            beforePosition: self._beforePosition,
                            afterPosition: after
                        };
                        if(!isNaN(newValue)) {
                            d.newValue = newValue;
                        }
                        //console.log("scrolled:" + JSON.stringify(d));
                        self._trigger("scrolled", null, d);
                    }, 0);
                }
            },
            _getDragLength: function (range, largeChange, track, min) {
                var divide = range / largeChange, dragLength = track / divide, minidrag = min;
                if(dragLength < minidrag) {
                    dragLength = minidrag;
                } else if((dragLength + 1) >= track) {
                    dragLength = track - 1;
                }
                return Math.round(dragLength);
            },
            _needScrollbar: function (scroller, needscroll) {
                var scrollbarMode = this._hasMode(scroller, "scrollbar"), barVisibility = scroller.scrollBarVisibility, needScrollBar = scrollbarMode && (barVisibility === "visible" || (barVisibility === "auto" && needscroll));
                return needScrollBar;
            },
            _bindBarEvent: function (barContainer, barDrag, dir) {
                var self = this;
                barContainer.bind("mouseover." + self.widgetName, self, self._scrollerMouseOver);
                if(!$.fn.draggable) {
                    return;
                }
                barDrag.draggable({
                    axis: dir === "h" ? "x" : "y",
                    start: function (e, data) {
                        self._isDragging = true;
                    },
                    drag: function (e, data) {
                        self._dragging(e, data, self);
                    },
                    containment: "parent",
                    stop: function (e) {
                        self._dragStop(e, self, dir);
                        $(e.target).removeClass(activeCss);
                        self._isDragging = false;
                    }
                });
            },
            _createBarIfNeeded: function (hNeedScrollBar, scrollerWrapper, dir, html, content) {
                if(hNeedScrollBar) {
                    var self = this, data, f = self._fields(), strBarContainer = dir + "barContainer", strBarDrag = dir + "barDrag", hbar = dir === "h", contentLength = //contentLength = content[0][hbar ? "clientHeight" : "clientWidth"],
                    content[hbar ? "innerHeight" : "innerWidth"](), c = f[strBarContainer] = $(html), targetBarLen, d;
                    scrollerWrapper.append(c);
                    targetBarLen = c[0][hbar ? "offsetHeight" : "offsetWidth"];
                    contentLength = contentLength - targetBarLen;
                    data = {
                        direction: hbar ? "horizontal" : "vertical",
                        targetBarLen: targetBarLen,
                        contentLength: contentLength
                    };
                    if(self._trigger(hbar ? "hScrollerActivating" : "vScrollerActivating", null, data) === false) {
                        return false;
                    }
                    d = f[strBarDrag] = c.find("." + scrollerHandle);
                    self._bindBarEvent(c, d, dir);
                    content[hbar ? "height" : "width"](contentLength);
                    // fixed bug on forum when set contentlength ,the width or height is changed.
                    //				f[hbar ? "contentWidth" : "contentHeight"] =
                    //                f.templateWrapper[hbar ? "width" : "height"]();
                                    }
            },
            _setScrollbarPosition: function (wrapper, self, content, targetBarContainer, referBarContainer, targetNeedScrollBar, referNeedScrollBar, targetScrollBarPosition, referScrollBarPosition, dir, scrollingNeed) {
                var hbar = dir === "h", targetBarLen, targetPadding, targetBarPosition, barPosition1, contentPosition1, barPosition2, contentPosition2, contentLength2, referBarWidth, css = self.options.wijCSS;
                if(targetNeedScrollBar) {
                    targetBarLen = targetBarContainer[0][hbar ? "offsetHeight" : "offsetWidth"];
                    targetPadding = self._getScrollContainerPadding(dir);
                    targetBarPosition = hbar ? "top" : "left";
                    barPosition1 = hbar ? {
                        top: "0px",
                        bottom: "auto",
                        left: "auto",
                        right: "auto"
                    } : {
                        left: "0px",
                        right: "auto",
                        top: "auto",
                        bottom: "auto"
                    };
                    contentPosition1 = hbar ? {
                        top: targetBarLen + "px",
                        left: null
                    } : {
                        left: targetBarLen + "px"
                    };
                    barPosition2 = hbar ? {
                        top: "auto",
                        right: "auto",
                        left: "auto",
                        bottom: "0px"
                    } : {
                        left: "auto",
                        right: "0px",
                        top: "auto",
                        bottom: "auto"
                    };
                    contentPosition2 = hbar ? {
                        top: "",
                        left: null
                    } : {
                        left: ""
                    };
                    //var contentLength = content[0][hbar? "clientHeight":"clientWidth"];
                    //contentLength2 = content[0][hbar? "clientWidth":"clientHeight"];
                    contentLength2 = content[hbar ? "innerWidth" : "innerHeight"]();
                    if(targetScrollBarPosition === targetBarPosition) {
                        targetBarContainer.css(barPosition1);
                        content.css(contentPosition1);
                        if(hbar) {
                            targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerBL).addClass(css.cornerTL);
                            targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBR).addClass(css.cornerTR);
                            targetBarContainer.removeClass(css.cornerBottom).addClass(css.cornerTop);
                        } else {
                            targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTR).addClass(css.cornerTL);
                            targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBR).addClass(css.cornerBL);
                            targetBarContainer.removeClass(css.cornerRight).addClass(css.cornerLeft);
                        }
                    } else {
                        targetBarContainer.css(barPosition2);
                        content.css(contentPosition2);
                        if(hbar) {
                            targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerTL).addClass(css.cornerBL);
                            targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBL).addClass(css.cornerBR);
                            targetBarContainer.removeClass(css.cornerTop).addClass(css.cornerBottom);
                        } else {
                            targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTL).addClass(css.cornerTR);
                            targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBL).addClass(css.cornerBR);
                            targetBarContainer.removeClass(css.cornerLeft).addClass(css.cornerRight);
                        }
                    }
                    //content[hbar?"height":"width"](contentLength - targetBarLen);
                    referBarWidth = 0;
                    if(referNeedScrollBar) {
                        referBarWidth = referBarContainer[0][hbar ? "offsetWidth" : "offsetHeight"];
                        if(referScrollBarPosition === "left") {
                            targetBarContainer.css("right", "0px");
                        } else if(referScrollBarPosition === "right") {
                            targetBarContainer.css("left", "0px");
                        } else if(referScrollBarPosition === "top") {
                            targetBarContainer.css("bottom", "0px");
                        } else if(referScrollBarPosition === "bottom") {
                            targetBarContainer.css("top", "0px");
                        }
                    }
                    if(!hbar/*vbar*/  && referNeedScrollBar) {
                        referBarWidth = 0;
                    }
                    targetBarContainer[hbar ? "width" : "height"](contentLength2 - targetPadding);
                    self._enableDisableScrollBar(dir, targetBarContainer, !scrollingNeed);
                } else {
                    wrapper.css(hbar ? "left" : "top", "");
                }
            },
            _testScroll: function (self, f, o) {
                var wrapper = f.templateWrapper, content = f.contentWrapper, scrollerWrapper = f.stateContainer, contentWidth = content.innerWidth(), contentHeight = content.innerHeight(), wrapperWidth = f.contentWidth, wrapperHeight = f.contentHeight, hNeedScrollBar, vNeedScrollBar, hbarContainer, vbarContainer, hbarPosition, vbarPosition;
                f.hScrolling = wrapperWidth > contentWidth;
                f.vScrolling = wrapperHeight > contentHeight;
                hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                    return false;
                }
                // having h scroll bar, but no vscroll bar, we need to test vscrolling again.
                if(hNeedScrollBar && !f.vScrolling) {
                    wrapper.css("float", "left");
                    f.contentHeight = wrapper.height();
                    f.vScrolling = f.contentHeight > (contentHeight - f.hbarContainer[0].offsetHeight);
                    wrapper.css("float", "");
                }
                vNeedScrollBar = self.vNeedScrollBar = self._needScrollbar(o.vScroller, f.vScrolling);
                if(self._createBarIfNeeded(vNeedScrollBar, scrollerWrapper, "v", vbarHtml, content) === false) {
                    return false;
                }
                if(vNeedScrollBar && !f.hScrolling) {
                    wrapper.css("float", "left");
                    f.contentWidth = wrapper.width();
                    //contentWidth =
                    f.hScrolling = f.contentWidth > (contentWidth - f.vbarContainer[0].offsetWidth);
                    wrapper.css("float", "");
                    if(f.hScrolling && !hNeedScrollBar) {
                        hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                        if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                            return false;
                        }
                    }
                }
                hbarContainer = f.hbarContainer;
                vbarContainer = f.vbarContainer;
                hbarPosition = o.hScroller.scrollBarPosition;
                vbarPosition = o.vScroller.scrollBarPosition;
                self._setScrollbarPosition(wrapper, self, content, hbarContainer, vbarContainer, hNeedScrollBar, vNeedScrollBar, hbarPosition, vbarPosition, "h", f.hScrolling);
                self._setScrollbarPosition(wrapper, self, content, vbarContainer, hbarContainer, vNeedScrollBar, hNeedScrollBar, vbarPosition, hbarPosition, "v", f.vScrolling);
            },
            _enableDisableScrollBar: function (bar, barContainer, disable) {
                // Disables scroll bar.
                // <param name="bar" type="String">
                // Scrollbar to disable.
                // Options are: "h" and "v"
                // </param>
                // <param name="barContainer" type="jQuery">
                // The scroll bar container jQuery object.
                // </param>
                // <param name="disable" type="Boolean">
                // Whether to disable scroll bar.
                // </param>
                var o = this.options;
                if(bar === "v") {
                    barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-vbarcontainer-disabled");
                    barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                } else if(bar === "h") {
                    barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-hbarcontainer-disabled");
                    barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                }
                barContainer.children("." + scrollerHandle)[disable ? "hide" : "show"]();
            },
            _initResizer: function () {
                // Initialize reseizer of wijsuperpanel.
                                var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                if(!$.fn.resizable) {
                    return;
                }
                if(!resizer && o.allowResize) {
                    resizableOptions = o.resizableOptions;
                    oldstop = resizableOptions.stop;
                    resizableOptions.stop = function (e) {
                        self._resizeStop(e, self);
                        if($.isFunction(oldstop)) {
                            oldstop(e);
                        }
                    };
                    f.resizer = resizer = self.element.resizable(resizableOptions);
                }
                if(!o.allowResize && f.resizer) {
                    resizer.resizable("destroy");
                    f.resizer = null;
                }
            },
            _resizeStop: function (e, self) {
                // give the chance to autoRefresh polling to repaint.
                if(!this.options.autoRefresh) {
                    self.paintPanel(true);
                }
                self._trigger("resized");
            },
            _createAdditionalDom: function (self, f, ele) {
                // make sure the key pressing event work in FireFox.
                if(!ele.attr("tabindex")) {
                    ele.attr("tabindex", "-1");
                    f.tabindex = true;
                }
                var stateContainer = f.stateContainer = $(innerElementHtml), templateW;
                // move child element to content wrapper div of wijsuperpanel.
                f.contentWrapper = stateContainer.children();
                templateW = f.templateWrapper = f.contentWrapper.children();
                ele.contents().each(function (index, el) {
                    var jel = $(el);
                    if(jel.hasClass("wijmo-wijsuperpanel-header")) {
                        f.header = jel;
                        return;
                    }
                    if(jel.hasClass("wijmo-wijsuperpanel-footer")) {
                        f.footer = jel;
                        return;
                    }
                    templateW[0].appendChild(el);
                });
                // apeend header to first element.
                if(f.header !== undefined) {
                    ele.prepend(f.header);
                }
                ele[0].appendChild(stateContainer[0]);
                // apeend footer to first element.
                if(f.footer !== undefined) {
                    f.footer.insertAfter(stateContainer);
                }
            },
            _setRounder: function (self, ele) {
                if(this.options.showRounder) {
                    ele.addClass(this.options.wijCSS.cornerAll);
                    if(self._rounderAdded) {
                        return;
                    }
                    if($.browser.msie) {
                        return;
                    }
                    var key1, key, value, border;
                    key1 = key = "";
                    if($.browser.webkit) {
                        key = "WebkitBorderTopLeftRadius";
                        key1 = "WebkitBorderRadius";
                    } else if($.browser.mozilla) {
                        key = "MozBorderRadiusBottomleft";
                        key1 = "MozBorderRadius";
                    } else {
                        key = "border-top-left-radius";
                        key1 = "border-radius";
                    }
                    value = ele.css(key);
                    border = parseInt(value, 10);
                    // adding 1 extra to out-most radius.
                    ele.css(key1, border + 1);
                    self._rounderAdded = true;
                    self._radiusKey = key1;
                } else {
                    ele.removeClass(this.options.wijCSS.cornerAll);
                }
            },
            _setInnerElementsSize: function (f, ele) {
                var state = f.stateContainer, content = f.contentWrapper, height = 0, style, clientHeight, clientWidth, style2;
                if(f.header !== undefined) {
                    height += f.header.outerHeight();
                }
                if(f.footer !== undefined) {
                    height += f.footer.outerHeight();
                }
                style = state[0].style;
                //clientHeight = ele[0].clientHeight - height;
                //clientWidth = ele[0].clientWidth;
                clientHeight = ele.innerHeight() - height;
                clientWidth = ele.innerWidth();
                // hide element before setting width and height to improve
                //javascript performance in FF3.
                style.display = "none";
                style.height = clientHeight + "px";
                style.width = clientWidth + "px";
                style2 = content[0].style;
                style2.height = clientHeight + "px";
                style2.width = clientWidth + "px";
                style.display = "";
            }
        });
        wijsuperpanel.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, {
            wijMobileCSS: {
                header: "ui-header ui-bar-a",
                content: "ui-body-c",
                stateDefault: "ui-btn-up-c",
                stateHover: "ui-btn-down-c",
                stateActive: "ui-btn-down-c"
            },
            initSelector: /// <summary>
            /// Selector option for auto self initialization.
            ///	This option is internal.
            /// </summary>
            ":jqmData(role='wijsuperpanel')",
            allowResize: /// <summary>
            /// This value determines whether the wijsuperpanel can be resized.
            /// Default: false.
            /// Type: Boolean.
            /// </summary>
            false,
            autoRefresh: /// <summary>
            /// This value determines whether wijsuperpanel to automatically refresh
            /// when content size or wijsuperpanel size are changed.
            /// Default: false.
            /// Type: Boolean.
            /// </summary>
            false,
            animationOptions: /// <summary>
            /// The animation properties of wijsuperpanel scrolling.
            /// Type: Object.
            /// </summary>
            /// <remarks>
            /// Set this options to null to disable animation.
            /// </remarks>
            {
                queue: /// <summary>
                /// This value determines whether to queue animation operations.
                /// Default: false.
                /// Type: Boolean.
                /// </summary>
                false,
                disabled: /// <summary>
                /// This value determines whether to disable animation operations.
                /// Default: false.
                /// Type: Boolean.
                /// </summary>
                false,
                duration: /// <summary>
                /// This value sets the animation duration of the scrolling animation.
                /// Default: 250.
                /// Type: Number.
                /// </summary>
                250,
                easing: /// <summary>
                /// This value sets the animation easing of the scrolling animation.
                /// Default: undefined.
                /// Type: string.
                /// </summary>
                undefined
            },
            hScrollerActivating: /// <summary>
            /// The hScrollerActivating event handler.
            /// A function called when horizontal scrollbar is activating.
            /// Default: null
            /// Type: Function
            /// Code example:
            /// Supply a function as an option.
            /// $("#selector").wijsuperpanel({ hScrollerActivating: function (e, data) { } });
            /// Bind to the event by type: wijtreenodeClick
            /// $("#selector").bind("wijsuperpanelhScrollerActivating", function(e, data) { } );
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data that relates to this event.
            /// data.direction: the direction of the scrollbar("horizontal" or "vertical").
            /// data.targetBarLen: the height of the horizontal scrollbar.
            /// data.contentLength: the height of the content.
            /// </param>
            null,
            hScroller: /// <summary>
            /// This option contains horizontal scroller settings.
            /// </summary>
            {
                scrollBarPosition: /// <summary>
                /// This value determines the position of the horizontal scroll bar.
                /// Default: "bottom".
                /// Type: String.
                /// </summary>
                /// <remarks>
                /// Possible options are "bottom" and "top".
                /// "bottom" - The horizontal scroll bar is placed at the bottom of
                /// the content area.
                /// "top" - The horizontal scroll bar is placed at the top of the
                ///content area.
                /// </remarks>
                "bottom",
                scrollBarVisibility: /// <summary>
                /// This value determines the visibility of the horizontal scroll bar.
                /// Default: "auto".
                /// Type: String
                /// </summary>
                /// <remarks>
                /// Possible options are "auto", "visible" and "hidden".
                /// "auto" - Shows the scroll when needed.
                /// "visible" - Scroll bar will always be visible. It"s disabled
                /// when not needed.
                /// "hidden" - Scroll bar will be hidden.
                /// </remarks>
                "auto",
                scrollMode: /// <summary>
                /// This value determines the scroll mode of horizontal scrolling.
                /// Default: "scrollbar".
                /// Type: String.
                /// </summary>
                /// <remarks>
                /// Possible options are "scrollBar", "buttons", "buttonsHover"
                /// and "edge".
                /// "scrollBar" - Scroll bars are used for scrolling.
                /// "buttons" - Scroll buttons are used for scrolling.
                /// Scrolling occurs only when scroll buttons are clicked.
                /// "buttonsHover" - Scroll buttons are used for scrolling.
                /// Scrolling occurs only when scroll buttons are hovered.
                /// "edge" - Scrolling occurs when the mouse is moving to the edge
                /// of the content area.
                /// Scroll modes can be combined with each other.
                /// For example, scrollMode: "scrollbar,scrollbuttons" will enable
                /// both a scrollbar and scroll buttons.
                /// </remarks>
                "scrollBar",
                scrollValue: /// <summary>
                /// This value determines the horizontal scrolling position of
                /// wijsuperpanel.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                null,
                scrollMax: /// <summary>
                /// This value sets the maximum value of horizontal scroller.
                /// Default: 100.
                /// Type: Number.
                /// </summary>
                100,
                scrollMin: /// <summary>
                /// This value sets the minimum value of horizontal scroller.
                /// Default: 0.
                /// Type: Number.
                /// </summary>
                0,
                scrollLargeChange: /// <summary>
                /// This value sets the large change value of horizontal scroller.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                /// <remarks>
                /// wijsuperpanel will scroll a large change when a user clicks on the
                /// tracks of scroll bars or presses left or right arrow keys on the
                /// keyboard with the shift key down.
                /// When scrollLargeChange is null, wijsuperpanel will scroll
                /// the width of content.
                /// </remarks>
                null,
                scrollSmallChange: /// <summary>
                /// This value sets the small change value of horizontal scroller.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                /// <remarks>
                /// wijsuperpanel will scroll a small change when a user clicks on
                /// the arrows of scroll bars, clicks or hovers scroll buttons,
                /// presses left or right arrow keys on keyboard,
                /// and hovers on the edge of wijsuperpanel.
                /// When scrollSmallChange is null, wijsuperpanel will scroll half of
                /// the width of content.
                /// </remarks>
                null,
                scrollMinDragLength: /// <summary>
                /// This value sets the minimum length, in pixel, of the horizontal
                /// scroll bar thumb button.
                /// Default: 6.
                /// Type: Number.
                /// </summary>
                6,
                increaseButtonPosition: /// <summary>
                /// This object determines the increase button position.
                /// Default: null.
                /// Type: Object.
                /// </summary>
                /// <remarks>
                /// Please look at the options for jquery.ui.position.js for more info.
                /// </remarks>
                null,
                decreaseButtonPosition: /// <summary>
                /// This object determines the decrease button position.
                /// Default: 0.
                /// Type: Object.
                /// </summary>
                null,
                hoverEdgeSpan: /// <summary>
                /// This value sets the width of horizontal hovering edge
                /// which will trigger the horizontal scrolling.
                /// Default: 20.
                /// Type: Number.
                /// </summary>
                20,
                firstStepChangeFix: /// <summary>
                /// The number specifies the value to add to smallchange or largechange
                /// when scrolling the first step(scrolling from scrollMin).
                /// Default: 0.
                /// Type: Number.
                /// </summary>
                0
            },
            keyboardSupport: /// <summary>
            /// A value determins whether wijsuperpanel provides
            /// keyboard scrolling support.
            /// Default: false.
            /// Type: Boolean.
            /// </summary>
            false,
            keyDownInterval: /// <summary>
            /// This value determines the time interval to call the scrolling
            /// function when doing continuous scrolling.
            /// Default: 100.
            /// Type: Number.
            /// </summary>
            100,
            mouseWheelSupport: /// <summary>
            /// This value determines whether wijsuperpanel has mouse wheel support.
            /// Default: true.
            /// Type: Boolean.
            /// </summary>
            /// <remarks>
            /// Mouse wheel plugin is needed to support this feature.
            /// </remarks>
            true,
            bubbleScrollingEvent: /// <summary>
            /// This value determines whether to fire the mouse wheel event
            /// when wijsuperpanel is scrolled to the end.
            /// Default: true.
            /// Type: Boolean.
            /// </summary>
            true,
            resizableOptions: /// <summary>
            /// This option determines the behavior of resizable widget.
            /// See JQuery UI resizable options document.
            /// Type: Object.
            /// </summary>
            {
                handles: "all",
                helper: "ui-widget-content wijmo-wijsuperpanel-helper"
            },
            resized: /// <summary>
            /// Resized event handler. A function gets called when resized event is fired.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the resized event:
            /// $("#element").wijsuperpanel({ resized: funtion() { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpanelresized", funtion() { dosometing });
            /// </summary>
            null,
            dragStop: /// <summary>
            /// This function gets called when thumb buttons of scrollbars dragging stops.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the dragstop event:
            /// $("#element").wijsuperpanel({ dragStop: funtion(e, data) { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpaneldragstop", funtion(e, data) { dosometing });
            /// <param name="e" type="EventObj">
            /// EventObj relates to this event.
            /// </param>
            /// <param name="data" type="Object">
            /// The data with this event.
            /// data.dir: data.draghandle is the direction of the scrolling action.
            /// Possible values: "v"(vertical) and "h"(horizontal).
            /// </param>
            /// </summary>
            null,
            painted: /// <summary>
            /// This function gets called after panel is painted.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the painted event:
            /// $("#element").wijsuperpanel({ painted: funtion() { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpanelpainted", funtion() { dosometing });
            /// </summary>
            null,
            scrolling: /// <summary>
            /// Scrolling event handler. A function called before scrolling occurs.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the scrolling event:
            /// $("#element").wijsuperpanel({ scrolling: funtion(e, data) { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpanelscrolling", funtion(e, data) { dosometing });
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data with this event.
            /// data.oldValue: The scrollValue before scrolling occurs.
            /// data.newValue: The scrollValue after scrolling occurs.
            /// data.dir: The direction of the scrolling action.
            /// Possible values: "v"(vertical) and "h"(horizontal).
            /// data.beforePosition: The position of content before scrolling occurs.
            /// </param>
            null,
            scroll: /// <summary>
            /// Scroll event handler. A function called immediately after scrolling occurs.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the scroll event:
            /// $("#element").wijsuperpanel({ scroll: funtion(e, data) { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpanelscroll", funtion(e, data) { dosometing });
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data with this event.
            /// data.animationOptions: The options of the animation which scrolling uses
            /// data.dir: The direction of the scrolling action.
            /// Possible values: "v"(vertical) and "h"(horizontal).
            /// data.position: The position of content after scrolling occurs.
            /// </param>
            null,
            scrolled: /// <summary>
            /// Scrolled event handler.  A function called after scrolling occurs.
            /// Default: null.
            /// Type: Function.
            /// code example:
            /// Supply a callback function to handle the scrolled event:
            /// $("#element").wijsuperpanel({ scrolled: funtion(e, data) { dosometing } });
            /// Bind to the event by type:
            /// $("#element").bind("wijsuperpanelscrolled", funtion(e, data) { dosometing });
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data with this event.
            /// data.dir: The direction of the scrolling action.
            /// Possible values: "v"(vertical) and "h"(horizontal).
            /// data.beforePosition: The position of content before scrolling occurs.
            /// data.afterPosition: The position of content after scrolling occurs.
            /// </param>
            null,
            showRounder: /// <summary>
            /// This value determines whether to show the rounded corner of wijsuperpanel.
            /// Default: true.
            /// Type: Boolean.
            /// </summary>
            true,
            vScrollerActivating: /// <summary>
            /// The vScrollerActivating event handler.
            /// A function called when vertical scrollbar is activating.
            /// Default: null
            /// Type: Function
            /// Code example:
            /// Supply a function as an option.
            /// $("#selector").wijsuperpanel({ vScrollerActivating: function (e, data) { } });
            /// Bind to the event by type: wijtreenodeClick
            /// $("#selector").bind("wijsuperpanelvScrollerActivating", function(e, data) { } );
            /// </summary>
            /// <param name="e" type="Object">
            /// jQuery.Event object.
            /// </param>
            /// <param name="data" type="Object">
            /// The data that relates to this event.
            /// data.direction: the direction of the scrollbar("horizontal" or "vertical").
            /// data.targetBarLen: the width of the vertical scrollbar.
            /// data.contentLength: the width of the content.
            /// </param>
            null,
            vScroller: /// <summary>
            /// This option contains vertical scroller settings.
            /// </summary>
            {
                scrollBarPosition: /// <summary>
                /// This value determines the position of vertical scroll bar.
                /// Default: "right".
                /// Type: String.
                /// </summary>
                /// <remarks>
                /// Possible options are: "left", "right".
                /// "left" - The vertical scroll bar is placed at the
                /// left side of the content area.
                /// "right" - The vertical scroll bar is placed at the
                /// right side of the content area.
                /// </remarks>
                "right",
                scrollBarVisibility: /// <summary>
                /// This value determines the visibility of the vertical scroll bar.
                /// Default.: "auto".
                /// Type: String.
                /// </summary>
                /// <remarks>
                /// Possible options are "auto", "visible" and "hidden".
                /// "auto" - Shows the scroll bar when needed.
                /// "visible" - Scroll bar will always be visible.
                /// It"s disabled when not needed.
                /// "hidden" - Scroll bar will be shown.
                /// </remarks>
                "auto",
                scrollMode: /// <summary>
                /// This value determines the scroll mode of vertical scrolling.
                /// Default: "scrollbar".
                /// Type: String.
                /// </summary>
                /// <remarks>
                /// Possible options are: "scrollBar", "buttons",
                /// "buttonsHover" and "edge".
                /// "scrollBar" - Scroll bars are used for scrolling.
                /// "buttons" - Scroll buttons are used for scrolling.
                /// Scrolling occurs only when scroll buttons are clicked.
                /// "buttonsHover" - Scroll buttons are used for scrolling.
                /// Scrolling occurs only when scroll buttons are hovered.
                /// "edge" - Scrolling occurs when the mouse is moving to
                /// the edge of the content area.
                /// Scroll modes can be combined with each other.
                /// For example, vScrollMode: "scrollbar,scrollbuttons" will enable
                /// both a scrollbar and scroll buttons.
                /// </remarks>
                "scrollBar",
                scrollValue: /// <summary>
                /// This value determines the vertical scrolling position of
                /// wijsuperpanel.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                null,
                scrollMax: /// <summary>
                /// This value sets the maximum value of vertical scroller.
                /// Default: 100.
                /// Type: Number.
                /// </summary>
                100,
                scrollMin: /// <summary>
                /// This value sets the minimum value of vertical scroller.
                /// Default: 0.
                /// Type: Number.
                /// </summary>
                0,
                scrollLargeChange: /// <summary>
                /// This value sets the large change value of vertical scroller.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                /// <remarks>
                /// wijsuperpanel will scroll a large change when a user clicks
                /// on the tracks of scroll bars or presses left or right arrow keys
                /// on the keyboard with the shift key down.
                /// When scrollLargeChange is null, wijsuperpanel
                /// will scroll the height of content.
                /// </remarks>
                null,
                scrollSmallChange: /// <summary>
                /// This value sets the small change value of vertical scroller.
                /// Default: null.
                /// Type: Number.
                /// </summary>
                /// <remarks>
                /// wijsuperpanel will scroll a small change when a user clicks on the
                /// arrows of scroll bars, clicks or hovers scroll buttons, presses left
                /// or right arrow keys on keyboard, and hovers on the edge of
                /// wijsuperpanel.
                /// When scrollSmallChange is null, wijsuperpanel will scroll half of
                /// the height of content.
                /// </remarks>
                null,
                scrollMinDragLength: /// <summary>
                /// This value sets the minimum length, in pixel, of the vertical
                /// scroll bar thumb button.
                /// Default: 6.
                /// Type: Number
                /// </summary>
                6,
                increaseButtonPosition: /// <summary>
                /// This object determines the increase button position.
                /// Default: null.
                /// Type: Object.
                /// </summary>
                /// <remarks>
                /// Please look at the options for jquery.ui.position.js for more info.
                /// </remarks>
                null,
                decreaseButtonPosition: /// <summary>
                /// This object determines the decrease button position.
                /// Default: 0.
                /// Type: Object.
                /// </summary>
                /// <remarks>
                /// Please look at the options for jquery.ui.position.js for more info.
                /// </remarks>
                null,
                hoverEdgeSpan: /// <summary>
                /// This value sets the width of horizontal hovering edge
                /// which will trigger the vertical scrolling.
                /// Default: 20.
                /// Type: Number.
                /// </summary>
                20,
                firstStepChangeFix: /// <summary>
                /// The value to add to small change or largechange when scrolling
                /// the first step(scrolling from value 0).
                /// Default: 0.
                /// Type: Number.
                /// </summary>
                0
            },
            customScrolling: /// <summary>
            /// Determines if use custom scrolling.
            /// Default: false.
            /// Type: Boolean.
            /// </summary>
            false,
            listenContentScroll: /// <summary>
            /// Determines.
            /// Default: false.
            /// Type: Boolean.
            /// </summary>
            false
        });
        $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
    } else {
        var scrollerHandle = "wijmo-wijsuperpanel-handle", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer'>" + "<div class='wijmo-wijsuperpanel-contentwrapper-touch'>" + "</div></div>";
        wijsuperpanel.prototype = $.extend(true, {
        }, $.Widget.prototype, {
            widgetEventPrefix: "wijsuperpanel",
            _setOption: function (key, value) {
                var self = this, o = self.options, f = self._fields();
                if(key === "animationOptions" || key === "resizableOptions") {
                    value = $.extend(o[key], value);
                } else if(key === "hScroller" || key === "vScroller") {
                    value = $.extend(o[key], value);
                    self.refresh();
                }
                $.Widget.prototype._setOption.apply(self, arguments);
                switch(key) {
                    case "allowResize":
                        self._initResizer();
                        break;
                    case "disabled":
                        self._handleDisabledOption(value, self.element);
                        break;
                    case "mouseWheelSupport":
                    case "keyboardSupport":
                        self._bindElementEvents(self, f, self.element, o);
                        break;
                }
            },
            _create: function () {
                var self = this, o = self.options;
                o.vScroller.dir = "v";
                o.hScroller.dir = "h";
                self._createDom();
                if(self.options.disabled) {
                    self.disable();
                }
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self.refresh();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijsuperpanel");
                }
            },
            _handleDisabledOption: function (disabled, ele) {
                var self = this;
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo("body");
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                }
            },
            _createDisabledDiv: function (outerEle) {
                var self = this, ele = outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                return $("<div></div>").addClass("ui-disabled").css({
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top
                });
            },
            _createDom: function () {
                var self = this, el = self.element;
                self.paintPanel();
                self._initResizer();
                self._bindElementEvents();
            },
            _applyOverflow: function (stateContainer) {
                var css = {
                }, o = this.options, hs = o.hScroller.scrollBarVisibility, vs = o.vScroller.scrollBarVisibility;
                css["overflow-x"] = hs;
                css["overflow-y"] = vs;
                stateContainer.css(css);
            },
            _createAdditionalDom: function (self, f, ele) {
                if(!ele.attr("tabindex")) {
                    ele.attr("tabindex", "-1");
                    f.tabindex = true;
                }
                var stateContainer = f.stateContainer = $(innerElementHtml), templateW;
                self._applyOverflow(f.stateContainer);
                // move child element to content wrapper div of wijsuperpanel.
                f.contentWrapper = stateContainer.children();
                ele.contents().each(function (index, el) {
                    var jel = $(el);
                    if(jel.hasClass("wijmo-wijsuperpanel-header")) {
                        f.header = jel;
                        return;
                    }
                    if(jel.hasClass("wijmo-wijsuperpanel-footer")) {
                        f.footer = jel;
                        return;
                    }
                    f.contentWrapper[0].appendChild(el);
                });
                // append header to first element.
                if(f.header !== undefined) {
                    ele.prepend(f.header);
                }
                ele[0].appendChild(stateContainer[0]);
                // append footer to first element.
                if(f.footer !== undefined) {
                    f.footer.insertAfter(stateContainer);
                }
                self._resetDom();
            },
            _bindElementEvents: function () {
                var self = this, ele = self.element, o = self.options, wn = self.widgetName;
                ele.bind("scroll", function (event) {
                    self._triggerScroll();
                });
                if(o.keyboardSupport) {
                    if(self._keyboardBind === undefined) {
                        self._keyboardBind = true;
                        ele.bind("keydown." + wn, self, self._panelKeyDown);
                    }
                } else {
                    ele.unbind("keydown." + wn, self._panelKeyDown);
                    self._keyboardBind = undefined;
                }
                if(!o.mouseWheelSupport) {
                    ele.bind("mousewheel", function (event) {
                        event.stopPropagation();
                        return false;
                    });
                }
            },
            _setScrollingInterval: function (f, dir, self, large) {
                var o = self.options;
                if(dir.length > 0) {
                    f.internalFuncID = window.setInterval(function () {
                        self._doScrolling(dir, self, large);
                    }, o.keyDownInterval);
                }
            },
            _triggerScroll: function (contentLeft, dir) {
                var data = {
                    position: contentLeft,
                    dir: dir
                };
                this._trigger("scroll", null, data);
            },
            _panelKeyDown: function (e) {
                // Key down handler.
                                var self = e.data, o = self.options, shift, keycode, kCode = self.getKeyCodeEnum();
                if(!o.keyboardSupport || o.disabled) {
                    return;
                }
                shift = e.shiftKey;
                keycode = e.keyCode;
                if(keycode === kCode.LEFT) {
                    self._doScrolling("left", self, shift);
                } else if(keycode === kCode.RIGHT) {
                    self._doScrolling("right", self, shift);
                } else if(keycode === kCode.UP) {
                    self._doScrolling("top", self, shift);
                } else if(keycode === kCode.DOWN) {
                    self._doScrolling("bottom", self, shift);
                }
                e.stopPropagation();
                e.preventDefault();
            },
            _doScrolling: function (dir, self, large) {
                var value, orient, func, f = self._fields(), ele = f.stateContainer[0], animateOpt = {
                }, scrollVal;
                if(dir === "top" || dir === "bottom") {
                    orient = "v";
                    func = "scrollTop";
                } else if(dir === "left" || dir === "right") {
                    orient = "h";
                    func = "scrollLeft";
                }
                if(large) {
                    value = self._getLargeChange(orient);
                } else {
                    value = self._getSmallChange(orient);
                }
                scrollVal = ele[func];
                if(dir === "top" || dir === "left") {
                    animateOpt[func] = scrollVal - value;
                } else {
                    animateOpt[func] = scrollVal + value;
                }
                self._animateTo(animateOpt);
            },
            _getLargeChange: function (div) {
                var self = this, f = self._fields(), largeChange, length = div == "h" ? f.clientWidth : f.clientHeight;
                if(length) {
                    largeChange = length;
                } else {
                    largeChange = f.stateContainer[div == "h" ? "width" : "height"]();
                }
                return largeChange;
            },
            _getSmallChange: function () {
                return this._getLargeChange() / 2;
            },
            _setRounder: function (self, ele) {
                var cornerCSS = this.options.wijCSS.cornerAll;
                if(this.options.showRounder) {
                    ele.addClass(cornerCSS);
                    if(self._rounderAdded) {
                        return;
                    }
                    if($.browser.msie) {
                        return;
                    }
                    var key1, key, value, border;
                    key1 = key = "";
                    if($.browser.webkit) {
                        key = "WebkitBorderTopLeftRadius";
                        key1 = "WebkitBorderRadius";
                    } else if($.browser.mozilla) {
                        key = "MozBorderRadiusBottomleft";
                        key1 = "MozBorderRadius";
                    } else {
                        key = "border-top-left-radius";
                        key1 = "border-radius";
                    }
                    value = ele.css(key);
                    border = parseInt(value, 10);
                    ele.css(key1, border + 1);
                    self._rounderAdded = true;
                    self._radiusKey = key1;
                } else {
                    ele.removeClass(cornerCSS);
                }
            },
            _initResizer: function () {
                // Initialize reseizer of wijsuperpanel.
                                var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                if(!$.fn.resizable) {
                    return;
                }
                if(!resizer && o.allowResize) {
                    resizableOptions = o.resizableOptions;
                    oldstop = resizableOptions.stop;
                    resizableOptions.stop = function (e) {
                        self._resetDom();
                        self._trigger("resized");
                        if($.isFunction(oldstop)) {
                            oldstop(e);
                        }
                    };
                    f.resizer = resizer = self.element.resizable(resizableOptions);
                }
                if(!o.allowResize && f.resizer) {
                    resizer.resizable("destroy");
                    f.resizer = null;
                }
            },
            _resetDom: function () {
                var self = this, o = self.options, ele = self.element, f = self._fields(), width = ele.width(), height = ele.height();
                if(f.stateContainer.length) {
                    f.stateContainer.css({
                        width: width,
                        height: height
                    });
                    f.clientWidth = f.stateContainer[0].clientWidth;
                    f.clientHeight = f.stateContainer[0].clientHeight;
                }
            },
            _fields: function () {
                var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                if(d === undefined) {
                    d = {
                    };
                    ele.data(key, d);
                    self._fieldsStore = d;
                }
                return d;
            },
            _getScrollOffset: function (child1) {
                var child = $(child1), f, cWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = {
                    left: null,
                    top: null
                };
                if(child.length === 0) {
                    return result;
                }
                f = this._fields();
                cWrapper = f.contentWrapper;
                //cWrapper = f.stateContainer;
                childOffset = child.offset();
                childOffset.leftWidth = childOffset.left + child.outerWidth();
                childOffset.topHeight = childOffset.top + child.outerHeight();
                cWrapperOffset = cWrapper.offset();
                cWrapperOffset.leftWidth = cWrapperOffset.left + f.clientWidth;
                cWrapperOffset.topHeight = cWrapperOffset.top + f.clientHeight;
                lDistance = childOffset.left - cWrapperOffset.left;
                if(childOffset.left < cWrapperOffset.left) {
                    result.left = lDistance;
                } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                    rDistance = childOffset.leftWidth - cWrapperOffset.left - f.clientWidth;
                    if(lDistance < rDistance) {
                        result.left = lDistance;
                    } else {
                        result.left = rDistance;
                    }
                }
                tDistance = childOffset.top - cWrapperOffset.top;
                if(childOffset.top < cWrapperOffset.top) {
                    result.top = tDistance;
                } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                    bDistance = childOffset.topHeight - cWrapperOffset.top - f.clientHeight;
                    if(tDistance < bDistance) {
                        result.top = tDistance;
                    } else {
                        result.top = bDistance;
                    }
                }
                return result;
            },
            _initialize: function (f, ele, self) {
                var wijCSS = self.options.wijCSS;
                f.initialized = true;
                ele.addClass([
                    "wijmo-wijsuperpanel", 
                    wijCSS.widget, 
                    wijCSS.content
                ].join(' '));
                self._setRounder(self, ele);
                self._createAdditionalDom(self, f, ele);
                self._trigger("painted");
            },
            _animateTo: function (to) {
                var self = this, ele = self.element, o = self.options, ao = o.animationOptions, f = self._fields();
                f.stateContainer.animate(to, ao);
            },
            destroy: function () {
                var self = this, ele = self.element, o = self.options, f = self._fields(), cWrapper, wijCSS = o.wijCSS;
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                if(f.resizer !== undefined) {
                    f.resizer.resizable("destroy");
                }
                ele.unbind("." + self.widgetName);
                ele.removeClass([
                    "wijmo-wijsuperpanel", 
                    wijCSS.widget, 
                    wijCSS.content, 
                    wijCSS.cornerAll
                ].join(' '));
                cWrapper = f.contentWrapper;
                cWrapper.contents().each(function (index, e) {
                    ele.append(e);
                });
                f.stateContainer.remove();
                $.Widget.prototype.destroy.apply(self, arguments);
            },
            doScrolling: function (dir, large) {
                /// <summary>
                /// Do scrolling.
                /// </summary>
                /// <param name="dir" type="string">
                ///   Scrolling direction. Options are: "left", "right", "top" and "bottom".
                /// </param>
                /// <param name="large" type="Boolean">
                /// Whether to scroll a large change.
                /// </param>
                this._doScrolling(dir, large);
            },
            paintPanel: function (unfocus) {
                var self = this, ele = self.element, f = self._fields();
                if(!f.initialized) {
                    this._initialize(f, ele, self);
                }
            },
            needToScroll: function (child1) {
                /// <summary>
                /// Determine whether scoll the child DOM element to view
                /// need to scroll the scroll bar
                /// </summary>
                /// <param name="child" type="DOMElement/JQueryObj">
                /// The child to scroll to.
                /// </param>
                var offset = this._getScrollOffset(child1);
                return offset.top !== null || offset.left !== null;
            },
            scrollChildIntoView: function (child1) {
                /// <summary>
                /// Scroll children DOM element to view.
                /// </summary>
                /// <param name="child" type="DOMElement/JQueryObj">
                /// The child to scroll to.
                /// </param>
                                var offset = this._getScrollOffset(child1), left = offset.left, top = offset.top;
                this.scrollTo(left, top);
            },
            getContentElement: function () {
                /// <summary>
                /// Gets the content element of wijsuperpanel.
                /// </summary>
                /// <returns type="JQueryObj" />
                return this._fields().contentWrapper;
            },
            hScrollTo: function (x) {
                /// <summary>
                /// Scroll to horizontal position.
                /// </summary>
                /// <param name="x" type="Number">
                /// The position to scroll to.
                /// </param>
                this._animateTo({
                    "scrollLeft": x
                });
            },
            vScrollTo: function (y) {
                /// <summary>
                /// Scroll to vertical position.
                /// </summary>
                /// <param name="y" type="Number">
                /// The position to scroll to.
                /// </param>
                this._animateTo({
                    "scrollTop": y
                });
            },
            refresh: function () {
                /// <summary>
                /// Refreshes wijsuperpanel.
                /// Needs to be called after content being changed.
                /// </summary>
                /// <returns type="Boolean">
                /// Returns true if it is successful, else returns false.
                /// </returns>
                                var self = this, f = self._fields();
                self._applyOverflow(f.stateContainer);
                self._resetDom();
            },
            scrollTo: function (x, y) {
                /// <summary>
                /// Scroll to specified position.
                /// </summary>
                /// <param name="x" type="Number">
                /// Horizontal position to scroll to.
                /// </param>
                /// <param name="y" type="Number">
                /// Vertical position to scroll to.
                /// </param>
                this._animateTo({
                    "scrollTop": y,
                    "scrollLeft": x
                });
            },
            scrollPxToValue: function (px, dir) {
                /// <summary>
                /// Convert pixel to scroll value.
                /// For example, wijsuperpanel scrolled 50px
                ///which is value 1 after conversion.
                /// </summary>
                /// <param name="px" type="Number">
                /// Length of scrolling.
                /// </param>
                /// <param name="dir" type="String">
                /// Scrolling direction. Options are: "h" and "v".
                /// </param>
                return px;
            }
        });
        wijsuperpanel.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, {
            wijMobileCSS: {
                header: "ui-header ui-bar-a",
                content: "ui-body-c",
                stateDefault: "ui-btn-up-c",
                stateHover: "ui-btn-down-c",
                stateActive: "ui-btn-down-c"
            },
            initSelector: /// <summary>
            /// Selector option for auto self initialization.
            ///	This option is internal.
            /// </summary>
            ":jqmData(role='wijsuperpanel')",
            allowResize: false,
            animationOptions: {
                queue: false,
                disabled: false,
                duration: 250,
                easing: undefined
            },
            hScroller: {
                scrollBarVisibility: "auto",
                scrollValue: null,
                scrollMax: 100,
                firstStepChangeFix: 0,
                scrollMin: 0,
                hoverEdgeSpan: 20
            },
            keyboardSupport: false,
            keyDownInterval: 100,
            mouseWheelSupport: true,
            resizableOptions: {
                handles: "all",
                helper: "ui-widget-content wijmo-wijsuperpanel-helper"
            },
            resized: null,
            painted: null,
            scroll: null,
            showRounder: true,
            vScroller: {
                scrollBarVisibility: "auto",
                scrollValue: null,
                scrollMax: 100,
                scrollMin: 0,
                firstStepChangeFix: 0,
                hoverEdgeSpan: 20
            }
        });
        $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
    }
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery */
/*
* Depends:
*  jquery-1.4.2.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijtextbox";
    var wijtextbox = (function (_super) {
        __extends(wijtextbox, _super);
        function wijtextbox() {
            _super.apply(this, arguments);

        }
        wijtextbox.prototype._create = function () {
            var self = this, e = self.element, wijCSS = self.options.wijCSS, allowedNodes = {
                'input': true,
                'textarea': true
            }, allowedInputTypes = {
                'text': true,
                'password': true,
                'email': true,
                'url': true
            }, nodeName = e.get(0).nodeName.toLowerCase();
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(!allowedNodes.hasOwnProperty(nodeName)) {
                return;
            }
            if((nodeName === 'input') && self.element.attr("type") && !allowedInputTypes.hasOwnProperty(self.element.attr("type").toLowerCase())) {
                return;
            }
            e.addClass(wijCSS.wijtextbox).addClass(wijCSS.widget).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll);
            self.element.bind("mouseover." + self.widgetName, function () {
                e.addClass(wijCSS.stateHover);
            }).bind("mouseout." + self.widgetName, function () {
                e.removeClass(wijCSS.stateHover);
            }).bind("mousedown." + self.widgetName, function () {
                e.addClass(wijCSS.stateActive);
            }).bind("mouseup." + self.widgetName, function () {
                e.removeClass(wijCSS.stateActive);
            }).bind("focus." + self.widgetName, function () {
                e.addClass(wijCSS.stateFocus);
            }).bind("blur." + self.widgetName, function () {
                e.removeClass(wijCSS.stateFocus);
            });
            //for case 20899
            if(e.is(":disabled")) {
                self._setOption("disabled", true);
                e.addClass(wijCSS.stateDisabled);
            } else {
                self._setOption("disabled", false);
                e.removeClass(wijCSS.stateDisabled);
            }
        };
        wijtextbox.prototype.destroy = function () {
            /// Remove the functionality completely.
            /// This will return the element back to its pre-init state.
                        var self = this, wijCSS = self.options.wijCSS;
            self.element.removeClass(wijCSS.widget).removeClass(wijCSS.stateDefault).removeClass(wijCSS.cornerAll).removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive).removeClass(wijCSS.wijtextbox).unbind("." + self.widgetName);
            _super.prototype.destroy.call(this);
        };
        return wijtextbox;
    })(wijmo.wijmoWidget);
    wijmo.wijtextbox = wijtextbox;    
    wijtextbox.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijtextbox')",
        wijCSS: /// <summary>
        /// wijtextbox css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijtextbox: "wijmo-wijtextbox"
        }
    });
    $.wijmo.registerWidget(widgetName, wijtextbox.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts" />
/*globals jQuery,document,window*/
/*
* Depends:
*	jquery.js
*	jquery.ui.js
*	jquery.mousewheel.js
*	jquery.bgiframe.js
*	jquery.wijmo.wijsuperpanel.js

*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijdropdown";
    var wijdropdown = (function (_super) {
        __extends(wijdropdown, _super);
        function wijdropdown() {
            _super.apply(this, arguments);

        }
        wijdropdown.prototype._setOption = function (key, value) {
            var self = this, wijCSS = self.options.wijCSS;
            _super.prototype._setOption.call(this, key, value);
            if(key === "disabled") {
                self._labelWrap.toggleClass(wijCSS.stateDisabled, value);
                self._label.toggleClass(wijCSS.stateDisabled, value);
                self.element.attr("disabled", value ? "disabled" : "");
            }
        };
        wijdropdown.prototype._create = function () {
            var self = this, ele = self.element;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(ele.get(0).tagName.toLowerCase() !== "select") {
                return;
            }
            if(ele.is(":visible")) {
                self._activeItem = null;
                self._createSelect();
                self._bindEvents();
                self.needInit = false;
            } else {
                self.needInit = true;
            }
            //update for visibility change
            if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    self.refresh();
                    if(self.element.wijRemoveVisibilityObserver) {
                        self.element.wijRemoveVisibilityObserver();
                    }
                }, "wijdropdown");
            }
        };
        wijdropdown.prototype._createSelect = function () {
            var self = this, o = self.options, wijCSS = self.options.wijCSS, ele = self.element, width = ele.width(), eleWidth = width, selectWrap = //height = ele.height(),
            ele.wrap("<div></div>").parent().addClass(wijCSS.helperHidden), container = selectWrap.wrap("<div></div>").parent().attr("role", "select").addClass(wijCSS.wijdropdown).addClass(wijCSS.widget).addClass(//ui-widwijmo-wijdropdownt-content
            wijCSS.stateDefault).addClass(wijCSS.cornerAll).addClass(wijCSS.helperClearFix), label = $("<label></label>").addClass(wijCSS.wijdropdownLabel).addClass(wijCSS.cornerAll).attr("id", ele.get(0).id + "_select").attr("name", ele.attr("name") || ""), rightTrigger = $("<div></div>").addClass(wijCSS.wijdropdownTrigger).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerRight), labelWrap = $("<a href=\"#\"></a>"), listContainer = $("<div>").addClass(wijCSS.wijmodropdown), list = $("<ul></ul>").addClass(wijCSS.wijdropdownList).addClass(wijCSS.content).addClass(wijCSS.widget).addClass(wijCSS.cornerAll).addClass(wijCSS.helperReset).appendTo(listContainer);
            $("<span></span>").addClass(wijCSS.icon).addClass(wijCSS.iconArrowDown).appendTo(rightTrigger);
            width = Math.max(width, container.width());
            if(ele.get(0).tabIndex !== "") {
                labelWrap.attr("tabindex", ele.attr("tabindex"));
            }
            if(ele.get(0).disabled !== false) {
                self.options.disabled = true;
            }
            if(self.options.disabled) {
                labelWrap.addClass(wijCSS.stateDisabled);
                label.addClass(wijCSS.stateDisabled);
            }
            labelWrap.append(label);
            container.append(selectWrap).append(labelWrap).append(rightTrigger);
            if(o.ensureDropDownOnBody) {
                listContainer.wrap($("<div></div>").addClass(wijCSS.wijdropdown)).parent().appendTo("body").css("position", "absolute");
            } else {
                container.append(listContainer);
            }
            eleWidth += parseInt(label.css("padding-left").replace(/px/, ""), 10);
            eleWidth += parseInt(label.css("padding-right").replace(/px/, ""), 10);
            eleWidth -= 16;
            container.width(eleWidth);
            self._buildList(list, listContainer, eleWidth);
            self._rightTrigger = rightTrigger;
            self._label = label;
            self._listContainer = listContainer;
            self._list = list;
            self._value = ele.val();
            //self._selectedIndex = ele.find("option:selected").index();
            self._selectedIndex = $('option', ele).index(ele.find("option:selected"));
            self._selectWrap = selectWrap;
            self._labelWrap = labelWrap;
            self._container = container;
            //update for fixed tooltip can't take effect
            container.attr("title", ele.attr("title"));
            ele.removeAttr("title");
        };
        wijdropdown.prototype._buildList = function (list, listContainer, eleWidth) {
            var self = this, wijCSS = self.options.wijCSS, ele = self.element, height;
            listContainer.show();
            ele.children().each(function (i, n) {
                var item = $(n), group, groupText, goupItems;
                if(item.is("option")) {
                    list.append(self._buildItem(item));
                } else {
                    group = $("<li></li>").addClass(wijCSS.wijdropdownOptgroup);
                    groupText = $("<span>" + item.attr("label") + "</span>").addClass(wijCSS.wijdropdownOptgroupHeader).addClass(wijCSS.priorityPrimary);
                    goupItems = $("<ul></ul>").addClass(wijCSS.helperReset).addClass(wijCSS.wijdropdownItems);
                    item.children("option").each(function () {
                        goupItems.append(self._buildItem($(this)));
                        return this;
                    });
                    group.append(groupText).append(goupItems);
                    list.append(group);
                }
                return this;
            });
            //update for fixing height setting is incorrect when
            //execute refresh at 2011/11/30
            listContainer.height("");
            //end for height setting
            height = listContainer.height();
            height = list.outerHeight() < height ? list.outerHeight() : height;
            listContainer.css({
                height: height,
                width: eleWidth
            });
            //update for fixing can't show all dropdown items by wuhao at 2012/2/24
            //fixed the bug 30486
            //list.setOutWidth(list.parent().parent().innerWidth() - 18);
            if($.browser.msie && /^[8]\.[0-9]+/.test($.browser.version)) {
                //list.setOutWidth(list.parent().parent().innerWidth() - 19);
                list.setOutWidth(eleWidth - 19);
            } else {
                //list.setOutWidth(list.parent().parent().innerWidth() - 18);
                list.setOutWidth(eleWidth - 18);
            }
            //end for issue
            if(listContainer.data("wijmoWijsuperpanel")) {
                listContainer.wijsuperpanel("paintPanel");
                self.superpanel = listContainer.data("wijmoWijsuperpanel");
            } else {
                self.superpanel = listContainer.wijsuperpanel().data("wijmoWijsuperpanel");
            }
            if($.fn.bgiframe) {
                self.superpanel.element.bgiframe();
            }
            //update for fixing can't show all dropdown items by wuhao at 2012/2/24
            //list.setOutWidth(list.parent().parent().innerWidth());
            if(!self.superpanel.vNeedScrollBar) {
                //fixed the bug 30486
                if($.browser.msie && /^[8]\.[0-9]+/.test($.browser.version)) {
                    //list.setOutWidth(list.parent().parent().innerWidth() - 1);
                    list.setOutWidth(eleWidth - 1);
                } else {
                    //list.setOutWidth(list.parent().parent().innerWidth());
                    list.setOutWidth(eleWidth);
                }
                self.superpanel.refresh();
            }
            //end for issue
            listContainer.hide();
        };
        wijdropdown.prototype._handelEvents = function (ele) {
            var self = this, wijCSS = self.options.wijCSS, namespace = "." + self.widgetName, element = self.element;
            ele.bind("click" + namespace, function (e) {
                if(self.options.disabled) {
                    return;
                }
                if(self._listContainer.is(":hidden")) {
                    self._show();
                } else {
                    self._hide();
                }
                element.click();
                if(ele.get(0) === self._label.get(0)) {
                    e.preventDefault();
                } else {
                    self._labelWrap.focus();
                }
            }).bind("mouseover" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                self._label.addClass(wijCSS.stateHover);
                self._rightTrigger.addClass(wijCSS.stateHover);
                element.trigger('mouseover');
            }).bind("mouseout" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                self._label.removeClass(wijCSS.stateHover);
                self._rightTrigger.removeClass(wijCSS.stateHover);
                element.trigger('mouseout');
            }).bind("mousedown" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                self._label.addClass(wijCSS.stateActive);
                self._rightTrigger.addClass(wijCSS.stateActive);
                element.trigger('mousedown');
            }).bind("mouseup" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                self._label.removeClass(wijCSS.stateActive);
                self._rightTrigger.removeClass(wijCSS.stateActive);
                element.trigger('mouseup');
            });
        };
        wijdropdown.prototype._bindEvents = function () {
            var self = this, wijCSS = self.options.wijCSS, namespace = "." + self.widgetName, label = self._label, rightTrigger = self._rightTrigger, labelWrap = self._labelWrap, listContainer = self._listContainer, ele = self.element, ischrome = false, offset;
            self._handelEvents(self._label);
            self._handelEvents(self._rightTrigger);
            $(window).bind("resize", function (e) {
                self._setListContainerPosition();
            }) , $(document).bind("mouseup" + namespace, function (e) {
                if(listContainer.is(":hidden")) {
                    label.removeClass(wijCSS.stateFocus);
                    rightTrigger.removeClass(wijCSS.stateFocus);
                    return;
                }
                offset = listContainer.offset();
                if(e.target === label.get(0) || e.target === rightTrigger.get(0) || e.target === rightTrigger.children().get(0)) {
                    return;
                }
                if(e.pageX < offset.left || e.pageX > offset.left + listContainer.width() || e.pageY < offset.top || e.pageY > offset.top + listContainer.height()) {
                    label.removeClass(wijCSS.stateFocus);
                    rightTrigger.removeClass(wijCSS.stateFocus);
                    self._hide();
                }
            });
            listContainer.bind("click" + namespace, function (e) {
                var target = $(e.target);
                if(target.closest("li." + wijCSS.wijdropdownItem, $(this).get(0)).length > 0) {
                    self._setValue();
                    listContainer.css("z-index", "");
                    if($.browser.msie && /^[6,7].[0-9]+/.test($.browser.version)) {
                        listContainer.parent().css("z-index", "");
                    }
                    listContainer.hide();
                    self._setValueToEle();
                    //self.oldVal = ele.val();
                    //ele.val(self._value);
                    //if (self.oldVal !== self._value) {
                    //	ele.trigger("change");
                    //}
                                    }
                ele.click();
            });
            labelWrap.bind("keydown" + namespace, function (e) {
                if(self.options.disabled) {
                    return;
                }
                var keyCode = $.ui.keyCode;
                switch(e.which) {
                    case keyCode.UP:
                    case keyCode.LEFT:
                        self._previous();
                        self._setValue();
                        //update for issue that can't get value with keydown
                        //by wh at 2012/1/19
                        self._setValueToEle();
                        //end for issue about keydown
                        break;
                    case keyCode.DOWN:
                    case keyCode.RIGHT:
                        self._next();
                        self._setValue();
                        //update for issue that can't get value with keydown
                        //by wh at 2012/1/19
                        self._setValueToEle();
                        //end for issue about keydown
                        break;
                    case keyCode.PAGE_DOWN:
                        self._nextPage();
                        self._setValue();
                        //update for issue that can't get value with keydown
                        //by wh at 2012/1/19
                        self._setValueToEle();
                        //end for issue about keydown
                        break;
                    case keyCode.PAGE_UP:
                        self._previousPage();
                        self._setValue();
                        //update for issue that can't get value with keydown
                        //by wh at 2012/1/19
                        self._setValueToEle();
                        //end for issue about keydown
                        break;
                    case keyCode.ENTER:
                    case keyCode.NUMPAD_ENTER:
                        self._setValue();
                        self._listContainer.hide();
                        //update for issue that can't get value with keydown
                        //by wh at 2012/1/19
                        self._setValueToEle();
                        //end for issue about keydown
                        break;
                }
                if(e.which !== keyCode.TAB) {
                    e.preventDefault();
                }
                ele.trigger('keydown');
            }).bind("focus" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                label.addClass(wijCSS.stateFocus);
                rightTrigger.addClass(wijCSS.stateFocus);
                ele.focus();
            }).bind("blur" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                label.removeClass(wijCSS.stateFocus);
                rightTrigger.removeClass(wijCSS.stateFocus);
                ele.trigger('blur');
            }).bind("keypress" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                ele.trigger('keypress');
            }).bind("keyup" + namespace, function () {
                if(self.options.disabled) {
                    return;
                }
                ele.trigger('keyup');
            });
            ischrome = /chrome/.test(navigator.userAgent.toLowerCase());
            if(ischrome || $.browser.safari) {
                labelWrap.bind("click" + namespace, function () {
                    labelWrap.focus();
                });
                rightTrigger.bind("mouseout" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    label.removeClass(wijCSS.stateFocus);
                    rightTrigger.removeClass(wijCSS.stateFocus);
                });
            }
        };
        wijdropdown.prototype._setListContainerPosition = function () {
            var self = this, o = self.options, _offset;
            if(!o.ensureDropDownOnBody) {
                return;
            }
            _offset = self._container.offset();
            self._listContainer.parent().offset({
                left: _offset.left,
                top: _offset.top + self._container.outerHeight()
            });
        };
        wijdropdown.prototype._init = function () {
            var self = this;
            self._initActiveItem();
            if(self._activeItem) {
                self._label.text(self._activeItem.text());
            }
        };
        wijdropdown.prototype._buildItem = function ($item) {
            var val = $item.val(), text = $item.text(), self = this, wijCSS = self.options.wijCSS, $li;
            if(text === "") {
                text = "&nbsp;";
            }
            $li = $("<li></li>").addClass(wijCSS.wijdropdownItem).addClass(wijCSS.cornerAll).append($("<span>" + text + "</span>")).mousemove(function (event) {
                var current = $(event.target).closest("." + wijCSS.wijdropdownItem);
                if(current !== this.last) {
                    self._activate($(this));
                }
                this.last = $(event.target).closest("." + wijCSS.wijdropdownItem);
            }).attr("role", "option");
            $li.data("value", val);
            return $li;
        };
        wijdropdown.prototype._show = function () {
            var self = this, listContainer = self._listContainer, showingAnimation = self.options.showingAnimation;
            self._setListContainerPosition();
            listContainer.css("z-index", "100000");
            if($.browser.msie && /^[6,7]\.[0-9]+/.test($.browser.version)) {
                listContainer.parent().css("z-index", "99999");
            }
            if(showingAnimation) {
                //update for fixing 20652 issue by wh at 2012/3/19
                //listContainer.stop().show(
                listContainer.show(//end for fixing issue 20652
                showingAnimation.effect, showingAnimation.options, showingAnimation.speed, function () {
                    self._initActiveItem();
                });
            } else {
                listContainer.show();
            }
        };
        wijdropdown.prototype._hide = function () {
            var self = this, listContainer = self._listContainer, hidingAnimation = self.options.hidingAnimation;
            if(listContainer.is(":hidden")) {
                return;
            }
            if(hidingAnimation) {
                //update for fixing 20652 issue by wh at 2012/3/19
                //listContainer.stop(false, true).hide(
                listContainer.hide(//end for fixing issue 20652
                hidingAnimation.effect, hidingAnimation.options, hidingAnimation.speed, function () {
                    if($.isFunction(hidingAnimation.callback)) {
                        hidingAnimation.callback.apply(self, arguments);
                    }
                    if($.browser.msie && /^[6,7]\.[0-9]+/.test($.browser.version)) {
                        listContainer.parent().css("z-index", "");
                    }
                    listContainer.css("z-index", "");
                });
            } else {
                if($.browser.msie && $.browser.version === "6.0") {
                    listContainer.parent().css("z-index", "");
                }
                listContainer.css("z-index", "");
                listContainer.hide();
            }
        };
        wijdropdown.prototype._setValue = function () {
            var self = this, wijCSS = self.options.wijCSS, listContainer = self._listContainer, top, height;
            if(self._activeItem) {
                self._label.text(self._activeItem.text());
                self._value = self._activeItem.data("value");
                //self._selectedIndex = self._activeItem.index();
                self._selectedIndex = $('li.' + wijCSS.wijdropdownItem, listContainer).index(self._activeItem);
                if(self.superpanel.vNeedScrollBar) {
                    top = self._activeItem.offset().top;
                    height = self._activeItem.outerHeight();
                    if(listContainer.offset().top > top) {
                        listContainer.wijsuperpanel("scrollTo", 0, top - self._list.offset().top);
                    } else if(listContainer.offset().top < top + height - listContainer.innerHeight()) {
                        listContainer.wijsuperpanel("scrollTo", 0, top + height - listContainer.height() - self._list.offset().top);
                    }
                }
            }
        };
        wijdropdown.prototype._setValueToEle = function () {
            var self = this, ele = self.element, oldSelectedItem = ele.find(":selected"), oldSelectedIndex = //oldSelectedIndex = oldSelectedItem.index(),
            $('option', ele).index(oldSelectedItem), selectedIndex = self._selectedIndex;
            //self.oldVal = ele.val();
            //ele.val(self._value);
            if(oldSelectedIndex !== selectedIndex) {
                if($.browser.mozilla) {
                    ele.val(self._value);
                }
                oldSelectedItem.removeAttr('selected');
                ele.find("option:eq(" + selectedIndex + ")").attr("selected", true);
                ele.trigger("change");
            }
            //if (self.oldVal !== self._value) {
            //	ele.trigger("change");
            //}
                    };
        wijdropdown.prototype._initActiveItem = function () {
            var self = this, wijCSS = self.options.wijCSS;
            if(self._value !== undefined) {
                if(self._selectedIndex === -1) {
                    self._activate(self._list.find("li." + wijCSS.wijdropdownItem).eq(0));
                    return;
                }
                self._list.find("li." + wijCSS.wijdropdownItem).each(function (idx) {
                    if(idx === self._selectedIndex) {
                        self._activate($(this));
                        return false;
                    }
                    //if ($(this).data("value") === self._value) {
                    //	self._activate($(this));
                    //}
                                    });
            }
        };
        wijdropdown.prototype._activate = function (item) {
            var self = this, wijCSS = self.options.wijCSS;
            self._deactivate();
            self._activeItem = item;
            self._activeItem.addClass(wijCSS.stateHover).attr("aria-selected", true);
        };
        wijdropdown.prototype._deactivate = function () {
            var self = this, wijCSS = self.options.wijCSS;
            if(self._activeItem) {
                self._activeItem.removeClass(wijCSS.stateHover).attr("aria-selected", false);
            }
        };
        wijdropdown.prototype._next = function () {
            this._move("next", "first");
        };
        wijdropdown.prototype._previous = function () {
            this._move("prev", "last");
        };
        wijdropdown.prototype._nextPage = function () {
            this._movePage("first");
        };
        wijdropdown.prototype._previousPage = function () {
            this._movePage("last");
        };
        wijdropdown.prototype.refresh = function () {
            /// Use the refresh method to set the drop-down element's style.
                        var self = this, wijCSS = self.options.wijCSS, ele = self.element, containerWidth;
            if(self.needInit) {
                if(self.element.is(":visible")) {
                    self._activeItem = null;
                    self._createSelect();
                    self._bindEvents();
                    self._init();
                    self.needInit = false;
                }
            } else {
                if(!self._list) {
                    return;
                }
                self._listContainer.show();
                //update for fixing width settings is wrong when
                //execute refresh method at 2011/11/30
                //containerWidth = self._listContainer.width();
                self._selectWrap.removeClass(wijCSS.helperHidden);
                containerWidth = self.element.width();
                containerWidth += parseInt(self._label.css("padding-left").replace(/px/, ""), 10);
                containerWidth += parseInt(self._label.css("padding-right").replace(/px/, ""), 10);
                containerWidth -= 16;
                self._container.width(containerWidth);
                self._selectWrap.addClass(wijCSS.helperHidden);
                //end for fixing width settings at 2011/11/30
                self._list.empty();
                self._buildList(self._list, self._listContainer, containerWidth);
                self._value = self.element.val();
                //self._selectedIndex = ele.find("option :selected").index();
                self._selectedIndex = $('option', ele).index(ele.find("option:selected"));
                self._initActiveItem();
                if(self._activeItem) {
                    self._label.text(self._activeItem.text());
                }
            }
        };
        wijdropdown.prototype._move = function (direction, edge) {
            var self = this, wijCSS = self.options.wijCSS, $nextLi, next;
            if(!self._activeItem) {
                self._activate(self._list.find("." + wijCSS.wijdropdownItem + ":" + edge));
                return;
            }
            $nextLi = self._activeItem[direction]().eq(0);
            if($nextLi.length) {
                next = self._getNextItem($nextLi, direction, edge);
            } else if(self._activeItem.closest("." + wijCSS.wijdropdownOptgroup).length) {
                next = self._getNextItem(self._activeItem.closest("." + wijCSS.wijdropdownOptgroup)[direction](), direction, edge);
            }
            if(next && next.length) {
                self._activate(next);
            } else {
                self._activate(self._list.find("." + wijCSS.wijdropdownItem + ":" + edge));
            }
        };
        wijdropdown.prototype._movePage = function (direction) {
            //argu: "first","last"
                        var self = this, wijCSS = self.options.wijCSS, base, height, result, antiDirection = direction === "first" ? "last" : "first";
            if(self.superpanel.vNeedScrollBar) {
                base = self._activeItem.offset().top;
                height = self.options.height;
                result = self._list.find("." + wijCSS.wijdropdownItem).filter(function () {
                    var close = $(this).offset().top - base + (direction === "first" ? -height : height) + $(this).height(), lineheight = $(this).height();
                    return close < lineheight && close > -lineheight;
                });
                if(!result.length) {
                    result = self._list.find("." + wijCSS.wijdropdownItem + ":" + antiDirection);
                }
                self._activate(result);
            } else {
                self._activate(self._list.find("." + wijCSS.wijdropdownItem + ":" + (!self._activeItem ? direction : antiDirection)));
            }
        };
        wijdropdown.prototype._getNextItem = function (next, direction, edge) {
            var wijCSS = this.options.wijCSS;
            if(next.length) {
                if(next.is("." + wijCSS.wijdropdownOptgroup)) {
                    if(!!next.find(">ul>li." + wijCSS.wijdropdownItem).length) {
                        return next.find(">ul>li." + wijCSS.wijdropdownItem + ":" + edge).eq(0);
                    } else {
                        this._getNextItem(next[direction]().eq(0));
                    }
                } else {
                    return next;
                }
            }
        };
        wijdropdown.prototype.destroy = function () {
            var self = this, wijCSS = self.options.wijCSS;
            //update for fixed tooltip can't take effect
            this.element.attr("title", this._container.attr("title"));
            /// Remove the functionality completely.
            /// This will return the element back to its pre-init state.
            this.element.closest("." + wijCSS.wijdropdown).find(">div." + wijCSS.wijdropdownTrigger + ",>div." + wijCSS.wijmodropdown + ",>a").remove();
            this._listContainer.remove();
            this.element.unwrap().unwrap().removeData("maxZIndex");
            _super.prototype.destroy.call(this);
        };
        return wijdropdown;
    })(wijmo.wijmoWidget);
    wijmo.wijdropdown = wijdropdown;    
    ;
    wijdropdown.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijdropdown')",
        wijCSS: /// <summary>
        /// wijdropdown css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijmodropdown: "wijmo-dropdown",
            wijdropdown: "wijmo-wijdropdown",
            wijdropdownLabel: "wijmo-dropdown-label",
            wijdropdownTrigger: "wijmo-dropdown-trigger",
            wijdropdownList: "wijmo-dropdown-list",
            wijdropdownOptgroup: "wijmo-dropdown-optgroup",
            wijdropdownOptgroupHeader: "wijmo-optgroup-header",
            wijdropdownItems: "wijmo-dropdown-items",
            wijdropdownItem: "wijmo-dropdown-item"
        },
        zIndex: 1000,
        showingAnimation: {
            effect: "blind"
        },
        hidingAnimation: {
            effect: "blind"
        },
        ensureDropDownOnBody: /// <summary>
        /// A value indicating the dropdown element will be append to the body or dropdown container.
        /// If the value is true, the dropdown list will be appended to body element.
        /// else it will append to the dropdown container.
        /// Default: null.
        /// Type: Boolean.
        /// Code example: $("#tags").wijdropdown("option", "ensureDropDownOnBody", false)
        /// </summary>
        false
    });
    $.wijmo.registerWidget(widgetName, wijdropdown.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery*/
/*
* Depends:
*  jquery-1.4.2.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijcheckbox", checkboxId = 0;
    var wijcheckbox = (function (_super) {
        __extends(wijcheckbox, _super);
        function wijcheckbox() {
            _super.apply(this, arguments);

            this._csspre = "wijcheckbox";
        }
        wijcheckbox.prototype._init = function () {
            var self = this, ele = self.element, o = self.options, checkboxElement, label, targetLabel, boxElement, iconElement;
            if(ele.is(":checkbox")) {
                if(!ele.attr("id")) {
                    ele.attr("id", self._csspre + checkboxId);
                    checkboxId += 1;
                }
                if(ele.parent().is("label")) {
                    checkboxElement = ele.parent().wrap($("<div></div>").addClass(o.wijCSS.wijcheckboxInputwrapper)).parent().wrap("<div></div>").parent().addClass(o.wijCSS.wijcheckbox).addClass(o.wijCSS.widget);
                    label = ele.parent();
                    label.attr("for", ele.attr("id"));
                    checkboxElement.find("." + o.wijCSS.wijcheckboxInputwrapper).append(ele);
                    checkboxElement.append(label);
                } else {
                    checkboxElement = ele.wrap($("<div></div>").addClass(o.wijCSS.wijcheckboxInputwrapper)).parent().wrap("<div></div>").parent().addClass(o.wijCSS.wijcheckbox).addClass(o.wijCSS.widget);
                }
                targetLabel = $("label[for='" + ele.attr("id") + "']");
                if(targetLabel.length > 0) {
                    checkboxElement.append(targetLabel);
                    targetLabel.attr("labelsign", "C1");
                }
                if(ele.is(":disabled")) {
                    self._setOption("disabled", true);
                }
                boxElement = $("<div></div>").addClass(o.wijCSS.wijcheckboxBox).addClass(o.wijCSS.widget).addClass(o.disabled ? o.wijCSS.stateDisabled : o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).append($("<span></span>").addClass(o.wijCSS.wijcheckboxIcon));
                iconElement = boxElement.children("." + o.wijCSS.wijcheckboxIcon);
                checkboxElement.append(boxElement);
                ele.data("iconElement", iconElement);
                ele.data("boxElement", boxElement);
                ele.data("checkboxElement", checkboxElement);
                boxElement.removeClass(o.wijCSS.wijcheckboxRelative).attr("role", "checkbox").bind("mouseover", function () {
                    ele.mouseover(null);
                }).bind("mouseout", function () {
                    ele.mouseout(null);
                });
                if(targetLabel.length === 0 || targetLabel.html() === "") {
                    boxElement.addClass(o.wijCSS.wijcheckboxRelative);
                }
                ele.bind("click.checkbox", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    self.refresh(e);
                    self._trigger("changed", null, {
                        checked: self.options.checked
                    });
                }).bind("focus.checkbox", function () {
                    if(o.disabled) {
                        return;
                    }
                    boxElement.removeClass(o.wijCSS.stateDefault).addClass(o.wijCSS.stateFocus);
                }).bind("blur.checkbox", function () {
                    if(o.disabled) {
                        return;
                    }
                    boxElement.removeClass(o.wijCSS.stateFocus).not("." + o.wijCSS.stateHover).addClass(o.wijCSS.stateDefault);
                }).bind("keydown.checkbox", function (e) {
                    if(e.keyCode === 32) {
                        if(o.disabled) {
                            return;
                        }
                        self.refresh(null);
                    }
                });
                boxElement.bind("click.checkbox", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    ele.get(0).checked = !ele.get(0).checked;
                    ele.change();
                    ele.focus();
                    self.refresh(e);
                    self._trigger("changed", null, {
                        checked: self.options.checked
                    });
                });
                self._initCheckState();
                self.refresh(null);
                checkboxElement.bind("mouseover.checkbox", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    boxElement.removeClass(o.wijCSS.stateDefault).addClass(o.wijCSS.stateHover);
                }).bind("mouseout.checkbox", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    boxElement.removeClass(o.wijCSS.stateHover).not("." + o.wijCSS.stateFocus).addClass(o.wijCSS.stateDefault);
                });
                //update for fixed tooltip can't take effect
                checkboxElement.attr("title", ele.attr("title"));
            }
        };
        wijcheckbox.prototype._create = function () {
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
        };
        wijcheckbox.prototype._setOption = function (key, value) {
            var self = this, originalCheckedState = self.options.checked;
            _super.prototype._setOption.call(this, key, value);
            if(key === 'checked') {
                self.element.get(0).checked = value;
                self.refresh(null);
                if(originalCheckedState !== value) {
                    self._trigger("changed", null, {
                        checked: value
                    });
                }
            }
        };
        wijcheckbox.prototype._initCheckState = function () {
            var self = this, o = self.options;
            if(o.checked !== undefined && o.checked !== null) {
                self.element.get(0).checked = o.checked;
            }
        };
        wijcheckbox.prototype.refresh = function (e) {
            /// Use the refresh method to set the checkbox element's style.
                        var self = this, o = self.options;
            o.checked = self.element.get(0).checked;
            self.element.data("iconElement").toggleClass(o.wijCSS.icon + " " + o.wijCSS.iconCheck, self.element.get(0).checked);
            self.element.data("boxElement").toggleClass(o.wijCSS.stateActive, self.element.get(0).checked).attr("aria-checked", self.element.get(0).checked);
            self.element.data("checkboxElement").toggleClass(o.wijCSS.stateChecked, self.element.get(0).checked);
            if(e) {
                e.stopPropagation();
            }
        };
        wijcheckbox.prototype.destroy = function () {
            /// Remove the functionality completely.
            /// This will return the element back to its pre-init state.
                        var self = this, boxelement = self.element.parent().parent();
            boxelement.children("div." + self.options.wijCSS.wijcheckboxBox).remove();
            self.element.unwrap();
            self.element.unwrap();
            _super.prototype.destroy.call(this);
        };
        return wijcheckbox;
    })(wijmo.wijmoWidget);    
    wijcheckbox.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijcheckbox')",
        wijCSS: /// <summary>
        /// wijcheckbox css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijcheckbox: "wijmo-checkbox",
            wijcheckboxBox: "wijmo-checkbox-box",
            wijcheckboxIcon: "wijmo-checkbox-icon",
            wijcheckboxInputwrapper: "wijmo-checkbox-inputwrapper",
            wijcheckboxRelative: "wijmo-checkbox-relative"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body-c",
            stateDefault: "ui-btn-up-c",
            stateHover: "ui-btn-down-c",
            stateActive: "ui-btn-down-b"
        },
        checked: /// <summary>
        /// A value determines the checked state of the checkbox
        /// Type: Boolean.
        /// Default: null.
        /// </summary>
        null,
        changed: /// <summary>
        /// A function called when checked state is changed.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        ///  $("#tags").wijcheckbox({changed: function(e, data) {
        ///     alert("checkbox is changed to " + (data.checked ? "" : "un") + "checked");
        ///  } });
        /// Bind to the event by type: wijcheckboxchanged
        /// $("#tags").bind("wijcheckboxchanged", function(e, data) {
        ///     alert("checkbox is changed to " + (data.checked ? "" : "un") + "checked");
        /// } );
        /// </summary>
        /// <param name="e" type="EventObj">
        /// The jquery event object.
        /// </param>
        /// <param name="data" type="Object">
        /// The wijcheckbox event data, include property "checked"
        /// </param>
        null
    });
    $.wijmo.registerWidget(widgetName, wijcheckbox.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery*/
/*
* Depends:
*  jquery-1.4.2.js
* 	jquery.ui.core.js
*  jquery.ui.widget.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijradio", _radiobuttonPre = "wijmo-wijradio", radiobuttonId = 0;
    var wijradio = (function (_super) {
        __extends(wijradio, _super);
        function wijradio() {
            _super.apply(this, arguments);

        }
        wijradio.prototype._create = function () {
            var self = this, ele = self.element, wijCSS = self.options.wijCSS, eleChkState, radiobuttonElement, label, targetLabel, boxElement, iconElement;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(ele.is(":radio")) {
                if(!ele.attr("id")) {
                    ele.attr("id", "wijmo-radio-" + radiobuttonId);
                    radiobuttonId += 1;
                }
                if(ele.parent().is("label")) {
                    radiobuttonElement = ele.parent().wrap($("<div></div>").addClass(wijCSS.wijradioInputwrapper)).parent().wrap("<div></div>").parent().addClass(wijCSS.wijradio).addClass(wijCSS.widget);
                    label = ele.parent();
                    label.attr("for", ele.attr("id"));
                    radiobuttonElement.find("." + wijCSS.wijradioInputwrapper).append(ele);
                    radiobuttonElement.append(label);
                } else {
                    radiobuttonElement = ele.wrap($("<div></div>").addClass(wijCSS.wijradioInputwrapper)).parent().wrap("<div></div>").parent().addClass(wijCSS.wijradio).addClass(wijCSS.widget);
                }
                targetLabel = $("label[for='" + ele.attr("id") + "']");
                if(targetLabel.length > 0) {
                    radiobuttonElement.append(targetLabel);
                    targetLabel.attr("labelsign", "wij");
                    //targetLabel.attr("tabindex", 0);
                                    }
                if(ele.is(":disabled")) {
                    self._setOption("disabled", true);
                }
                boxElement = $("<div></div>").addClass(wijCSS.wijradioBox).addClass(wijCSS.widget).addClass(self.options.disabled ? wijCSS.stateDisabled : wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<span></span>").addClass(wijCSS.wijradioIcon));
                iconElement = boxElement.children("." + wijCSS.wijradioIcon);
                radiobuttonElement.append(boxElement);
                iconElement.addClass(wijCSS.icon).addClass(wijCSS.iconRadioOn);
                ele.data("iconElement", iconElement);
                ele.data("boxElement", boxElement);
                ele.data("radiobuttonElement", radiobuttonElement);
                boxElement.removeClass(wijCSS.wijradioRelative).attr("role", "radio").bind("mouseover", function () {
                    ele.mouseover(null);
                }).bind("mouseout", function () {
                    ele.mouseout(null);
                });
                if(targetLabel.length === 0 || targetLabel.html() === "") {
                    boxElement.addClass(wijCSS.wijradioRelative);
                }
                self._setDefaul();
                //			boxElement.css("margin-top","9px");
                ele.bind("click.radio", function () {
                    //fixed bug:
                    //the "focus()" event fires twice when the radio is clicked
                    //ele.focus();
                    if(self.options.disabled) {
                        return;
                    }
                    eleChkState = self.options.checked;
                    self._refresh();
                    if(eleChkState !== self.element.is(":checked")) {
                        self._trigger("changed", null, {
                            checked: self.options.checked
                        });
                    }
                }).bind("focus.radio", function () {
                    if(self.options.disabled) {
                        return;
                    }
                    boxElement.removeClass(wijCSS.stateDefault).addClass(wijCSS.stateFocus);
                }).bind("blur.radio", function () {
                    if(self.options.disabled) {
                        return;
                    }
                    boxElement.removeClass(wijCSS.stateFocus).not("." + wijCSS.stateHover).addClass(wijCSS.stateDefault);
                });
                radiobuttonElement.click(function () {
                    if(self.options.disabled) {
                        return;
                    }
                    if(targetLabel.length === 0 || targetLabel.html() === "") {
                        //fixed bug:
                        //the "focus()" event fires twice when the radio is clicked
                        eleChkState = self.options.checked;
                        ele.attr("checked", true);
                        //ele.attr("checked", true).focus();
                        self._refresh();
                        ele.change();
                        if(eleChkState !== self.element.is(":checked")) {
                            self._trigger("changed", null, {
                                checked: self.options.checked
                            });
                        }
                    }
                });
                radiobuttonElement.bind("mouseover.radio", function () {
                    if(self.options.disabled) {
                        return;
                    }
                    boxElement.removeClass(wijCSS.stateDefault).addClass(wijCSS.stateHover);
                }).bind("mouseout.radio", function () {
                    if(self.options.disabled) {
                        return;
                    }
                    boxElement.removeClass(wijCSS.stateHover).not("." + wijCSS.stateFocus).addClass(wijCSS.stateDefault);
                });
                //update for fixed tooltip can't take effect
                radiobuttonElement.attr("title", ele.attr("title"));
            }
        };
        wijradio.prototype._setOption = function (key, value) {
            var self = this, originalCheckedState = self.options.checked;
            _super.prototype._setOption.call(this, key, value);
            if(key === 'checked') {
                self.element.attr("checked", value);
                self._refresh();
                if(originalCheckedState !== value) {
                    self._trigger("changed", null, {
                        checked: value
                    });
                }
            }
        };
        wijradio.prototype._setDefaul = function () {
            var self = this, o = self.options;
            if(o.checked !== undefined && o.checked !== null) {
                this.element.attr("checked", o.checked);
            }
            if(this.element.attr("checked")) {
                this.element.parents("." + o.wijCSS.wijradio).find("." + o.wijCSS.wijradioBox).children().removeClass(o.wijCSS.iconRadioOn).addClass(o.wijCSS.iconRadioOff);
                this.element.data("boxElement").removeClass(o.wijCSS.stateDefault).addClass(o.wijCSS.stateActive).attr("aria-checked", true);
                this.element.data("radiobuttonElement").addClass(o.wijCSS.stateChecked);
            }
        };
        wijradio.prototype._refresh = function () {
            var name = this.element.attr("name") || "", self = this, wijCSS = self.options.wijCSS, radioEle;
            if(name === "") {
                return;
            }
            $("[name='" + name + "']").each(function (i, n) {
                $(n).parents("." + wijCSS.wijradio).find("." + wijCSS.wijradioBox).children().removeClass(wijCSS.iconRadioOff).addClass(wijCSS.iconRadioOn);
                $(n).parents("." + wijCSS.wijradio).find("." + wijCSS.wijradioBox).removeClass(wijCSS.stateActive).addClass(wijCSS.stateDefault).attr("aria-checked", false);
                $(n).parents("." + wijCSS.wijradio).removeClass(wijCSS.stateChecked);
                radioEle = $(n).parents("." + wijCSS.wijradio).find(":radio");
                if(radioEle.wijradio("option", "checked") && radioEle[0] !== self.element[0]) {
                    radioEle.wijradio("setCheckedOption", false);
                }
                return this;
            });
            if(self.element.is(":checked")) {
                self.element.data("iconElement").removeClass(wijCSS.iconRadioOn).addClass(wijCSS.iconRadioOff);
                self.element.data("boxElement").removeClass(wijCSS.stateDefault).addClass(wijCSS.stateActive).attr("aria-checked", true);
                self.element.data("radiobuttonElement").addClass(wijCSS.stateChecked);
            }
            self.options.checked = self.element.is(":checked");
        };
        wijradio.prototype.setCheckedOption = function (value) {
            var self = this, o = self.options;
            if(o.checked !== null && o.checked !== value) {
                o.checked = value;
                self._trigger("changed", null, {
                    checked: value
                });
            }
        };
        wijradio.prototype.refresh = function () {
            /// Use the refresh method to set the radio button's style.
            this._refresh();
        };
        wijradio.prototype.destroy = function () {
            /// Remove the functionality completely.
            /// This will return the element back to its pre-init state.
                        var self = this, boxelement = self.element.parent().parent();
            boxelement.children("div." + self.options.wijCSS.wijradioBox).remove();
            self.element.unwrap();
            self.element.unwrap();
            _super.prototype.destroy.call(this);
        };
        return wijradio;
    })(wijmo.wijmoWidget);
    wijmo.wijradio = wijradio;    
    wijradio.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijradio')",
        wijCSS: /// <summary>
        /// wijradio css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijradio: "wijmo-wijradio",
            wijradioBox: "wijmo-wijradio-box",
            wijradioIcon: "wijmo-wijradio-icon",
            wijradioInputwrapper: "wijmo-wijradio-inputwrapper",
            wijradioRelative: "wijmo-wijradio-relative"
        },
        checked: /// <summary>
        /// A value determines the checked state of the radio
        /// Type: Boolean.
        /// Default: null.
        /// </summary>
        null,
        changed: /// <summary>
        /// A function called when checked state is changed.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        ///  $("#tags").wijradio({changed: function(e, data) { } });
        /// Bind to the event by type: wijradiochanged
        /// $("#tags").bind("wijradiochanged", function(e, data) {} );
        /// </summary>
        /// <param name="e" type="EventObj">
        /// The jquery event object.
        null
    });
    $.wijmo.registerWidget(widgetName, wijradio.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../external/declarations/globalize.d.ts"/>
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
/*globals jQuery,window,document*/
/*
* Depends:
*     jquery.ui.core.js
*     jquery.ui.widget.js
*     jquery.wijmo.wijtooltip.js
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijlist";
    //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    var listItemCSS = "wijmo-wijlist-item", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    listItemCSSAlternate = listItemCSS + "-alternate", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    listItemCSSSelected = listItemCSS + "-selected", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    listItemCSSFirst = listItemCSS + "-first", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    listItemCSSLast = listItemCSS + "-last", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    activeItem = //stateHover = "ui-state-hover",
    //uiStateActive = "ui-state-active",
    "wijmo-wijlistitem-active", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
    itemKey = //selectedActive = listItemCSSSelected + " " + uiStateActive,
    "item.wijlist";
    var wijlist = (function (_super) {
        __extends(wijlist, _super);
        function wijlist() {
            _super.apply(this, arguments);

        }
        wijlist.prototype.removeAll = function () {
            ///	<summary>
            ///	The method removes all items in the wijlist.
            /// Code example: $("#element").wijlist("removeAll");
            ///	</summary>
            var self = this;
            self.items = [];
            self._refresh();
        };
        wijlist.prototype.addItem = function (item, index) {
            ///	<summary>
            ///	Add the specified item into the list by index.
            /// Code example: $("#element")
            ///				.wijlist("addItem", {label: "label1", value: "value1"});
            ///	</summary>
            /// <param name="item" type="Object">
            /// The item that need to be inserted.
            /// </param>
            /// <param name="index" type="Number">
            /// The position of the inserted item.
            /// </param>
            var self = this;
            self._checkData();
            if(index === null || index === undefined) {
                self.items.push(item);
            } else {
                if(self.items) {
                    self.items.splice(index, 0, item);
                }
            }
            self._refresh();
        };
        wijlist.prototype.removeItem = function (item) {
            ///	<summary>
            ///	Remove the specified item from the wijlist.
            /// Code example: $("#element")
            ///		.wijlist("removeItem", {label: "label1", value: "value1"});
            ///	</summary>
            /// <param name="item" type="Object">
            /// Indicates the item to be removed.
            /// </param>
                        var self = this, index;
            self._checkData();
            index = self.indexOf(item);
            if(index >= 0) {
                self.removeItemAt(index);
            }
        };
        wijlist.prototype.indexOf = function (item) {
            ///	<summary>
            ///	Return the index of the specified list item.
            /// Code example: $("#element")
            ///			.wijlist("indexOf", {label: "label1", value: "value1"});
            ///	</summary>
            /// <param name="item" type="Object">
            /// Indicates the specified item.
            /// </param>
                        var self = this, index = -1, i = 0, oItem;
            self._checkData();
            for(i = 0; i < self.items.length; i++) {
                oItem = self.items[i];
                if(oItem.label === item.label && oItem.value === item.value) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        wijlist.prototype.findIndexByLabel = function (label) {
            /// <summary>
            /// Allows the user to find the index of first matched list item by item's label.
            /// Return the index of first matched list item.
            /// If there is no matched list item, it will return -1.
            /// Code Example:$("#element").wijlist("findIndexByLabel","label");
            /// </summary>
            /// <param name="label" type="String">
            /// Indicates the specified item's label that used to search.
            /// </param>
                        var self = this, index = -1, i = 0, oItem;
            if(label === null || label === undefined) {
                return index;
            }
            self._checkData();
            for(i = 0; i < self.items.length; i++) {
                oItem = self.items[i];
                if(oItem.label === label) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        wijlist.prototype.removeItemAt = function (index) {
            ///	<summary>
            ///	Remove the specified item by index from the wijlist widget.
            /// Code example: $("#element").wijlist("removeItemAt", 3);
            ///	</summary>
            /// <param name="item" type="Object">
            /// Index of the item to be removed.
            /// </param>
            var self = this;
            self._checkData();
            self.items.splice(index, 1);
            self._refresh();
        };
        wijlist.prototype._checkData = function () {
            var self = this;
            if(!self.items) {
                self.items = [];
            }
        };
        wijlist.prototype._refresh = function () {
            var self = this;
            self.renderList();
            self.refreshSuperPanel();
        };
        wijlist.prototype._setOption = function (key, value) {
            var self = this, selectedItem, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, ulOuterHeight, isBind, renderItems;
            //$.wijmo.widget.prototype._setOption.apply(self, arguments);
            _super.prototype._setOption.call(this, key, value);
            if(key === "disabled") {
                self._handleDisabledOption(value, self.element);
            } else if(key === "selectionMode") {
                selectedItem = self.selectedItem;
                if(selectedItem) {
                    selectedItem.selected = false;
                    if(selectedItem.element) {
                        selectedItem.element.removeClass(selectedActive);
                    }
                    self.selectedItem = undefined;
                }
                if(self.selectedItems) {
                    $.each(self.selectedItems, function (index, i) {
                        i.selected = false;
                        i.element.removeClass(selectedActive);
                    });
                }
                self.selectedItem = [];
            } else if(key === "listItems") {
                isBind = self._isBind();
                if(isBind) {
                    renderItems = self._getRenderItems();
                    self.setItems(renderItems);
                } else {
                    self.setItems(value);
                }
                self.renderList();
                self.refreshSuperPanel();
            } else if(key === "dataSource") {
                isBind = self._isBind();
                if(isBind) {
                    renderItems = self._getRenderItems();
                    self.setItems(renderItems);
                    self.renderList();
                    self.refreshSuperPanel();
                }
            } else if(key === "autoSize" || key === "maxItemsCount") {
                if(!self.options.autoSize && self.element.is(":visible")) {
                    if(self._oriHeight !== 0) {
                        self.element.height(self._oriHeight);
                    } else {
                        ulOuterHeight = self.ul.outerHeight();
                        self.element.height(ulOuterHeight);
                        $(".wijmo-wijsuperpanel-statecontainer", self.element).height(ulOuterHeight);
                        $(".wijmo-wijsuperpanel-contentwrapper", self.element).height(ulOuterHeight);
                    }
                }
                self.refreshSuperPanel();
            }
        };
        wijlist.prototype._create = function () {
            var self = this, ele = this.element, o = this.options, wijCSS = o.wijCSS, listCSS = wijCSS.widget + " " + wijCSS.content + " " + wijCSS.cornerAll + " wijmo-wijlist", renderItems;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            self._oriHeight = parseInt(ele.css("height"), 10);
            ele.addClass(listCSS).attr({
                role: "listbox",
                "aria-activedescendant": activeItem,
                "aria-multiselectable": o.selectionMode === "multiple"
            }).bind("click." + self.widgetName, self, self._onListClick);
            if(ele.is("div") && ele.children().is("ul")) {
                self._isInnerData = true;
                self._templates = [];
                $.each($("ul > li", ele), function (idx, liNode) {
                    self._templates.push({
                        templateHtml: liNode.innerHTML
                    });
                });
                self._oriChildren = ele.children().hide();
            }
            self.ul = $("<ul class='wijmo-wijlist-ul'></ul>").appendTo(ele);
            if(o.listItems !== null) {
                renderItems = self._getRenderItems();
                if(renderItems) {
                    self.setItems(renderItems);
                    self.renderList();
                    self.refreshSuperPanel();
                }
            }
            //update for visibility change
            if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    self.refreshSuperPanel();
                    if(self.element.wijRemoveVisibilityObserver) {
                        self.element.wijRemoveVisibilityObserver();
                    }
                }, "wijlist");
            }
            if(o.disabled) {
                self.disable();
                self._handleDisabledOption(true, self.element);
            }
        };
        wijlist.prototype._isBind = function () {
            var o = this.options, listItems = o.listItems;
            if(listItems !== null && listItems.label && listItems.label.bind) {
                return true;
            }
            return false;
        };
        wijlist.prototype._getRenderItems = function () {
            var o = this.options, listItems = o.listItems;
            if(listItems !== null) {
                if($.isArray(listItems) && listItems.length > 0 && typeof (listItems[0].label) === "string") {
                    return listItems;
                } else if(listItems.label && listItems.label.bind) {
                    return this._getMappingItems();
                } else {
                    return null;
                }
            }
            return null;
        };
        wijlist.prototype._getMappingItems = function () {
            var o = this.options, dataSource = o.dataSource, listItems = o.listItems, mappingItems, labelKey, valueKey;
            if(!dataSource || !listItems) {
                return null;
            }
            if(!listItems.label || !listItems.label.bind || !listItems.value || !listItems.value.bind) {
                return null;
            }
            labelKey = listItems.label.bind;
            valueKey = listItems.value.bind;
            //1.Array
            if(dataSource && dataSource.length !== 0) {
                mappingItems = [];
                $.each(dataSource, function (i, item) {
                    mappingItems.push({
                        label: item[labelKey],
                        value: item[valueKey]
                    });
                });
                return mappingItems;
            }
            return null;
        };
        wijlist.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                self.disabledDiv.appendTo("body");
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
            }
        };
        wijlist.prototype._createDisabledDiv = function (outerEle) {
            var self = this, ele = outerEle || self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
            return $("<div></div>").addClass("ui-disabled").css({
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top,
                "pointer-events": "auto"
            });
        };
        wijlist.prototype.setTemplateItems = function (data) {
            this._setItemsByExtend(data, true);
        };
        wijlist.prototype.setItems = function (items) {
            ///	<summary>
            ///	Sets Items to be rendered by the wijlist widget.
            /// This will return the element back to its pre-init state.
            /// Code example: $("#element")
            ///		.wijlist("setItems",{label: "label1", value: "value1"});
            ///	</summary>
            /// <param name="items" type="Array">
            /// Items to be rendered by the wijlist.
            /// </param>
            this._setItemsByExtend(items, false);
        };
        wijlist.prototype._setItemsByExtend = function (items, isExtend) {
            /// <summary>
            /// Sets Items to be rendered by the wijlist.
            /// </summary>
            /// <param name="items" type="Array">
            /// Items array to be rendered.  The array contains object like
            ///{label: "label", value: "value"}.
            /// </param>
                        var self = this, selectedItems;
            if(isExtend) {
                //update for 24130 issue at 2012/7/20
                //first load the items by keydown, the
                //items.length will not be equal self._templates.length
                if(self._templates && items && items.length !== self._templates.length) {
                    return;
                }
                self.items = items;
                //end
                if(!self.items) {
                    self.items = [];
                }
                $.each(self._templates, function (idx) {
                    if(self.items[idx]) {
                        self.items[idx].templateHtml = self._templates[idx].templateHtml;
                    } else {
                        self.items.push({
                            templateHtml: self._templates[idx].templateHtml,
                            label: items[idx].label,
                            value: items[idx].value
                        });
                    }
                });
            } else {
                self.items = items;
            }
            if(!items) {
                return null;
            }
            selectedItems = $.grep(items, function (a) {
                return a.selected;
            }, undefined);
            if(self.options.selectionMode === "single") {
                self.selectedItems = [];
                self.selectedItem = selectedItems.length > 0 ? selectedItems[0] : undefined;
            } else {
                self.selectedItems = selectedItems;
            }
        };
        wijlist.prototype.filterItems = function (searchTerm, autoFilter, needHighlightMatching, hightWord) {
            var self = this, term1 = self._escapeRegex(searchTerm), matcher, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, priorityPrimary = self.options.wijCSS.priorityPrimary, label, liText = '', itemsChanged = false, topHit = null;
            /// TODO : start with or contains and case sensitive.
            if(!this.items) {
                return null;
            }
            if($("li[wijhidden].wijmo-wijlist-item", self.element) && $("li[wijhidden].wijmo-wijlist-item", self.element).length > 0) {
                itemsChanged = true;
            }
            if($("span." + priorityPrimary, self.element) && $("span." + priorityPrimary, self.element).length > 0) {
                itemsChanged = true;
            }
            if(!itemsChanged && (!searchTerm || searchTerm.length === 0)) {
                $.each(this.items, function (index, item) {
                    if(item.selected) {
                        self.activate(null, item, false);
                        if(item.element) {
                            item.element.addClass(selectedActive);
                        }
                        self.selectedItem = item;
                    } else {
                        if(item.element && item.element.hasClass(selectedActive)) {
                            item.element.removeClass(selectedActive);
                        }
                    }
                });
                return;
            }
            matcher = new RegExp(term1, "i");
            $.each(this.items, function (index, item) {
                label = item.label;
                // if text is set, text will override label value.
                if(item.templateHtml) {
                    label = item.templateHtml;
                } else if(item.text !== undefined) {
                    label = item.text;
                }
                /* remove the code the close the dropdown list
                * when close the dropdown list, all items need to
                * restore original style, see resetItemsStyle*/
                if($("span." + priorityPrimary, item.element).length > 0) {
                    item.element.empty().append(label);
                }
                //filter still use the item.label;
                var matchResult = matcher.exec(item.label);
                if(matchResult === null && autoFilter) {
                    if(item.element) {
                        item.element.hide();
                        item.element.attr("wijhidden", "wijhidden");
                    }
                } else {
                    // update for: when using the key to active the item
                    // the active item is incorrect at 2012/8/13
                    if(item.selected) {
                        self.activate(null, item, false);
                        if(item.element) {
                            item.element.addClass(selectedActive);
                        }
                        self.selectedItem = item;
                    } else {
                        if(item.element && item.element.hasClass(selectedActive)) {
                            item.element.removeClass(selectedActive);
                        }
                    }
                    if(needHighlightMatching) {
                        liText = label.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term1 + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<span class='" + priorityPrimary + "'>$1</span>");
                        if(item.element) {
                            item.element.html(liText);
                        }
                    }
                    if(item.element && !item.element.is(":visible")) {
                        item.element.show();
                        item.element.removeAttr("wijhidden");
                    }
                    //update for 25224 issue at 2012/8/13
                    if(term1 !== undefined && term1.length !== 0 && topHit === null && matchResult && matchResult.index === 0) {
                        //self.activate(null, item, true);
                        topHit = item;
                    }
                }
            });
            return topHit;
        };
        wijlist.prototype.popItem = function () {
            ///	<summary>
            ///	Remove the last item in the wijlist.
            /// Code example: $("#element").wijlist("popItem");
            ///	</summary>
            var self = this;
            self._checkData();
            self.items.pop();
            self._refresh();
        };
        wijlist.prototype.getList = function () {
            /// <summary>
            /// Gets the JQuery object reference of the <ul> element of the wijlist widget.
            /// Code example: $("#element").wijlist("getList");
            /// </summary>
            /// <returns type="JQueryObj">
            /// ul JQuery reference.
            /// </returns>
            return this.ul;
        };
        wijlist.prototype._onListClick = function (e) {
            var self = e.data;
            if(self.options.disabled) {
                return;
            }
            if(!$(e.target).closest(".wijmo-wijlist-item").length) {
                return;
            }
            self.select(e);
        };
        wijlist.prototype.destroy = function () {
            ///	<summary>
            ///	Remove the wijlist functionality completely.
            /// This will return the element back to its pre-init state.
            /// Code example: $("#element").wijlist("destroy");
            ///	</summary>
                        var self = this, ele = this.element, o = this.options, wijCSS = o.wijCSS, listCSS = wijCSS.widget + " " + wijCSS.content + " " + wijCSS.cornerAll + " wijmo-wijlist";
            if(self.superPanel !== undefined) {
                self.superPanel.destroy();
            }
            ele.removeClass("wijmo-wijobserver-visibility").removeClass(listCSS).removeAttr("role").removeAttr("aria-activedescendant").unbind("." + self.widgetName);
            self.ul.remove();
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            if(self._isInnerData) {
                self._oriChildren.show();
            }
            // $.wijmo.widget.prototype.destroy.apply(self, arguments);
            _super.prototype.destroy.call(this);
        };
        wijlist.prototype.activate = function (event, item, scrollTo) {
            ///	<summary>
            ///	The method activates an item in the wijlist and will allow the list to scrollTo the item.
            /// Code example:
            /// var item = {element:$(".wijmo-wijlist-item:first"),list:$("#list")
            ///			.wijlist()};
            /// $("#element").wijlist("activate", null, item, false);
            ///	</summary>
            /// <param name="event" type="EventObject">
            /// Event will raise activation.
            /// </param>
            /// <param name="item" type="wijlistItem">
            /// wijlistItem to activate.
            ///	</param>
            /// <param name="scrollTo" type="Boolean">
            /// Whether to scroll activated item to view.
            ///	</param>
                        var self = this, active, activeElement;
            self.deactivate();
            if(item === null || item === undefined) {
                return;
            }
            if(self._trigger("focusing", event, item) === false) {
                return;
            }
            active = self.active = item;
            activeElement = item.element;
            if(activeElement) {
                if(self.options.addHoverItemClass) {
                    activeElement.addClass(self.options.wijCSS.stateHover);
                }
                activeElement.attr("id", activeItem);
            }
            if(scrollTo && self.superPanel !== undefined) {
                self.superPanel.scrollChildIntoView(activeElement);
            }
            if(self.element.is(":visible")) {
                self._trigger("focus", event, item);
            }
        };
        wijlist.prototype.deactivate = function () {
            /// <summary>
            /// Deactivates activated items in the wijlist widget.
            /// Code example: $("#element").wijlist("deactivate");
            /// </summary>
                        var self = this, a = self.active, ele;
            if(!a) {
                return;
            }
            ele = a.element;
            self._trigger("blur", null, a);
            if(ele) {
                ele.removeClass(self.options.wijCSS.stateHover).removeAttr("id");
            }
            self.active = undefined;
        };
        wijlist.prototype.next = function (event) {
            /// <summary>
            /// Moves focus to the next item.
            /// Code example: $("#element").wijlist("next");
            /// </summary>
            /// <param name="event" type="EventObject">
            /// Event will raise activation.
            /// </param>
            this.move("next", "." + listItemCSS + ":first", event);
        };
        wijlist.prototype.nextPage = function () {
            /// <summary>
            /// Turns to the next page of the list.
            /// Code example: $("#element").wijlist("nextPage");
            /// </summary>
            this.superPanel.doScrolling("bottom", true);
        };
        wijlist.prototype.previous = function (event) {
            /// <summary>
            /// Moves focus to the previous item.
            /// Code example: $("#element").wijlist("previous");
            /// </summary>
            /// <param name="event" type="EventObject">
            /// Event will raise activation.
            /// </param>
            this.move("prev", "." + listItemCSS + ":last", event);
        };
        wijlist.prototype.previousPage = function () {
            /// <summary>
            /// Turns to the previous page of the wijlist.
            /// Code example: $("#element").wijlist("previousPage");
            /// </summary>
            this.superPanel.doScrolling("top", true);
        };
        wijlist.prototype.first = function () {
            /// <summary>
            /// Tests that the focus is at the first list item.
            /// Code example: $("#element").wijlist("first");
            /// </summary>
            return this.active && !this.active.element.prev().length;
        };
        wijlist.prototype.last = function () {
            /// <summary>
            /// Tests that the focus is at the last list item.
            /// Code example: $("#element").wijlist("last");
            /// </summary>
            return this.active && !this.active.element.next().length;
        };
        wijlist.prototype.move = function (direction, edge, event) {
            /// <summary>
            /// Move focus between items.
            /// </summary>
                        var self = this, item, next;
            if(!self.active) {
                item = self.ul.children(":visible" + edge).data(itemKey);
                self.activate(event, item, true);
                return;
            }
            next = self.active.element[direction + "All"](":visible." + listItemCSS).eq(0);
            /*
            if (!self._templates) {
            next = self.active.element[direction + "All"]("." + listItemCSS).eq(0);
            } else {
            //add for only visible item will be moved
            next = self.active.element[direction + "All"](":visible." + listItemCSS).eq(0);
            }*/
            if(next.length) {
                self.activate(event, next.data(itemKey), true);
            } else {
                self.activate(event, self.element.children(edge).data(itemKey), true);
            }
        };
        wijlist.prototype.select = function (event, data) {
            /// <summary>
            /// Selects active list item.
            /// </summary>
            ///
                        var self = this, ele, selectedIndex, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, item, singleMode, previous;
            if(self.active === undefined) {
                self.active = $($(event.target).closest(".wijmo-wijlist-item")).data(itemKey);
                if(self.active === undefined) {
                    return;
                }
            }
            ele = self.active.element;
            if(ele === undefined || ele.attr("wijhidden")) {
                return;
            }
            item = ele.data(itemKey);
            if(!item) {
                return;
            }
            //end
            singleMode = self.options.selectionMode === "single";
            if(singleMode) {
                previous = self.selectedItem;
                ele.addClass(selectedActive).attr("aria-selected", "true");
                item.selected = true;
                if(previous !== undefined && item !== previous) {
                    previous.selected = false;
                    if(previous.element) {
                        previous.element.removeClass(selectedActive).removeAttr("aria-selected");
                    }
                }
                self.selectedItem = item;
                selectedIndex = $.inArray(item, self.items);
                self._trigger("selected", event, {
                    item: item,
                    previousItem: previous,
                    selectedIndex: selectedIndex,
                    data: data
                });
            } else {
                item.selected = !item.selected;
                if(item.selected) {
                    ele.addClass(selectedActive).attr("aria-selected", "true");
                } else {
                    ele.removeClass(selectedActive).removeAttr("aria-selected", "true");
                }
                selectedIndex = [];
                self.selectedItems = $.grep(self.items, function (a, index) {
                    if(a.selected) {
                        selectedIndex.push(index);
                    }
                    return a.selected;
                }, undefined);
                self._trigger("selected", event, {
                    selectedIndex: selectedIndex,
                    item: item,
                    selectedItems: self.selectedItems
                });
            }
        };
        wijlist.prototype._findItemsByValues = function (values) {
            var itemFound, found = [];
            found = $.grep(this.items, function (itm, i) {
                itemFound = false;
                for(var j = 0; j < values.length; j++) {
                    if(itm.value === values[j]) {
                        itemFound = true;
                    }
                }
                return itemFound;
            }, undefined);
            return found;
        };
        wijlist.prototype._findItemsByIndices = function (indices) {
            var self = this, len = this.items.length, found = [];
            $.each(indices, function (index, value) {
                if(value >= 0 && value < len) {
                    found.push(self.items[value]);
                }
            });
            return found;
        };
        wijlist.prototype.getItems = function (indices, byIndex) {
            /// <summary>
            /// Allows the user to find list items by indices or values.
            /// Code Example:$("#element").wijlist("getItems",5);
            /// </summary>
            /// <param name="indices" type="Array/Number/String">
            /// This parameter could be a string, number, array of string,
            /// array of number.
            /// </param>
            /// <param name="byIndex" type="Boolean">
            /// Indicates the indices parameter is indices or values of items.
            /// If true, it's used as the index/indices of the item(s) to get.
            /// If false, it's used as the value/values of the item(s) to get.
            /// </param>
                        var self = this, isNumber, byArray, searchTerms, foundItems;
            byArray = $.isArray(indices);
            isNumber = (!byArray) && typeof (indices) === "number" || (byArray && typeof (indices[0]) === "number");
            searchTerms = byArray ? indices : [
                indices
            ];
            if(!byIndex) {
                foundItems = self._findItemsByValues(searchTerms);
            } else {
                if(!isNumber) {
                    return null;
                }
                foundItems = self._findItemsByIndices(searchTerms);
            }
            return foundItems;
        };
        wijlist.prototype.selectItems = function (indices, triggerSelected, byIndex) {
            /// <summary>
            /// Selects item(s) in the list by item index/indices or value(s).
            /// Code Example:$("#element").wijlist("selectItems",5, false, true);
            /// </summary>
            /// <param name="indices" type="Array/Number/String">
            /// This parameter could be a string, number, array of string,
            /// array of number.
            /// </param>
            /// <param name="triggerSelected" type="Boolean">
            /// Whether to trigger selected event of list.
            /// </param>
            /// <param name="byIndex" type="Boolean">
            /// Indicates the indices parameter is indices or values of items.
            /// If true, it's used as the index/indices of the item(s) to get.
            /// If false, it's used as the value/values of the item(s) to get.
            /// </param>
                        var self = this, singleMode = this.options.selectionMode === "single", selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, item, previous, foundItems;
            foundItems = self.getItems(indices, byIndex);
            if(singleMode) {
                if(foundItems.length > 0) {
                    item = foundItems[0];
                    item.selected = true;
                    item.element.addClass(selectedActive);
                }
                previous = self.selectedItem;
                if(previous) {
                    previous.selected = false;
                    previous.element.removeClass(selectedActive);
                }
                self.selectedItem = item;
                if(triggerSelected) {
                    self._trigger("selected", null, {
                        item: item,
                        previousItem: previous
                    });
                }
            } else {
                $.each(foundItems, function (index, itm) {
                    itm.selected = true;
                    itm.element.addClass(selectedActive);
                });
                self.selectedItems = $.grep(self.items, function (a) {
                    return a.selected;
                }, undefined);
                if(triggerSelected) {
                    self._trigger("selected", null, {
                        selectedItems: self.selectedItems
                    });
                }
            }
        };
        wijlist.prototype.unselectItems = function (indices) {
            /// <summary>
            /// Unselects list items by items' indices.
            /// Code Example:$("#element").wijlist("unselectItems",5);
            /// </summary>
            /// <param name="indices" type="Array">
            /// Indices of items to unselect.
            /// </param>
                        var self = this, mode = this.options.selectionMode, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, selectedItem, foundItems;
            if(mode === "single") {
                selectedItem = self.selectedItem;
                if(selectedItem) {
                    selectedItem.selected = false;
                    selectedItem.element.removeClass(selectedActive);
                    self.selectedItem = undefined;
                }
            } else {
                foundItems = self.getItems(indices, true);
                if(!foundItems || foundItems.length === 0) {
                    return;
                }
                $.each(foundItems, function (index, i) {
                    i.selected = false;
                    i.element.removeClass(selectedActive);
                });
                self.selectedItems = $.grep(self.items, function (a) {
                    return a.selected;
                }, undefined);
            }
        };
        wijlist.prototype.renderList = function () {
            /// <summary>
            /// Render the wijlist widget on the client browser.
            /// Code Example:$("#element").wijlist("renderList");
            /// </summary>
                        var self = this, ul = this.ul, o = this.options, items, count, singleMode, i, item;
            //licollection;
                        ul.empty();
            // returns if no items to render.
            items = self.items;
            if(items === undefined) {
                return;
            }
            count = items.length;
            if(items === undefined || items === null && count === 0) {
                return;
            }
            singleMode = o.selectionMode === "single";
            //for performance change
            //licollection = [];
            for(i = 0; i < count; i++) {
                item = items[i];
                //for jquery 1.9 change
                self._renderItem(ul, item, i, singleMode);
                //licollection.push(self._renderItem(ul, item, i, singleMode));
                            }
            //for jquery 1.9 change
            //for performance change
            //$(licollection).appendTo(ul);
            if(count > 0) {
                if(items[0].element) {
                    items[0].element.addClass(listItemCSSFirst);
                }
                if(items[count - 1].element) {
                    items[count - 1].element.addClass(listItemCSSLast);
                }
            }
            self._trigger("listRendered", null, self);
        };
        wijlist.prototype._renderItem = function (ul, item, index, singleMode) {
            var self = this, li = $("<li role='option' class='wijmo-wijlist-item " + self.options.wijCSS.cornerAll + "'></li>"), selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, label, url;
            item.element = li;
            item.list = self;
            if(self._trigger("itemRendering", null, item) === false) {
                return;
            }
            label = item.label;
            if(item.title) {
                li.attr("title", item.title);
            }
            // if text is set, text will override label value.
            if(item.templateHtml) {
                label = item.templateHtml;
            } else if(item.text !== undefined) {
                label = item.text;
            }
            // binds list item event
            li.bind("mouseover", function (event) {
                if(self.options.disabled) {
                    return;
                }
                self.activate(event, item, false);
            }).bind("mouseout", function () {
                if(self.options.disabled) {
                    return;
                }
                if(!self.options.keepHightlightOnMouseLeave) {
                    self.deactivate();
                }
            }).data(itemKey, item).append(label).appendTo(ul)//for jquery 1.9
            ;
            // render image
            if(!self._isInnerData) {
                // render image
                url = item.imageUrl;
                if(url !== undefined && url.length > 0) {
                    li.prepend("<img src='" + item.imageUrl + "'>");
                }
            }
            // add selected items
            if(item.selected) {
                self.activate(null, item, false);
                li.addClass(selectedActive);
            }
            if(index % 2 === 1) {
                li.addClass(listItemCSSAlternate);
            }
            self._trigger("itemRendered", null, item);
            return li;
        };
        wijlist.prototype._escapeRegex = function (value) {
            if(value === undefined) {
                return value;
            }
            return value.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1");
        };
        wijlist.prototype.adjustOptions = //update for juice
        function () {
            var o = this.options, i;
            if(o.data !== null) {
                for(i = 0; i < o.listItems.length; i++) {
                    delete o.listItems[i].element;
                    delete o.listItems[i].list;
                }
            }
            return o;
        };
        wijlist.prototype.refreshSuperPanel = function () {
            /// <summary>
            /// Reset the layout of superpanel to reflect the change in content.
            /// Code Example:$("#element").wijlist("refreshSuperPanel");
            /// </summary>
                        var self = this, ele = this.element, o = this.options, ul = this.ul, singleItem = ul.children(".wijmo-wijlist-item:first"), headerHeight, ulOuterHeight, eleInnerWidth, adjustHeight = null, h, percent, small, vScroller, large, spOptions, pt;
            if(!ele.is(":visible")) {
                return false;
            }
            ulOuterHeight = ul.outerHeight();
            eleInnerWidth = ele.innerWidth();
            if(o.autoSize) {
                adjustHeight = singleItem.outerHeight(true) * o.maxItemsCount;
            }
            if(adjustHeight !== null) {
                ele.height(Math.min(adjustHeight, ulOuterHeight));
            }
            h = ele.innerHeight();
            percent = h / (ulOuterHeight - h);
            large = (101 * percent) / (1 + percent);
            small = (singleItem.outerHeight() / (ulOuterHeight - h)) * (101 - large);
            if(self.superPanel === undefined) {
                spOptions = {
                    allowResize: false,
                    keyboardSupport: false,
                    bubbleScrollingEvent: true,
                    hScroller: {
                        scrollBarVisibility: "hidden"
                    },
                    vScroller: {
                        scrollSmallChange: small,
                        scrollLargeChange: large
                    }
                };
                $.extend(spOptions, o.superPanelOptions);
                self.superPanel = ele.wijsuperpanel(spOptions).data("wijmoWijsuperpanel");
                //update for fixing can't show all dropdown items by wuhao
                if(self.superPanel && self.superPanel.vNeedScrollBar) {
                    ul.setOutWidth(eleInnerWidth - 18);
                    self.superPanel.refresh();
                }
                //end for issue
                            } else {
                vScroller = self.superPanel.options.vScroller;
                vScroller.scrollLargeChange = large;
                vScroller.scrollSmallChange = small;
                //update for fixing can't show all dropdown items by wuhao
                self.superPanel.paintPanel();
                if(self.superPanel.vNeedScrollBar) {
                    ul.setOutWidth(eleInnerWidth - 18);
                    self.superPanel.refresh();
                } else {
                    ul.setOutWidth(ele.outerWidth());
                    headerHeight = ele.children(".wijmo-wijsuperpanel-header").outerHeight();
                    //update for case 24248 at 2012/7/27
                    //Note: not good method for doing this
                    if(headerHeight !== null && headerHeight !== undefined) {
                        ele.height(ulOuterHeight + headerHeight);
                    }
                    //end
                    self.superPanel.refresh();
                }
                //end for issue
                            }
            pt = ul.css("padding-top");
            if(pt.length > 0) {
                vScroller = self.superPanel.options.vScroller;
                vScroller.firstStepChangeFix = self.superPanel.scrollPxToValue(parseFloat(pt), "v");
            } else {
                vScroller.firstStepChangeFix = 0;
            }
            ul.setOutWidth(ul.parent().parent().innerWidth());
            //if list is disabled, adjust disabledDiv's width/height
            if(o.disabled && self.disabledDiv) {
                self.disabledDiv.css("left", ele.offset().left).css("top", ele.offset().top).css("width", ele.outerWidth()).css("height", ele.outerHeight());
            }
        };
        return wijlist;
    })(wijmo.wijmoWidget);
    wijmo.wijlist = wijlist;    
    wijlist.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body-c",
            stateDefault: "ui-btn-up-c",
            stateHover: "ui-btn-up-b",
            stateActive: "ui-btn-down-b"
        },
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijlist')",
        dataSource: /// <summary>
        /// wijdataview to which this wijlist is bound.
        /// Default: null.
        /// Type: wijdataview
        /// </summary>
        /// <remarks>
        /// This option is used if this wijlist is bound to a wijdataview.
        /// In that case, you can also specify a mapping option to
        /// select the properties to bind to,
        /// and the listItems option returns an array of objects containing
        /// value and label property values determined by that mapping.
        /// </remarks>
        null,
        listItems: /// <summary>
        /// An array that specifies the listItem collections of wijlist.
        /// Example: listItems: [{label: "label1", value: "value1"},
        ///                  {label: "label2", value: "value2"},
        ///                  {label: "label3", value: "value3"}]
        /// Default: [].
        /// Type: Array.
        /// Code example:$("#element").wijlist("option","listItems",listItems);
        /// </summary>
        [],
        selected: /// <summary>
        /// Select event handler of wijlist. A function will be called
        /// when any item in the list is selected.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a callback function to handle the selected event:
        /// $("#element").wijlist({ selected: function (e, data) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistselected", function(e, data) { });
        /// </summary>
        /// <param name="e" type="eventObj">
        /// The jquery event object.
        ///	</param>
        /// <param name="data" type="Object">
        /// By data.item to obtain the item selected.
        /// By data.item.element to obtain the li DOM element selected.
        ///	</param>
        null,
        selectionMode: /// <summary>
        /// A value indicates the list items can be single-selected or multi-selected
        /// Default: "single".
        /// Type: String.
        /// Code example:$("#element").wijlist("option","selectionMode",'single');
        /// </summary>
        /// <remarks>
        /// Options are "single" and "multiple". This option should not be set
        /// again after initialization.
        /// </remarks>
        "single",
        autoSize: /// <summary>
        /// A value determines whether to auto-size wijlist.
        /// Default: false.
        /// Type: String.
        /// Code example:$("#element").wijlist("option","autoSize",true);
        /// </summary>
        false,
        maxItemsCount: /// <summary>
        /// A value specifies the maximum number of items that will be displayed
        /// if the autoSize option is also set to true.
        /// Default: 5.
        /// Type: Number.
        /// Code example:$("#element").wijlist("option","maxItemsCount",6);
        /// </summary>
        5,
        addHoverItemClass: /// <summary>
        /// A value determines whether to add ui-state-hover class to list
        /// item when mouse enters.
        /// Default: true.
        /// Type: Boolean.
        /// Code example:$("#element").wijlist("option","addHoverItemClass",false);
        /// </summary>
        true,
        superPanelOptions: /// <summary>
        /// The option indicates the customized options of wijsuperpanel when the wijsuperpanel is created.
        /// (superpanel is container of the list, detailed options please refer the wijsuperpanel widget)
        /// Default: null.
        /// Type: Object.
        /// Code example:$("#element").wijlist("option","superPanelOptions",null);
        /// </summary>
        null,
        disabled: /// <summary>
        /// A value indicates whether wijlist is disabled.
        /// Default: false.
        /// Type: Boolean.
        /// Code example:$("#element").wijlist("option","disabled",true);
        /// </summary>
        false,
        focusing: /// <summary>
        /// A function called when the mouse enters the item and before any
        /// logic in the hover event is processed.
        /// Default: null.
        /// Type: Function.
        /// Supply a callback function to handle the focusing event:
        /// $("#element").wijlist({ focusing: function (e, item) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistfocusing", function(e, item) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object, event object passed in to activate method.
        /// </param>
        /// <param name="item" type="Object">
        /// item to be rendered.
        /// item.element: The <LI> element with this item.
        /// item.list: The wijlist instance.
        /// item.label: The label of the item.
        /// item.value: The value of the item.
        /// item.text: could be set in handler to override rendered label of item.
        /// </param>
        /// <returns>
        /// returns false to cancel item focusing.
        /// </returns>
        null,
        focus: /// <summary>
        /// A function called when the mouse enters the item and
        /// after the hover event logic is processed
        /// Default: null.
        /// Type: Function.
        /// Supply a callback function to handle the focus event:
        /// $("#element").wijlist({ focus: function (e, item) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistfocus", function(e, item) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object, event object passed in to activate method.
        /// </param>
        /// <param name="item" type="Object">
        /// item to be rendered.
        /// item.element: The <LI> element with this item.
        /// item.list: The wijlist instance.
        /// item.label: The label of the item.
        /// item.value: The value of the item.
        /// item.text: This parameter can be set in the handler to override
        /// the rendered label of the item.
        /// </param>
        null,
        blur: /// <summary>
        /// A function called when the mouse leaves the item.
        /// Type: Function.
        /// Default: null.
        /// Supply a callback function to handle the blur event:
        /// $("#element").wijlist({ blur: function (e, item) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistblur", function(e, item) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object, event object passed in to activate method.
        /// </param>
        /// <param name="item" type="Object">
        /// item to be rendered.
        /// item.element: The <LI> element with this item.
        /// item.list: The wijlist instance.
        /// item.label: The label of the item.
        /// item.value: The value of the item.
        /// item.text: This parameter can be set in the handler to override
        /// the rendered label of the item.
        /// </param>
        null,
        itemRendering: /// <summary>
        /// A function called before an item is rendered.
        /// Default: null.
        /// Type: Function.
        /// Supply a callback function to handle the itemRendering event:
        /// $("#element").wijlist({ itemRendering: function (e, item) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistitemRendering", function(e, item) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object.
        /// </param>
        /// <param name="item" type="Object">
        /// item to be rendered.
        /// item.element: The <LI> element with this item.
        /// item.list: The wijlist instance.
        /// item.label: The label of the item.
        /// item.value: The value of the item.
        /// item.text: This parameter can be set in the handler to override
        /// the rendered label of the item.
        /// </param>
        null,
        itemRendered: /// <summary>
        /// A function called after a list item is rendered.
        /// Default: null.
        /// Type: Function.
        /// Supply a callback function to handle the itemRendered event:
        /// $("#element").wijlist({ itemRendered: function (e, item) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistitemRendered", function(e, item) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object.
        /// </param>
        /// <param name="item" type="Object">
        /// item to be rendered.
        /// item.element: The <LI> element with this item.
        /// item.list: The wijlist instance.
        /// item.label: The label of the item.
        /// item.value: The value of the item.
        /// item.text: This parameter can be set in the handler to override
        /// the rendered label of the item.
        /// </param>
        null,
        listRendered: /// <summary>
        /// A function called after list is rendered.
        /// Default: null.
        /// Type: Function.
        /// Supply a callback function to handle the listRendered event:
        /// $("#element").wijlist({ listRendered: function (e, list) { } });
        /// Bind to the event by type:
        /// $("#element").bind("wijlistlistRendered", function(e, list) { });
        /// </summary>
        /// <param name="event" type="EventObject">
        /// The jquery event object.
        /// </param>
        /// <param name="list" type="Object">
        /// The list to be rendered.
        /// </param>
        null,
        keepHightlightOnMouseLeave: /// <summary>
        /// A value determines the highlight state when the mouse leaves an item.
        /// Default: Boolean.
        /// Type: false.
        /// Code example:$("#element")
        ///		.wijlist("option","keepHightlightOnMouseLeave",true);
        /// </summary>
        false
    });
    $.wijmo.registerWidget("wijlist", wijlist.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/// <reference path="../external/declarations/globalize.d.ts"/>
/*globals jQuery,window,document*/
/*
* Depends:
*     jquery.ui.core.js
*     jquery.ui.widget.js
*     jquery.wijmo.wijtooltip.js
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijcalendar";
    var wijDayType = {
        general: ///	<summary>
        ///	A general day cell, denotes nothing.
        ///	</summary>
        0,
        weekEnd: ///	<summary>
        ///	A weekend day cell.
        ///	</summary>
        1,
        otherMonth: ///	<summary>
        ///	A day cell with a date blongs to other month.
        ///	</summary>
        2,
        outOfRange: ///	<summary>
        ///	A day cell with a date out of the minDate/maxDate range.
        ///	</summary>
        4,
        today: ///	<summary>
        ///	A day cell represents today.
        ///	</summary>
        8,
        custom: ///	<summary>
        ///	A custom day cell, which has CSS class
        /// 'wijmo-wijcalendar-customday' associated.
        ///	</summary>
        16,
        disabled: ///	<summary>
        ///	A day cell in disabled state.
        ///	</summary>
        32,
        selected: ///	<summary>
        ///	A day cell in selected state.
        ///	</summary>
        64,
        gap: ///	<summary>
        ///	A blank day cell.
        ///	</summary>
        128
    };
    var wijcalendar = (function (_super) {
        __extends(wijcalendar, _super);
        function wijcalendar() {
            _super.apply(this, arguments);

        }
        wijcalendar.prototype._create = function () {
            var self = this, wijCSS = self.options.wijCSS;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            // Add for parse date options for jUICE. D.H
            if($.isFunction(window["wijmoASPNetParseOptions"])) {
                wijmoASPNetParseOptions(this.options);
            }
            this.element.addClass("wijmo-wijcalendar  " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll).attr('role', 'grid');
            this._previewWrapper(this.options.allowPreview);
            this.element.data('preview.wijcalendar', false);
            //update for visibility change
            if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    self.refresh();
                    if(self.element.wijRemoveVisibilityObserver) {
                        self.element.wijRemoveVisibilityObserver();
                    }
                }, "wijcalendar");
            }
        };
        wijcalendar.prototype._init = function () {
            if(this.options.popupMode) {
                var po = {
                    autoHide: !!this.options.autoHide,
                    showing: undefined,
                    shown: undefined,
                    hiding: undefined,
                    hidden: undefined
                }, self = this;
                if(this.options.beforePopup) {
                    po.showing = this.options.beforePopup;
                }
                if(this.options.afterPopup) {
                    po.shown = this.options.afterPopup;
                }
                if(this.options.beforeClose) {
                    po.hiding = this.options.beforeClose;
                }
                po.hidden = function (data) {
                    self.element.removeData("lastdate.wijcalendar");
                    if(self.options.afterClose) {
                        self.options.afterClose.call(data);
                    }
                };
                this.element.wijpopup(po);
            }
            this._getSelectedDates();
            this._getDisabledDates();
            this._resetWidth();
            this.refresh();
            //this.element.width(this.element.width() + 2);
                    };
        wijcalendar.prototype.destroy = function () {
            var wijCSS = this.options.wijCSS;
            //$.wijmo.widget.prototype.destroy.apply(this, arguments);
            _super.prototype.destroy.call(this);
            this.close();
            this.element.html("");
            this.element.removeClass("wijmo-wijcalendar " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll + " " + wijCSS.datepickerMulti).removeAttr('role');
            var self = this;
            $.each([
                "preview", 
                "disableddates", 
                "selecteddates", 
                "dragging", 
                "lastdate", 
                "animating"
            ], function (i, prefix) {
                self.element.removeData(prefix + ".wijcalendar");
            });
            this._previewWrapper(false);
        };
        wijcalendar.prototype._setOption = function (key, value) {
            //$.wijmo.widget.prototype._setOption.apply(this, arguments);
            _super.prototype._setOption.call(this, key, value);
            switch(key) {
                case "showWeekDays":
                case "showWeekNumbers":
                case "showTitle":
                case "showOtherMonthDays":
                case "selectionMode":
                    this.unSelectAll();
                    this._resetWidth();
                    this.refresh();
                    break;
                case "culture":
                    this.refresh();
                    break;
                case "allowPreview":
                    this._previewWrapper(value);
                    this.refresh();
                    break;
                case "monthCols":
                    if(this._myGrid) {
                        this._myGrid = undefined;
                    }
                    this._resetWidth();
                    this.refresh();
                    break;
                case "monthRows":
                    if(this._myGrid) {
                        this._myGrid = undefined;
                    }
                    break;
                case "autoHide":
                    this.element.wijpopup({
                        autoHide: this.options.autoHide
                    });
                    break;
                case "selectedDates":
                    this._getSelectedDates().setDates(value);
                    this.refresh();
                    break;
                case "disabledDates":
                    this._getDisabledDates().setDates(value);
                    this.refresh();
                    break;
                case "displayDate":
                    this.refresh();
                    break;
            }
        };
        wijcalendar.prototype._previewWrapper = function (add) {
            if(add) {
                if(!this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                    this.element.wrap("<div class='wijmo-wijcalendar-preview-wrapper" + " " + this.options.wijCSS.helperClearFix + "'></div>");
                }
            } else {
                if(this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                    this.element.unwrap();
                }
            }
        };
        wijcalendar.prototype._isRTL = function () {
            return !!this._getCulture(null).isRTL;
        };
        wijcalendar.prototype.refresh = function () {
            /// <summary>Refreshes the calendar.</summary>
            this.element.empty().append(this._createCalendar());
            this.element[(this._isRTL() ? 'add' : 'remove') + 'Class'](this.options.wijCSS.datepickerRtl);
            if(!this.options.showTitle) {
                this.element.addClass("wijmo-wijcalendar-notitle");
            } else {
                this.element.removeClass("wijmo-wijcalendar-notitle");
            }
            this._bindEvents();
        };
        wijcalendar.prototype.refreshDate = function (date) {
            /// <summary>
            ///  Refreshes a single date.
            /// </summary>
            /// <param name="date" type="Date">The date to be refreshed.</param>
            if(!this._monthViews) {
                return;
            }
            if(date < this._groupStartDate || date > this._groupEndDate) {
                return;
            }
            $.each(this._monthViews, function () {
                this._refreshDate(date);
            });
        };
        wijcalendar.prototype.getDisplayDate = function () {
            /// <summary>Gets the valid display date.</summary>
            var d = this.options.displayDate ? this.options.displayDate : new Date();
            if(wijDateOps.isSameDate(d, new Date(1900, 0, 1))) {
                d = new Date();
            }
            return d;
        };
        wijcalendar.prototype.getSelectedDate = function () {
            /// <summary>Gets the current selected date.</summary>
            var dates = this.options.selectedDates;
            return (!dates || dates.length === 0) ? null : dates[0];
        };
        wijcalendar.prototype.selectDate = function (date) {
            /// <summary>
            ///  Select a date by code.
            /// </summary>
            /// <param name="date" type="Date">The date to be selected.</param>
            date = new Date(date);
            if(this._getDisabledDates().contains(date)) {
                return false;
            }
            if(date < this.options.minDate || date > this.options.maxDate) {
                return false;
            }
            this._getSelectedDates().add(date);
            this.refreshDate(date);
            return true;
        };
        wijcalendar.prototype.unSelectDate = function (date) {
            /// <summary>
            ///  Unselect a date by code.
            /// </summary>
            /// <param name="date" type="Date">
            /// The date to be removed from the selectedDates collection.
            /// </param>
            date = new Date(date);
            if(this._getDisabledDates().contains(date)) {
                return false;
            }
            if(date < this.options.minDate || date > this.options.maxDate) {
                return false;
            }
            this._getSelectedDates().remove(date);
            this.refreshDate(date);
            return true;
        };
        wijcalendar.prototype.unSelectAll = function () {
            /// <summary>Unselect all by code.</summary>
                        var dates = this.options.selectedDates, i;
            if(dates && dates.length > 0) {
                this._getSelectedDates().clear();
                for(i = 0; i < dates.length; i++) {
                    this.refreshDate(dates[i]);
                }
            }
        };
        wijcalendar.prototype._slideToDate = function (date) {
            if(wijDateOps.isSameMonth(this.getDisplayDate(), date)) {
                return;
            }
            var visible = this.element.is(":visible");
            if(!visible) {
                this.options.displayDate = date;
            } else {
                if(this._trigger('beforeSlide') === false) {
                    return;
                }
                if(this._isSingleMonth()) {
                    this._playSlideAnimation(date);
                } else {
                    this._playMmSlideAnimation(date);
                }
            }
        };
        wijcalendar.prototype.isPopupShowing = function () {
            /// <summary>Determines whether the calendar is in popup state.</summary>
            return !!this.options.popupMode ? this.element.wijpopup('isVisible') : false;
        };
        wijcalendar.prototype.popup = function (position) {
            /// <summary>Pops up the calendar at specifies position.</summary>
            /// <param name="position" type="Object">
            /// The position object accepts by the jQuery Position plugin.
            /// Please see "http://jqueryui.com/demos/position/" for details
            /// of the parameter.
            /// </param>
            this._myGrid = undefined;
            this.refresh();
            this.element.data('dragging.wijcalendar', false);
            if(this.element.data("wijmoWijpopup")) {
                this.element.wijpopup('show', position);
            }
        };
        wijcalendar.prototype.popupAt = function (x, y) {
            /// <summary>
            /// Pops up the calendar at the X/Y position to the document.
            /// </summary>
            /// <param name="x" type="Number">X offset.</param>
            /// <param name="y" type="Number">Y offset.</param>
            this._myGrid = undefined;
            this.refresh();
            this.element.data('dragging.wijcalendar', false);
            if(this.element.data("wijmoWijpopup")) {
                this.element.wijpopup('showAt', x, y);
            }
        };
        wijcalendar.prototype.close = function () {
            /// <summary>Close the calendar if is it in popup state.</summary>
            if(this.isPopupShowing()) {
                this.element.wijpopup('hide');
            }
        };
        wijcalendar.prototype._getCulture = function (name) {
            return Globalize.findClosestCulture(name || this.options.culture);
        };
        wijcalendar.prototype._getDates = function (token) {
            var name = token.toLowerCase() + ".wijcalendar", dates = this.element.data(name);
            if(dates === undefined) {
                dates = new wijDateCollection(this, token);
                this.element.data(name, dates);
            }
            return dates;
        };
        wijcalendar.prototype._getDisabledDates = function () {
            return this._getDates('disabledDates');
        };
        wijcalendar.prototype._getSelectedDates = function () {
            return this._getDates('selectedDates');
        };
        wijcalendar.prototype._onDayDragStart = function (e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        };
        wijcalendar.prototype._onDayMouseDown = function (e) {
            e.preventDefault();
            e.stopPropagation();
            var o = this.options, self = this, date, args, selected = false, selDates = o.selectedDates, exist = false, dates = [];
            if(e.which !== 1) {
                return false;
            }
            date = this._getCellDate(e.currentTarget);
            if(date === undefined) {
                return false;
            }
            if(!o.selectionMode.day) {
                return false;
            }
            args = {
                date: date
            };
            if(this._trigger("beforeSelect", null, args) === false) {
                return false;
            }
            if(!o.selectionMode.days || (!e.metaKey && !e.shiftKey && !e.ctrlKey)) {
                this.unSelectAll();
            }
            if(!!o.selectionMode.days) {
                if(e.shiftKey && this.element.data("lastdate.wijcalendar")) {
                    this._selectRange(this.element.data("lastdate.wijcalendar"), date, null);
                    selected = true;
                } else {
                    if(e.ctrlKey) {
                        this.element.data("lastdate.wijcalendar", date);
                        $.each(selDates, function (i, d) {
                            if(date.getFullYear() === d.getFullYear() && date.getMonth() === d.getMonth() && date.getDate() === d.getDate()) {
                                exist = true;
                                return false;
                            }
                        });
                        if(exist) {
                            this.unSelectDate(date);
                        } else {
                            this.selectDate(date);
                        }
                        selDates = o.selectedDates;
                        $.each(selDates, function (i, d) {
                            dates.push(new Date(d));
                        });
                        this._trigger('selectedDatesChanged', null, {
                            dates: dates
                        });
                        selected = true;
                    }
                }
            }
            if(!selected) {
                this.element.data("lastdate.wijcalendar", date);
                selected = this.selectDate(date);
                this._trigger('selectedDatesChanged', null, {
                    dates: [
                        date
                    ]
                });
            }
            if(selected) {
                this._trigger('afterSelect', null, args);
                if(!!o.selectionMode.days) {
                    this.element.data('dragging.wijcalendar', true);
                    $(document.body).bind("mouseup." + this.widgetName, function () {
                        $(document.body).unbind("mouseup." + self.widgetName);
                        self.element.data('dragging.wijcalendar', false);
                    });
                }
            }
            return false;
        };
        wijcalendar.prototype._onMouseUp = function (e) {
            e.preventDefault();
            e.stopPropagation();
            //var self = this;
            this.element.data('dragging.wijcalendar', false);
            return false;
        };
        wijcalendar.prototype._onDayClicked = function (e) {
            var date = this._getCellDate(e.currentTarget);
            if(date === undefined) {
                return false;
            }
            if(!this.options.selectionMode.day) {
                return false;
            }
            if(this.isPopupShowing()) {
                this.close();
            } else {
                if($(e.currentTarget).hasClass(this.options.wijCSS.datepickerOtherMonth)) {
                    this._slideToDate(date);
                }
            }
            return false;
        };
        wijcalendar.prototype._onDayMouseEnter = function (e) {
            $(e.currentTarget).attr('state', 'hover');
            this._refreshDayCell(e.currentTarget);
            if(!!this.element.data('dragging.wijcalendar')) {
                var date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return;
                }
                this.unSelectAll();
                this._selectRange(this.element.data("lastdate.wijcalendar"), date, true);
            }
        };
        wijcalendar.prototype._onDayMouseLeave = function (e) {
            $(e.currentTarget).attr('state', 'normal');
            this._refreshDayCell(e.currentTarget);
        };
        wijcalendar.prototype._selectRange = function (start, end, bymouse) {
            if(start !== undefined && start !== new Date(1900, 1, 1)) {
                var minDate = start, maxDate = end, selDates = [];
                if(start > end) {
                    maxDate = start;
                    minDate = end;
                }
                while(true) {
                    if(minDate > maxDate) {
                        break;
                    }
                    this.selectDate(minDate);
                    selDates[selDates.length] = minDate;
                    minDate = wijDateOps.addDays(minDate, 1);
                }
                if(!bymouse) {
                    this.element.removeData("lastdate.wijcalendar");
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
            } else {
                this.selectDate(start);
                this._trigger('selectedDatesChanged', null, {
                    dates: [
                        start
                    ]
                });
            }
            return true;
        };
        wijcalendar.prototype._getCellDate = function (c) {
            var d = $(c).attr('date');
            return (d === undefined) ? d : new Date(d);
        };
        wijcalendar.prototype._getParentTable = function (c) {
            var parents = $(c).parents('table');
            return (parents.length === 0) ? undefined : parents.get(0);
        };
        wijcalendar.prototype._initMonthSelector = function (ms) {
            if($(ms).data('cells') !== undefined) {
                return;
            }
            var tokens = ms.id.split('_'), monthID, monthTable, cells = [], i, j, td, dt, row;
            if(tokens[tokens.length - 1] !== 'ms') {
                throw Error["create"]('not a monthview');
            }
            monthID = (tokens.slice(0, tokens.length - 1)).join('_');
            monthTable = this._getParentTable(ms);
            if(monthTable) {
                if(monthTable.id !== monthID) {
                    throw Error["create"]('not a monthview');
                }
                for(i = 0; i < monthTable.rows.length; i++) {
                    row = monthTable.rows[i];
                    for(j = 0; j < row.cells.length; j++) {
                        td = row.cells[j];
                        if(td) {
                            dt = $(td).attr('daytype');
                            if(dt !== undefined) {
                                if($(td).find('a').hasClass(this.options.wijCSS.prioritySecondary) === false) {
                                    if(this._isSelectable(parseInt(dt, 10))) {
                                        cells[cells.length] = td;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            $(ms).data('cells', cells);
        };
        wijcalendar.prototype._onMonthSelectorClicked = function (e) {
            this._initMonthSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
            this.element.removeData("lastdate.wijcalendar");
            this.unSelectAll();
            for(i = 0; i < cells.length; i++) {
                c = cells[i];
                d = $(c).attr('date');
                if(d !== undefined) {
                    date = new Date(d);
                    this.selectDate(date);
                    selDates[selDates.length] = date;
                }
            }
            this._trigger('selectedDatesChanged', null, {
                dates: selDates
            });
            if(this.isPopupShowing()) {
                this.close();
            }
            return false;
        };
        wijcalendar.prototype._onMonthSelectorMouseEnter = function (e) {
            this._initMonthSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseEnter(e);
            }
        };
        wijcalendar.prototype._onMonthSelectorMouseLeave = function (e) {
            this._initMonthSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseLeave(e);
            }
        };
        wijcalendar.prototype._initWeekDaySelector = function (wd) {
            if($(wd).data('cells') !== undefined) {
                return;
            }
            var tokens = wd.id.split('_'), colIndex, monthID, monthTable, cells = [], i = 0, tr, td, dt;
            if(tokens[tokens.length - 2] !== 'cs') {
                throw Error["create"]('not a column');
            }
            colIndex = parseInt(tokens[tokens.length - 1], 10);
            monthID = (tokens.slice(0, tokens.length - 2)).join('_');
            monthTable = this._getParentTable(wd);
            if(monthTable) {
                if(monthTable.id !== monthID) {
                    throw Error["create"]('not a column');
                }
                /** update for issue 29995
                if (!this._isSingleMonth()) {
                i++;
                }*/
                if(this.options.showWeekDays) {
                    i++;
                }
                for(; i < monthTable.rows.length; i++) {
                    tr = monthTable.rows[i];
                    if(colIndex < tr.cells.length) {
                        td = tr.cells[colIndex];
                        if(td) {
                            dt = $(td).attr('daytype');
                            if(dt !== undefined) {
                                if($(td).find('a').hasClass(this.options.wijCSS.prioritySecondary) === false) {
                                    if(this._isSelectable(parseInt(dt, 10))) {
                                        cells[cells.length] = td;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            $(wd).data('cells', cells);
        };
        wijcalendar.prototype._onWeekDayClicked = function (e) {
            this._initWeekDaySelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
            this.unSelectAll();
            for(i = 0; i < cells.length; i++) {
                c = $(cells[i]);
                d = c.attr('date');
                if(d !== undefined) {
                    date = new Date(d);
                    this.selectDate(date);
                    selDates[selDates.length] = date;
                }
            }
            this._trigger('selectedDatesChanged', null, {
                dates: selDates
            });
            if(this.isPopupShowing()) {
                this.close();
            }
            return false;
        };
        wijcalendar.prototype._onWeekDayMouseEnter = function (e) {
            this._initWeekDaySelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseEnter(e);
            }
        };
        wijcalendar.prototype._onWeekDayMouseLeave = function (e) {
            this._initWeekDaySelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseLeave(e);
            }
        };
        wijcalendar.prototype._initWeekNumberSelector = function (wn) {
            if($(wn).data('cells') !== undefined) {
                return;
            }
            var tokens = wn.id.split('_'), rowIndex, monthID, monthTable, cells = [], tr, i, td, dt;
            if(tokens[tokens.length - 2] !== 'rs') {
                throw Error["create"]('not a row');
            }
            rowIndex = parseInt(tokens[tokens.length - 1], 10);
            monthID = (tokens.slice(0, tokens.length - 2)).join('_');
            monthTable = this._getParentTable(wn);
            if(monthTable) {
                if(monthTable.id !== monthID) {
                    throw Error["create"]('not a row');
                }
                tr = monthTable.rows[rowIndex];
                if(tr) {
                    i = 0;
                    if(this.options.showWeekNumbers) {
                        i++;
                    }
                    for(; i < tr.cells.length; i++) {
                        td = tr.cells[i];
                        if(td) {
                            dt = $(td).attr('daytype');
                            if(dt !== undefined) {
                                if($(td).find('a').hasClass(this.options.wijCSS.prioritySecondary) === false) {
                                    if(this._isSelectable(parseInt(dt, 10))) {
                                        cells[cells.length] = td;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            $(wn).data('cells', cells);
        };
        wijcalendar.prototype._onWeekNumberClicked = function (e) {
            this._initWeekNumberSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
            this.unSelectAll();
            for(i = 0; i < cells.length; i++) {
                c = $(cells[i]);
                d = c.attr('date');
                if(d !== undefined) {
                    date = new Date(d);
                    this.selectDate(date);
                    selDates[selDates.length] = date;
                }
            }
            this._trigger('selectedDatesChanged', null, {
                dates: selDates
            });
            if(this.isPopupShowing()) {
                this.close();
            }
            return false;
        };
        wijcalendar.prototype._onWeekNumberMouseEnter = function (e) {
            this._initWeekNumberSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseEnter(e);
            }
        };
        wijcalendar.prototype._onWeekNumberMouseLeave = function (e) {
            this._initWeekNumberSelector(e.currentTarget);
            var cells = $(e.currentTarget).data('cells'), i;
            for(i = 0; i < cells.length; i++) {
                e.currentTarget = cells[i];
                this._onDayMouseLeave(e);
            }
        };
        wijcalendar.prototype._isAnimating = function () {
            return !!this.element.data('animating.wijcalendar');
        };
        wijcalendar.prototype._onPreviewMouseEnter = function (e) {
            if(!!this.element.data('previewContainer')) {
                return;
            }
            if(this._isAnimating()) {
                return;
            }
            var btn = $(e.currentTarget), btnId = btn.attr('id'), mainDate = this.getDisplayDate(), wijCSS = this.options.wijCSS, months = this.options.monthCols * this.options.monthRows, previewContainer = $('<div/>');
            if(btnId === undefined) {
                return;
            }
            if(btnId === "prevPreview") {
                months = -months;
            }
            this.options.displayDate = wijDateOps.addMonths(mainDate, months);
            this.element.data('preview.wijcalendar', true);
            previewContainer.appendTo(document.body);
            previewContainer.hide();
            previewContainer.addClass('wijmo-wijcalendar ' + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll);
            previewContainer.append(this._createCalendar());
            this.options.displayDate = mainDate;
            this.element.data('preview.wijcalendar', false);
            this._createMonthViews();
            previewContainer.wijpopup({
                showEffect: 'slide',
                showOptions: {
                    direction: (btnId === 'prevPreview' ? 'right' : 'left')
                },
                hideEffect: 'slide',
                hideOptions: {
                    direction: (btnId === 'prevPreview' ? 'right' : 'left')
                }
            });
            previewContainer.wijpopup('show', {
                my: (btnId === 'prevPreview' ? 'right top' : 'left top'),
                at: (btnId === 'prevPreview' ? 'left top' : 'right top'),
                of: btn
            });
            this.element.data('previewContainer', previewContainer);
        };
        wijcalendar.prototype._onPreviewMouseLeave = function (e) {
            var btn = $(e.currentTarget), btnId = btn.attr('id'), previewContainer = this.element.data('previewContainer'), self = this;
            if(btnId === undefined) {
                return;
            }
            if(previewContainer) {
                if(previewContainer.wijpopup('isAnimating')) {
                    window.setTimeout(function () {
                        self._onPreviewMouseLeave(e);
                    }, 200);
                } else {
                    previewContainer.wijpopup('hide');
                    this.element.removeData('previewContainer');
                }
            }
        };
        wijcalendar.prototype._resetWidth = function () {
            if(!this._myGrid) {
                this.element.css('height', '');
                if(this.options.monthCols > 1) {
                    this.element.css('width', 17 * this.options.monthCols + 'em');
                    this.element.addClass(this.options.wijCSS.datepickerMulti);
                } else {
                    this.element.css('width', '');
                    this.element.removeClass(this.options.wijCSS.datepickerMulti);
                }
            }
        };
        wijcalendar.prototype._playMmSlideAnimation = function (toDate) {
            var w = this.element.width(), h = this.element.height(), date = this.getDisplayDate(), curContent, newContent, goNext, direction = this.options.direction || 'horizontal', calendar = this, curContentAniOpts, newContentAniOpts;
            this.element.height(h);
            this.element.wrapInner("<div class='wijmo-wijcalendar-multi-aniwrapper'></div>");
            curContent = this.element.find('>:first-child').width(w).height(h);
            newContent = curContent.clone(false);
            newContent.hide();
            this.options.displayDate = toDate;
            this._createMonthViews();
            newContent.empty().append(this._createMonthGroup());
            newContent.appendTo(this.element);
            goNext = toDate > date;
            this.element.data('animating.wijcalendar', true);
            if($.effects) {
                curContent.effect('slide', {
                    mode: 'hide',
                    direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                    easing: this.options.easing || 'easeOutBack',
                    duration: this.options.duration
                }, function () {
                    curContent.remove();
                });
                newContent.effect('slide', {
                    direction: direction === 'horizontal' ? (goNext ? 'right' : 'left') : (goNext ? 'down' : 'up'),
                    easing: this.options.easing || 'easeOutBack',
                    duration: this.options.duration
                }, function () {
                    while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                        newContent.parent().replaceWith(newContent);
                    }
                    newContent.replaceWith(newContent.contents());
                    calendar.element.height('');
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                    calendar._trigger('afterSlide');
                });
            } else {
                if(direction === 'horizontal') {
                    curContentAniOpts = {
                        width: 0
                    };
                    newContentAniOpts = {
                        width: '100%'
                    };
                } else {
                    curContentAniOpts = {
                        height: 0
                    };
                    newContentAniOpts = {
                        height: '100%'
                    };
                }
                curContent.animate(curContentAniOpts, this.options.duration, //this.options.easing || 'easeOutBack',
                null, function () {
                    curContent.remove();
                });
                newContent.animate(newContentAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                function () {
                    while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                        newContent.parent().replaceWith(newContent);
                    }
                    newContent.replaceWith(newContent.contents());
                    calendar.element.height('');
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                    calendar._trigger('afterSlide');
                });
            }
        };
        wijcalendar.prototype._playSlideAnimation = function (toDate) {
            if(!this._isSingleMonth()) {
                return;
            }
            var self = this, date = this.getDisplayDate(), wijCSS = self.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, slideContainer, yearStep = 1, direction = this.options.direction || 'horizontal', goNext = toDate > date, months = [], w, h, wrapperAniOpts;
            if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                wrapper = curTable.parent();
            } else {
                //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' });
                wrapper = $.createWrapper(curTable).css({
                    overflow: 'hidden'
                });
                wrapper.removeClass(wijCSS.effectsWrapper);
                wrapper.addClass('wijmo-wijcalendar-aniwrapper');
            }
            if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                slideContainer = wrapper.parent();
            } else {
                //slideContainer = $.effects.createWrapper(wrapper)
                //	.css({ overflow: 'hidden' });
                slideContainer = $.createWrapper(wrapper).css({
                    overflow: 'hidden'
                });
                slideContainer.removeClass(wijCSS.effectsWrapper);
                slideContainer.addClass('wijmo-wijcalendar-aniwrapper');
            }
            if(this._myGrid) {
                switch(this._myGrid.gridType) {
                    case "month":
                        yearStep = 1;
                        break;
                    case "year":
                        yearStep = 10;
                        break;
                    case "decade":
                        yearStep = 100;
                        break;
                }
            }
            months[months.length] = toDate;
            w = curTable.outerWidth();
            h = curTable.outerHeight();
            if(direction === 'horizontal') {
                curTable.width(w).css('float', goNext ? 'left' : 'right');
                wrapper.width((months.length + 1) * w);
                wrapper.css('left', goNext ? 0 : -months.length * w).css('position', 'absolute');
            } else {
                wrapper.width(w);
                wrapper.css('top', goNext ? 0 : -months.length * h).css('position', 'absolute');
                wrapper.height((months.length + 1) * h);
            }
            $.each(months, function (index, date) {
                if(self._myGrid === undefined) {
                    var mv = new wijMonthView(self, date), $view = self._customize(mv.getHtml(true));
                    if(direction === 'horizontal') {
                        $view.width(w).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                    } else {
                        $view.appendTo(wrapper);
                    }
                } else {
                    if(direction === 'horizontal') {
                        $(self._myGrid.getHtml(date, true)).width(w).height(h).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                    } else {
                        $(self._myGrid.getHtml(date, true)).height(h).appendTo(wrapper);
                    }
                }
            });
            this.options.displayDate = toDate;
            if(this._myGrid === undefined) {
                this._createMonthViews();
            }
            this._refreshTitle();
            this.element.data('animating.wijcalendar', true);
            if($.effects) {
                wrapper.effect('slide', {
                    mode: 'hide',
                    direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                    easing: this.options.easing || 'easeOutBack',
                    distance: (direction === 'horizontal' ? w : h) * months.length,
                    duration: this.options.duration
                }, function () {
                    curTable = wrapper.children(':last');
                    while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        curTable.parent().replaceWith(curTable);
                    }
                    curTable.css({
                        'float': '',
                        'width': ''
                    });
                    self._bindEvents();
                    self.element.data('animating.wijcalendar', false);
                    self._trigger('afterSlide');
                });
            } else {
                if(direction === 'horizontal') {
                    wrapperAniOpts = {
                        width: 0
                    };
                } else {
                    wrapperAniOpts = {
                        height: 0
                    };
                }
                wrapper.animate(wrapperAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                function () {
                    curTable = wrapper.children(':last');
                    while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        curTable.parent().replaceWith(curTable);
                    }
                    curTable.css({
                        'float': '',
                        'width': ''
                    });
                    self._bindEvents();
                    self.element.data('animating.wijcalendar', false);
                    self._trigger('afterSlide');
                });
            }
        };
        wijcalendar.prototype._onTitleClicked = function () {
            if(!this.options.allowQuickPick || !this._isSingleMonth()) {
                return;
            }
            if(this._isAnimating()) {
                return;
            }
            if(this._myGrid === undefined) {
                this._myGrid = new wijMyGrid(this);
            } else {
                switch(this._myGrid.gridType) {
                    case "month":
                        this._myGrid.gridType = "year";
                        break;
                    case "year":
                        this._myGrid.gridType = "decade";
                        break;
                    case "decade":
                        return;
                }
            }
            this._refreshTitle();
            this.element.width(this.element.width()).height(this.element.height());
            var wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, nextTable, w = curTable.outerWidth(), h = curTable.outerHeight(), selIndex, row, col, toWidth, toHeight, toBounds, calendar = this;
            if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                wrapper = curTable.parent();
            } else {
                //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                wrapper = $.createWrapper(curTable).css({
                    overflow: 'hidden'
                }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper');
            }
            if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                container = wrapper.parent();
            } else {
                //container = $.effects.createWrapper(wrapper).css({ overflow: 'hidden' })
                container = $.createWrapper(wrapper).css({
                    overflow: 'hidden'
                }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
            }
            nextTable = $(this._myGrid.getHtml(true)).css({
                position: 'absolute',
                top: 0,
                left: 0,
                opacity: 0
            }).appendTo(container).height(h);
            selIndex = this._myGrid.getSelectedIndex();
            row = Math.floor(selIndex / 4);
            col = selIndex - (row * 4);
            toWidth = w / 4;
            toHeight = h / 3;
            toBounds = {
                left: toWidth * col,
                top: toHeight * row,
                width: toWidth,
                height: toHeight
            };
            curTable.width("100%").height("100%");
            wrapper.css({
                border: 'solid 1px #cccccc'
            });
            this.element.data('animating.wijcalendar', true);
            if($.effects) {
                wrapper.effect('size', {
                    to: toBounds,
                    duration: this.options.duration || 500
                }, function () {
                    wrapper.remove();
                });
            } else {
                wrapper.animate(toBounds, this.options.duration || 500, null, function () {
                    wrapper.remove();
                });
            }
            nextTable.animate({
                opacity: 1
            }, this.options.duration || 500, null, function () {
                nextTable.css({
                    position: '',
                    top: '',
                    left: '',
                    filter: ''
                });
                while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    nextTable.parent().replaceWith(nextTable);
                }
                calendar._bindEvents();
                calendar.element.data('animating.wijcalendar', false);
            });
        };
        wijcalendar.prototype._onMyGridClicked = function (e) {
            if(this._myGrid === undefined) {
                return false;
            }
            if(this._isAnimating()) {
                return false;
            }
            var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10), value = parseInt(cell.attr('value'), 10), wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, w, h, bounds, $content, date, mv, nextTable, calendar = this;
            if(this._myGrid.gridType !== "month") {
                if(!index || index === 11) {
                    return false;
                }
            }
            if(!cell.hasClass(wijCSS.stateActive)) {
                this._myGrid.select(index, value);
            }
            if(this._myGrid.gridType === "decade") {
                this._myGrid.gridType = "year";
            } else {
                if(this._myGrid.gridType === "year") {
                    this._myGrid.gridType = "month";
                } else {
                    this._myGrid = undefined;
                }
            }
            this._refreshTitle();
            w = curTable.outerWidth();
            h = curTable.outerHeight();
            if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                container = curTable.parent();
            } else {
                //container = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                container = $.createWrapper(curTable).css({
                    overflow: 'hidden'
                }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
            }
            bounds = $.extend({
            }, cell.position(), {
                width: cell.width(),
                height: cell.height()
            });
            if(this._myGrid === undefined) {
                this._createMonthViews();
                date = this.getDisplayDate();
                mv = this._getMonthView(date);
                $content = this._customize(mv.getHtml(true));
            } else {
                $content = $(this._myGrid.getHtml(true));
            }
            nextTable = $content.height(h).appendTo(container);
            //wrapper = $.effects.createWrapper(nextTable).css({ overflow: 'hidden' })
            wrapper = $.createWrapper(nextTable).css({
                overflow: 'hidden'
            }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').css($.extend(bounds, {
                border: 'solid 1px #cccccc',
                position: 'absolute'
            }));
            this.element.data('animating.wijcalendar', true);
            wrapper.animate({
                left: 0,
                top: 0,
                width: w,
                height: h
            }, this.options.duration || 500, null, function () {
                nextTable.css("width", "");
            });
            curTable.animate({
                opacity: 0
            }, this.options.duration || 500, null, function () {
                curTable.remove();
                while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    nextTable.parent().replaceWith(nextTable);
                }
                if(calendar._myGrid === undefined) {
                    calendar.element.width('').height('');
                }
                calendar._bindEvents();
                calendar.element.data('animating.wijcalendar', false);
            });
            return false;
        };
        wijcalendar.prototype._onMyGridMouseEnter = function (e) {
            if(this._myGrid === undefined) {
                return;
            }
            var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
            if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                return;
            }
            cell.addClass(this.options.wijCSS.stateHover);
        };
        wijcalendar.prototype._onMyGridMouseLeave = function (e) {
            if(this._myGrid === undefined) {
                return;
            }
            var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
            if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                return;
            }
            cell.removeClass(this.options.wijCSS.stateHover);
        };
        wijcalendar.prototype._bindEvents = function () {
            var wijCSS = this.options.wijCSS;
            if(!this.element.data('preview.wijcalendar') && !this.options.disabledState && !this.options.disabled) {
                this.element.find('div .wijmo-wijcalendar-navbutton').unbind().bind('mouseout.wijcalendar', function () {
                    var el = $(this);
                    el.removeClass(wijCSS.stateHover);
                    if(el.hasClass(wijCSS.datepickerNextHover)) {
                        el.removeClass(wijCSS.datepickerNextHover);
                    } else if(el.hasClass(wijCSS.datepickerPrevHover)) {
                        el.removeClass(wijCSS.datepickerPrevHover);
                    }
                }).bind('mouseover.wijcalendar', function () {
                    var el = $(this);
                    el.addClass(wijCSS.stateHover);
                    if(el.hasClass(wijCSS.datepickerNext)) {
                        el.addClass(wijCSS.datepickerNextHover);
                    } else if(el.hasClass(wijCSS.datepickerPrev)) {
                        el.addClass(wijCSS.datepickerPrevHover);
                    }
                }).bind('click.wijcalendar', $.proxy(this._onNavButtonClicked, this));
                this.element.unbind(".wijcalendar").bind({
                    "mouseup.wijcalendar": $.proxy(this._onMouseUp, this)
                });
                this.element.find("." + wijCSS.datepickerTitle).unbind().bind('mouseout.wijcalendar', function () {
                    $(this).removeClass(wijCSS.stateHover);
                }).bind('mouseover.wijcalendar', function () {
                    $(this).addClass(wijCSS.stateHover);
                }).bind('click.wijcalendar', $.proxy(this._onTitleClicked, this));
                this.element.find(".wijmo-wijcalendar-prevpreview-button, " + ".wijmo-wijcalendar-nextpreview-button").unbind('mouseenter.wijcalendar').unbind('mouseleave.wijcalendar').bind({
                    "mouseenter.wijcalendar": $.proxy(this._onPreviewMouseEnter, this),
                    "mouseleave.wijcalendar": $.proxy(this._onPreviewMouseLeave, this)
                });
                if(this._myGrid === undefined) {
                    this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind({
                        "click.wijcalendar": $.proxy(this._onDayClicked, this),
                        "mouseenter.wijcalendar": $.proxy(this._onDayMouseEnter, this),
                        "mouseleave.wijcalendar": $.proxy(this._onDayMouseLeave, this),
                        "mousedown.wijcalendar": $.proxy(this._onDayMouseDown, this),
                        "dragstart.wijcalendar": $.proxy(this._onDayDragStart, this)
                    });
                    if(!!this.options.selectionMode.month) {
                        this.element.find(".wijmo-wijcalendar-monthselector").unbind().bind({
                            "click.wijcalendar": $.proxy(this._onMonthSelectorClicked, this),
                            "mouseenter.wijcalendar": $.proxy(this._onMonthSelectorMouseEnter, this),
                            "mouseleave.wijcalendar": $.proxy(this._onMonthSelectorMouseLeave, this)
                        });
                    }
                    if(!!this.options.selectionMode.weekDay) {
                        this.element.find("." + wijCSS.datepickerWeekDay).unbind().bind({
                            "click.wijcalendar": $.proxy(this._onWeekDayClicked, this),
                            "mouseenter.wijcalendar": $.proxy(this._onWeekDayMouseEnter, this),
                            "mouseleave.wijcalendar": $.proxy(this._onWeekDayMouseLeave, this)
                        });
                    }
                    if(!!this.options.selectionMode.weekNumber) {
                        this.element.find(".wijmo-wijcalendar-week-num").unbind().bind({
                            "click.wijcalendar": $.proxy(this._onWeekNumberClicked, this),
                            "mouseenter.wijcalendar": $.proxy(this._onWeekNumberMouseEnter, this),
                            "mouseleave.wijcalendar": $.proxy(this._onWeekNumberMouseLeave, this)
                        });
                    }
                } else {
                    this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind({
                        "click.wijcalendar": $.proxy(this._onMyGridClicked, this),
                        "mouseenter.wijcalendar": $.proxy(this._onMyGridMouseEnter, this),
                        "mouseleave.wijcalendar": $.proxy(this._onMyGridMouseLeave, this)
                    });
                }
            }
        };
        wijcalendar.prototype._isSelectable = function (dayType) {
            var o = this.options;
            return (o.showOtherMonthDays && (dayType & wijDayType.otherMonth)) || !(dayType & (wijDayType.outOfRange | wijDayType.disabled | wijDayType.otherMonth));
        };
        wijcalendar.prototype._getCellClassName = function (dayType, date, previewMode) {
            var o = this.options, cssCell = '', cssText = o.wijCSS.stateDefault, allowSelDay = (!!o.selectionMode.day || !!o.selectionMode.days);
            previewMode = previewMode || false;
            if(!previewMode && !o.disabledState && !o.disabled && allowSelDay && this._isSelectable(dayType)) {
                cssCell += " wijmo-wijcalendar-day-selectable";
            }
            if((dayType & wijDayType.weekEnd)) {
                cssCell += ' ' + o.wijCSS.datepickerWeekEnd;
            }
            if((dayType & wijDayType.otherMonth)) {
                cssCell += ' ' + o.wijCSS.datepickerOtherMonth;
                cssText += ' ' + o.wijCSS.prioritySecondary;
            }
            if((dayType & wijDayType.outOfRange)) {
                cssCell += ' wijmo-wijcalendar-outofrangeday';
                cssText += ' ' + o.wijCSS.prioritySecondary;
            }
            if((dayType & wijDayType.gap)) {
                cssCell += ' wijmo-wijcalendar-gap';
            } else {
                if((dayType & wijDayType.disabled)) {
                    cssCell += ' ' + o.wijCSS.datepickerUnselectable;
                    cssText += ' ' + o.wijCSS.stateDisabled;
                }
                if((dayType & wijDayType.today)) {
                    cssCell += ' ' + o.wijCSS.datepickerDaysCellOver + ' ' + o.wijCSS.datepickerToday;
                    cssText += ' ' + o.wijCSS.stateHighlight;
                }
                if((dayType & wijDayType.selected) && ((dayType & (wijDayType.outOfRange | wijDayType.disabled)) === 0)) {
                    cssCell += ' ' + o.wijCSS.datepickerCurrentDay;
                    cssText += ' ' + o.wijCSS.stateActive;
                }
                if((dayType & wijDayType.gap)) {
                    cssCell += ' wijmo-wijcalendar-gap';
                }
                if((dayType & wijDayType.custom)) {
                    cssCell += ' wijmo-wijcalendar-customday';
                }
            }
            return {
                cssCell: cssCell,
                cssText: cssText
            };
        };
        wijcalendar.prototype._onNavButtonClicked = function (e) {
            if(this._isAnimating()) {
                return false;
            }
            var step = 1, btnId = $(e.currentTarget).attr('id'), date = this.getDisplayDate(), nextDate = date;
            if(this._myGrid === undefined) {
                step = btnId.indexOf('quick') >= 0 ? this.options.quickNavStep : 1;
                step = btnId.indexOf('next') >= 0 ? step : -step;
                step = step * this.options.monthRows * this.options.monthCols;
                nextDate = wijDateOps.addMonths(date, step);
            } else {
                step = btnId.indexOf('next') >= 0 ? 1 : -1;
                switch(this._myGrid.gridType) {
                    case "month":
                        nextDate = wijDateOps.addYears(date, step);
                        break;
                    case "year":
                        nextDate = wijDateOps.addYears(date, step * 10);
                        break;
                    case "decade":
                        nextDate = wijDateOps.addYears(date, step * 100);
                        break;
                }
            }
            this._slideToDate(nextDate);
            return false;
        };
        wijcalendar.prototype._getMonthGroupHtml = function () {
            var date = this.getDisplayDate(), mv, width, hw, wijCSS = this.options.wijCSS, r, c;
            if(this._isSingleMonth()) {
                mv = this._getMonthView(date);
                mv.showPreview = this.options.allowPreview && !this.element.data('preview.wijcalendar');
                return mv.getHtml();
            }
            width = 100 / this.options.monthCols + '%';
            hw = new htmlTextWriter();
            for(r = 0; r < this.options.monthRows; r++) {
                for(c = 0; c < this.options.monthCols; c++) {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerGroup + (c === 0 ? ' ' + wijCSS.datepickerGroupFirst : '') + (c === this.options.monthCols - 1 ? ' ' + wijCSS.datepickerGroupLast : ''));
                    hw.writeAttribute('style', 'width:' + width);
                    hw.writeTagRightChar();
                    mv = this._getMonthView(date);
                    mv.showPreview = false;
                    hw.write(mv.getHtml());
                    hw.writeEndTag('div');
                    date = wijDateOps.addMonths(date, 1);
                }
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.datepickerRowBreak);
                hw.writeTagRightChar();
                hw.writeEndTag('div');
            }
            return hw.toString();
        };
        wijcalendar.prototype._getCalendarHtml = function () {
            this._createMonthViews();
            var hw = new htmlTextWriter();
            hw.write(this._getMonthGroupHtml());
            return hw.toString();
        };
        wijcalendar.prototype._customizeDayCell = function ($dayCell) {
            if($dayCell.attr("state") === undefined) {
                $dayCell.attr("state", 'normal');
            }
            if($dayCell.attr("daytype") === undefined) {
                return;
            }
            if($dayCell.attr("date") === undefined) {
                return;
            }
            var dayType = parseInt($dayCell.attr("daytype"), 10), date = new Date($dayCell.attr("date")), hover = $dayCell.attr("state") === 'hover';
            this.options.customizeDate($dayCell, date, dayType, hover);
        };
        wijcalendar.prototype._customize = function (html) {
            var o = this.options, self = this, $h = $(html);
            if(!$.isFunction(o.customizeDate)) {
                return $h;
            }
            $.each($h.find('.wijmo-wijcalendar-day-selectable'), function (index, dayCell) {
                self._customizeDayCell($(dayCell));
            });
            return $h;
        };
        wijcalendar.prototype._createCalendar = function () {
            //for jquery change to 1.9 $.parseHTML
            return this._customize($($.parseHTML(this._getCalendarHtml())));
        };
        wijcalendar.prototype._createMonthGroup = function () {
            return this._customize($(this._getMonthGroupHtml()));
        };
        wijcalendar.prototype._getMonthID = function (date) {
            return date.getFullYear() + '_' + (date.getMonth() + 1);
        };
        wijcalendar.prototype._createMonthViews = function () {
            this._monthViews = {
            };
            var monthID = '', date = this.getDisplayDate(), row, col, mv, count;
            for(row = 0; row < this.options.monthRows; row++) {
                for(col = 0; col < this.options.monthCols; col++) {
                    monthID = this._getMonthID(date);
                    this._monthViews[monthID] = new wijMonthView(this, date);
                    if(row === 0) {
                        if(col === 0) {
                            this._monthViews[monthID].isFirst = true;
                        }
                        if(col === this.options.monthCols - 1) {
                            this._monthViews[monthID].isLast = true;
                        }
                    }
                    date = wijDateOps.addMonths(date, 1);
                }
            }
            date = this.getDisplayDate();
            monthID = this._getMonthID(date);
            mv = this._monthViews[monthID];
            if(mv) {
                this._groupStartDate = mv.getStartDate();
            }
            count = this.options.monthRows * this.options.monthCols;
            if(count > 1) {
                date = wijDateOps.addMonths(date, count - 1);
                monthID = this._getMonthID(date);
                mv = this._monthViews[monthID];
            }
            if(mv) {
                this._groupEndDate = mv.getEndDate();
            }
        };
        wijcalendar.prototype._getMonthView = function (date) {
            var monthID = this._getMonthID(date);
            return this._monthViews[monthID];
        };
        wijcalendar.prototype._getId = function () {
            return this.element.attr("id");
        };
        wijcalendar.prototype._getChildElement = function (id) {
            var child = this.element.find('[id*=\'' + id + '\']');
            return child.length === 0 ? undefined : child;
        };
        wijcalendar.prototype._refreshDayCell = function (dayCell) {
            var $dc = $(dayCell), o = this.options, dayType, date, hover, txt;
            if($dc.attr("state") === undefined) {
                $dc.attr("state", 'normal');
            }
            if($dc.attr("daytype") === undefined) {
                return;
            }
            if($dc.attr("date") === undefined) {
                return;
            }
            dayType = parseInt($dc.attr("daytype"), 10);
            date = new Date($dc.attr("date"));
            hover = $dc.attr("state") === 'hover';
            $dc.attr('class', this._getCellClassName(dayType, date, undefined).cssCell);
            $dc.removeAttr('aria-selected');
            if(dayType & wijDayType.selected) {
                $dc.attr('aria-selected', true);
            }
            if($.isFunction(o.customizeDate)) {
                if(this._customizeDayCell($dc)) {
                    return;
                }
            }
            txt = $dc.find('a');
            if(txt.length > 0) {
                txt.toggleClass(this.options.wijCSS.stateHover, hover);
                txt.toggleClass(this.options.wijCSS.stateActive, ((dayType & wijDayType.selected) !== 0));
            }
        };
        wijcalendar.prototype._isSingleMonth = function () {
            return this.options.monthCols * this.options.monthRows === 1;
        };
        wijcalendar.prototype._splitString = function (s, sep, count) {
            if(count === undefined) {
                return s.split(sep);
            }
            var ret = [], arr = s.split(sep), i;
            for(i = 0; i < arr.length; i++) {
                if(i >= count) {
                    ret[count - 1] = ret[count - 1] + sep + arr[i];
                } else {
                    ret.push(arr[i]);
                }
            }
            return ret;
        };
        wijcalendar.prototype._getNavButtonHtml = function (id, cls, imgClass, tooltip) {
            var hw = new htmlTextWriter();
            hw.writeBeginTag('a');
            hw.writeAttribute('id', id);
            hw.writeAttribute('class', cls);
            hw.writeAttribute('role', 'button');
            hw.writeAttribute('href', '#');
            if(tooltip) {
                hw.writeAttribute('title', tooltip);
                hw.writeAttribute('aria-label', tooltip);
            }
            hw.writeTagRightChar();
            hw.writeBeginTag('span');
            hw.writeAttribute('class', imgClass);
            hw.writeTagRightChar();
            if(tooltip) {
                hw.write(tooltip);
            }
            hw.writeEndTag('span');
            hw.writeEndTag('a');
            return hw.toString();
        };
        wijcalendar.prototype._getTitleText = // 2013-1-6
        function (monthDate) {
            if(this._myGrid !== undefined) {
                return this._myGrid.getTitle();
            } else {
                var d = monthDate || this.getDisplayDate(), f = this.options.titleFormat || 'MMMM yyyy';
                if($.isFunction(this.options.title)) {
                    return this.options.title(d, f) || this._formatDate(f, d);
                }
                return this._formatDate(f, d);
            }
        };
        wijcalendar.prototype._refreshTitle = function () {
            this.element.find('.' + this.options.wijCSS.datepickerTitle).html(this._getTitleText(undefined));
        };
        wijcalendar.prototype._fillTitle = function (hw, date) {
            var wijCSS = this.options.wijCSS;
            hw.writeBeginTag('div');
            hw.writeAttribute('class', wijCSS.datepickerTitle + ' wijmo-wijcalendar-title' + ' ' + wijCSS.stateDefault + ' ' + wijCSS.cornerAll);
            hw.writeTagRightChar();
            hw.write(this._getTitleText(date));
            hw.writeEndTag('div');
        };
        wijcalendar.prototype._getHeaderHtml = function (monthDate, prevButtons, nextButtons) {
            var previewMode = !!this.element.data('preview.wijcalendar'), wijCSS = this.options.wijCSS, buttons = previewMode ? 'none' : (this._isSingleMonth() ? this.options.navButtons : 'default'), isRTL = this.element.is('.' + wijCSS.datepickerRtl), hw = new htmlTextWriter();
            if(buttons === 'quick') {
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.header + ' wijmo-wijcalendar-header ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                hw.writeAttribute('role', 'heading');
                hw.writeTagRightChar();
                if(!!prevButtons) {
                    hw.write(this._getNavButtonHtml('quickprev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'next' : 'prev') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.quickPrevTooltip.replace('#', this.options.quickNavStep)));
                }
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.datepickerHeader + ' wijmo-wijcalendar-header-inner');
                hw.writeTagRightChar();
                if(!!prevButtons) {
                    hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + " " + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                }
                this._fillTitle(hw, monthDate);
                if(!!nextButtons) {
                    hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                }
                hw.writeEndTag('div');
                if(!!nextButtons) {
                    hw.write(this._getNavButtonHtml('quicknext', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'prev' : 'next') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.quickNextTooltip.replace('#', this.options.quickNavStep)));
                }
                hw.writeEndTag('div');
            } else {
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.datepickerHeader + ' ' + wijCSS.header + ' ' + wijCSS.datepickerHeader + ' ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                hw.writeAttribute('role', 'heading');
                hw.writeTagRightChar();
                if(buttons !== 'none' && !!prevButtons) {
                    hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                }
                this._fillTitle(hw, monthDate);
                if(buttons !== 'none' && !!nextButtons) {
                    hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + ' ' + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                }
                hw.writeEndTag('div');
            }
            return hw.toString();
        };
        wijcalendar.prototype._formatDate = function (format, date) {
            if(!wijDateOps.getTicks(date)) {
                return '&nbsp;';
            }
            return Globalize.format(date, format, this._getCulture(null));
        };
        return wijcalendar;
    })(wijmo.wijmoWidget);
    wijmo.wijcalendar = wijcalendar;    
    wijcalendar.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijcalendar')",
        wijCSS: //All CSS classes used in widgets that use jQuery UI CSS Framework
        {
            datepickerInline: "ui-datepicker-inline",
            datepicker: "ui-datepicker",
            datepickerCalendar: "ui-datepicker-calendar",
            datepickerMulti: "ui-datepicker-multi",
            datepickerRtl: "datepicker-rtl",
            datepickerOtherMonth: "ui-datepicker-other-month",
            prioritySecondary: "ui-priority-secondary",
            effectsWrapper: "ui-effects-wrapper",
            datepickerNextHover: "ui-datepicker-next-hover",
            datepickerPrevHover: "ui-datepicker-prev-hover",
            datepickerNext: "ui-datepicker-next",
            datepickerPrev: "ui-datepicker-prev",
            datepickerTitle: "ui-datepicker-title",
            datepickerWeekDay: "ui-datepicker-week-day",
            datepickerWeekEnd: "ui-datepicker-week-end",
            datepickerUnselectable: "ui-datepicker-unselectable",
            datepickerDaysCellOver: "ui-datepicker-days-cell-over",
            datepickerToday: "ui-datepicker-today",
            stateHighlight: "ui-state-highlight",
            datepickerCurrentDay: "ui-datepicker-current-day",
            datepickerGroup: "ui-datepicker-group",
            datepickerGroupFirst: "ui-datepicker-group-first",
            datepickerGroupLast: "ui-datepicker-group-last",
            datepickerRowBreak: "ui-datepicker-row-break",
            datepickerHeader: "ui-datepicker-header",
            uiIconGripDottedVertical: "ui-icon-grip-dotted-vertical",
            uiDatepickerWeekCol: "ui-datepicker-week-col"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-body ui-body-c",
            stateDefault: "ui-btn-up-c"
        },
        culture: ///	<summary>
        ///	Assigns the string value of the culture ID that appears on the calendar
        /// for the weekday and title names.
        /// Default: ''
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({culture: "zh-CN"});
        ///	</summary>
        '',
        monthCols: ///	<summary>
        ///	Gets or sets the number of calendar months in horizontal direction.
        /// Default: 1
        /// Type: Number
        /// Code example:
        ///		$(".selector").wijcalendar({monthCols: 2});
        ///	</summary>
        1,
        monthRows: ///	<summary>
        ///	Gets or sets the number of calendar months in vertical direction.
        /// Default: 1
        /// Type: Number
        /// Code example:
        ///		$(".selector").wijcalendar({monthRows: 2});
        ///	</summary>
        1,
        titleFormat: ///	<summary>
        ///	Gets or sets the format for the title text.
        /// Default: "MMMM yyyy"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({titleFormat: "MMMM yyyy"});
        ///	</summary>
        "MMMM yyyy",
        showTitle: ///	<summary>
        ///	A Boolean property that determines whether to display calendar title.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({showTitle: false});
        ///	</summary>
        true,
        displayDate: ///	<summary>
        ///	Gets or sets the display date for the first month view.
        /// Default: undefined
        /// Type: Date
        /// Code example:
        ///		$(".selector").wijcalendar({displayDate: new Date(1900,1,1)});
        ///	</summary>
        undefined,
        dayRows: ///	<summary>
        ///	Gets or sets the number of day rows that appear in the calendar.
        /// This is useful if you want to view more or less calendar days on the calendar month.
        /// Default: 6
        /// Type: Number
        /// Code example:
        ///		$(".selector").wijcalendar({dayRows: 6});
        ///	</summary>
        6,
        dayCols: ///	<summary>
        ///	Gets or sets the number of day columns that appear in the calendar.
        /// This is useful if you want to view more or less calendar days on
        /// the calendar month.
        /// Default: 7
        /// Type: Number
        /// Code example:
        ///		$(".selector").wijcalendar({dayCols: 7});
        ///	</summary>
        7,
        weekDayFormat: ///	<summary>
        ///	Gets or sets the format for the week day.
        ///	Possible values are: "short", "full", "firstLetter" or "abbreviated".
        /// Default: "short"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({weekDayFormat: "abbreviated"});
        ///	</summary>
        "short",
        showWeekDays: ///	<summary>
        ///	A Boolean property that determines whether to display week days.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({showWeekDays: false});
        ///	</summary>
        true,
        showWeekNumbers: ///	<summary>
        ///	Determines whether to display week numbers. When enabled,
        /// the week numbers appear vertically on the left side of the calendar.
        /// The week numbers represent a week number for each week in the calendar month.
        /// In the calendar year there are a total of 52 weeks so the weeknumbers will
        /// range from 1 to 52.
        /// Default: false
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({showWeekNumbers: true});
        ///	</summary>
        false,
        calendarWeekRule: ///	<summary>
        ///	Defines different rules for determining the first week of the year.
        ///	Possible values are: "firstDay", "firstFullWeek" or "firstFourDayWeek"
        /// Default: "firstDay"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({calendarWeekRule: "firstDay"});
        ///	</summary>
        "firstDay",
        minDate: ///	<summary>
        ///	Determines the minimum date to display.
        /// Default: new Date(1900, 0, 1)
        /// Type: Date
        /// Code example:
        ///		$(".selector").wijcalendar({minDate: new Date(2012, 2, 1)});
        ///	</summary>
        new Date(1900, 0, 1),
        maxDate: ///	<summary>
        ///	Determines the maximum date to display.
        /// Default: new Date(2099, 11, 31)
        /// Type: Date
        /// Code example:
        ///		$(".selector").wijcalendar({maxDate: new Date(2012, 5, 31)});
        ///	</summary>
        new Date(2099, 11, 31),
        showOtherMonthDays: ///	<summary>
        ///	Determines whether to display the days of the next
        /// and/or previous month.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({showOtherMonthDays: false});
        ///	</summary>
        true,
        showDayPadding: ///	<summary>
        ///	Determines whether to add zeroes to days with only one digit
        /// (for example, "1" would become "01" if this property were set to "true").
        /// Default: false
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({showDayPadding: true});
        ///	</summary>
        false,
        selectionMode: ///	<summary>
        ///	Gets or sets the date selection mode on the calendar control that
        /// specifies whether the user can select a single day, a week,
        /// or an entire month.
        /// Default: { day: true, days: true }
        /// Type: Hash Object
        ///	Possible fields in hash are: day, days, weekDay, weekNumber, month.
        /// Code example:
        ///	$(".selector").wijcalendar({
        /// selectionMode: { day: true, days: true, weekDay: true}});
        ///	</summary>
        {
            day: true,
            days: true
        },
        allowPreview: ///	<summary>
        ///	When set to true, a popup calendar appears that displays the previous and
        /// next calendar months. This is useful when you want to view the current calendar month while navigating
        /// through the previous or next calendar months.
        /// Default: false
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({allowPreview: true});
        ///	</summary>
        false,
        allowQuickPick: ///	<summary>
        ///	Determines whether users can change the view to month/year/decade
        /// while clicking on the calendar title.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({allowQuickPick: false});
        ///	</summary>
        true,
        toolTipFormat: ///	<summary>
        ///	Gets or sets the format for the ToolTip.
        /// Default: "dddd, MMMM dd, yyyy"
        /// Type: String
        /// Code example:
        ///	$(".selector").wijcalendar({toolTipFormat: "dddd, MMMM dd, yyyy"});
        ///	</summary>
        "dddd, MMMM dd, yyyy",
        prevTooltip: ///	<summary>
        ///	Gets or sets the text for the 'previous' button's ToolTip.
        /// Default: "Previous"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({prevTooltip: "Previous"});
        ///	</summary>
        "Previous",
        nextTooltip: ///	<summary>
        ///	Gets or sets the text for the 'next' button's ToolTip.
        /// Default: "Next"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({nextTooltip: "Next"});
        ///	</summary>
        "Next",
        quickPrevTooltip: ///	<summary>
        ///	Gets or sets the  "quick previous" button's ToolTip.
        /// Default: "Quick Previous"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({quickPrevTooltip: "Quick Previous"});
        ///	</summary>
        "Quick Previous",
        quickNextTooltip: ///	<summary>
        ///	Gets or sets the "quick next" button's ToolTip.
        /// Default: "Quick Next"
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({quickNextTooltip: "Quick Next"});
        ///	</summary>
        "Quick Next",
        prevPreviewTooltip: ///	<summary>
        ///	Gets or sets the "previous preview" button's ToolTip.
        /// Default: ""
        /// Type: String
        /// Code example:
        ///	$(".selector").wijcalendar({
        /// prevPreviewTooltip: "Preview previous month"});
        ///	</summary>
        "",
        nextPreviewTooltip: ///	<summary>
        ///	Gets or sets the "next preview" button's ToolTip.
        /// Default: ""
        /// Type: String
        /// Code example:
        ///	$(".selector").wijcalendar({
        /// nextPreviewTooltip: "Preview next month"});
        ///	</summary>
        "",
        navButtons: ///	<summary>
        ///	Determines the display type of navigation buttons.
        ///	Possible values are: "default", "quick" or "none"
        /// Default: 'default'
        /// Type: String
        /// Code example:
        ///	$(".selector").wijcalendar({navButtons: "quick"});
        ///	</summary>
        'default',
        quickNavStep: ///	<summary>
        ///	Detemines the inc/dec steps when clicking the quick navigation button.
        /// Default: 12
        /// Type: Number
        /// Code example:
        ///	$(".selector").wijcalendar({quickNavStep: 3});
        ///	</summary>
        12,
        direction: ///	<summary>
        ///	Determines the month slide direction.
        ///	Possible values are: horizontal or vertical
        /// Default: 'horizontal'
        /// Type: String
        /// Code example:
        ///	$(".selector").wijcalendar({direction: "vertical"});
        ///	</summary>
        'horizontal',
        duration: ///	<summary>
        ///	Gets or sets the animation duration in milliseconds.
        /// Default: 250
        /// Type: Number
        /// Code example:
        ///		$(".selector").wijcalendar({duration: 500});
        ///	</summary>
        250,
        easing: ///	<summary>
        ///	Determines the animations easing effect.
        /// Default: 'easeInQuad'
        /// Type: String
        /// Code example:
        ///		$(".selector").wijcalendar({easing: "easeInQuad"});
        ///	</summary>
        'easeInQuad',
        popupMode: ///	<summary>
        ///	A Boolean property that determines whether
        /// the wijcalendar widget is a pop-up calendar.
        /// Default: false
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({popupMode: true});
        ///	</summary>
        false,
        autoHide: ///	<summary>
        ///	A Boolean property that determines whether to autohide
        /// the calendar in pop-up mode when clicking outside of the calendar.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///		$(".selector").wijcalendar({autoHide: false});
        ///	</summary>
        true,
        customizeDate: /// <summary>
        /// A callback function used for customizing the content,
        /// style and attributes of a day cell.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({
        /// customizeDate: function($daycell, date, dayType, hover, preview){ } });
        /// </summary>
        /// <param name="$daycell" type="jQuery">
        /// jQuery object that represents table cell of the date to be customized.
        /// </param>
        /// <param name="date" type="Date">Date of the cell.</param>
        /// <param name="dayType" type="Number">
        /// Type of the day. Please see the definition of wijDayType.
        ///	</param>
        /// <param name="hover" type="Boolean">
        /// Whether mouse is over the day cell.
        /// </param>
        /// <param name="preview" type="Object">
        /// Whether rendering in preview container.
        /// </param>
        /// <returns type="Boolean">
        /// True if day cell content has been changed
        /// and default cell content will not be applied.
        /// </returns>
        null,
        title: /// <summary>
        /// A callback function used to customizing the title text on month view.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({ title: function (date, format) { } });
        /// </summary>
        ///
        /// <param name="date" type="Date">The display date of the month.</param>
        /// <param name="format" type="String">
        /// The title format. Determined by the options.titleFormat.
        /// </param>
        /// <returns type="String">The customized title text.</returns>
        null,
        beforeSlide: /// <summary>
        /// The beforeSlide event handler.
        /// A function called before the calendar view slides to another month.
        /// Cancellable.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({ beforeSlide: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        afterSlide: /// <summary>
        /// The afterSlide event handler.
        /// A function called after the calendar view slided to another month.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({ afterSlide: function (e) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        beforeSelect: /// <summary>
        /// The beforeSelect event handler.
        /// A function called before user selects a day by mouse. Cancellable.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({ beforeSelect: function (e, args) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="args" type="Object">
        /// The data with this event.
        /// args.date: The date to be selected.
        ///</param>
        null,
        afterSelect: /// <summary>
        /// The afterSelect event handler.
        /// A function called after user selects a day by mouse.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({ afterSelect: function (e, args) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="args" type="Object">
        /// The data with this event.
        /// args.date: The selected date.
        ///</param>
        null,
        selectedDatesChanged: /// <summary>
        /// The selectedDatesChanged event handler.
        /// A function called after the selectedDates collection changed.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// $(".selector").wijcalendar({
        /// selectedDatesChanged: function (e, args) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="args" type="Object">
        /// The data with this event.
        /// args.dates: The array with all selected date object.
        ///</param>
        null
    });
    $.wijmo.registerWidget("wijcalendar", wijcalendar.prototype);
    var htmlTextWriter = (function () {
        function htmlTextWriter() {
            this._html = [];
        }
        htmlTextWriter.prototype.writeTagLeftChar = function () {
            this._html[this._html.length] = '<';
        };
        htmlTextWriter.prototype.writeTagRightChar = function () {
            this._html[this._html.length] = '>';
        };
        htmlTextWriter.prototype.write = function (text) {
            this._html[this._html.length] = ' ' + text + ' ';
        };
        htmlTextWriter.prototype.writeBeginTag = function (tagName) {
            this._html[this._html.length] = '<' + tagName;
        };
        htmlTextWriter.prototype.writeEndTag = function (tagName) {
            this._html[this._html.length] = '</' + tagName + '>';
        };
        htmlTextWriter.prototype.writeFullBeginTag = function (tagName) {
            this._html[this._html.length] = '<' + tagName + '>';
        };
        htmlTextWriter.prototype.writeSelfClosingTagEnd = function () {
            this._html[this._html.length] = '/>';
        };
        htmlTextWriter.prototype.writeAttribute = function (name, value) {
            if(value === undefined || value === null) {
                return;
            }
            this._html[this._html.length] = ' ' + name + '=\"';
            this._html[this._html.length] = value;
            this._html[this._html.length] = '\"';
        };
        htmlTextWriter.prototype.clean = function () {
            this._html = [];
        };
        htmlTextWriter.prototype.toString = function () {
            return this._html.join('');
        };
        return htmlTextWriter;
    })();
    wijmo.htmlTextWriter = htmlTextWriter;    
    var wijDateOps = {
        addDays: function (date, days) {
            var dt = new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
            if(days) {
                if(dt.getDate() === date.getDate()) {
                    dt = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                    dt.setTime(dt.getTime() + (days * 24 * 3600 * 1000));
                }
            }
            return dt;
        },
        addMonths: function (date, months) {
            return new Date(date.getFullYear(), date.getMonth() + months, 1);
        },
        addYears: function (date, years) {
            return this.addMonths(date, years * 12);
        },
        getDate: function (date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        },
        getTicks: function (date) {
            return date.valueOf();
        },
        isSameDate: function (date1, date2) {
            return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
        },
        isSameMonth: function (date1, date2) {
            return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
        },
        getDaysInMonth: function (date) {
            return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        },
        getWeekStartDate: function (date, firstDayOfWeek) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate() - ((date.getDay() - firstDayOfWeek + 7) % 7));
        },
        getDayOfYear: function (date) {
            var start = new Date(date.getFullYear(), 0, 1), distance = this.getTicks(date) - this.getTicks(start), days = distance / (24 * 60 * 60 * 1000);
            return Math.floor(days) + 1;
        },
        getFirstDayWeekOfYear: function (date, firstDayOfWeek) {
            var days = this.getDayOfYear(date) - 1, offset = date.getDay() - (days % 7), weeks;
            offset = ((offset - firstDayOfWeek) + 14) % 7;
            weeks = ((days + offset) / 7);
            return Math.floor(weeks) + 1;
        },
        getDayOfWeek: function (date, firstDayOfWeek) {
            return ((date.getDay() - firstDayOfWeek + 7) % 7);
        },
        getWeekOfYearFullDays: function (time, rule, firstDayOfWeek, fullDays) {
            var days = this.getDayOfYear(time) - 1, offset = (this.getDayOfWeek(time, firstDayOfWeek)) - (days % 7);
            offset = ((firstDayOfWeek - offset) + 14) % 7;
            if((offset) && (offset >= fullDays)) {
                offset -= 7;
            }
            offset = days - offset;
            if(offset >= 0) {
                return (Math.floor(offset / 7) + 1);
            }
            return this.getWeekOfYearFullDays(this.addDays(time, -(days + 1)), rule, firstDayOfWeek, fullDays);
        },
        getWeekOfYear: function (date, rule, firstDayOfWeek) {
            switch(rule) {
                case "firstDay":
                    return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
                case "firstFullWeek":
                    return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 7);
                case "firstFourDayWeek":
                    return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 4);
            }
            return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
        },
        getDateToken: function (date) {
            return date.getFullYear() + '_' + date.getMonth() + '_' + date.getDate();
        }
    };
    var wijMonthView = (function () {
        function wijMonthView(calendar, displayDate) {
            this.calendar = calendar;
            if(displayDate === undefined || wijDateOps.isSameDate(displayDate, new Date(1900, 0, 1))) {
                displayDate = new Date();
            }
            this.displayDate = displayDate;
            this.id = this.calendar._getId() + '_' + this.calendar._getMonthID(displayDate);
            this.isFirst = false;
            this.isLast = false;
            this.showPreview = false;
            this.culture = this.calendar._getCulture();
            this._calcDates(this.displayDate);
        }
        wijMonthView.prototype._calcDates = function (date) {
            var daysInMonth = wijDateOps.getDaysInMonth(date);
            this._startDateInMonth = new Date(date.getFullYear(), date.getMonth(), 1);
            this._endDateInMonth = wijDateOps.addDays(this._startDateInMonth, daysInMonth - 1);
            this._startDate = wijDateOps.getWeekStartDate(this._startDateInMonth, this.culture.calendar.firstDay);
            this._endDate = wijDateOps.addDays(this._startDate, this.calendar.options.dayRows * this.calendar.options.dayCols - 1);
        };
        wijMonthView.prototype._isFirstMonth = function () {
            var date = this.calendar.getDisplayDate();
            return wijDateOps.isSameMonth(this._startDateInMonth, date);
        };
        wijMonthView.prototype._isLastMonth = function () {
            var date = this.calendar.getDisplayDate();
            date = new Date(date.getFullYear(), date.getMonth(), 1);
            date = wijDateOps.addMonths(date, this.calendar.options.monthCols * this.calendar.options.monthRows - 1);
            return wijDateOps.isSameMonth(this._startDateInMonth, date);
        };
        wijMonthView.prototype.getStartDate = function () {
            return this._startDate;
        };
        wijMonthView.prototype.getEndDate = function () {
            return this._endDate;
        };
        wijMonthView.prototype._getMonthDate = function () {
            if(this._startDateInMonth === undefined) {
                //this._calcDates(this.getDisplayDate());
                            }
            return this._startDateInMonth;
        };
        wijMonthView.prototype._setMonthDate = function (date) {
            this._calcDates(date);
        };
        wijMonthView.prototype._getWeekDayText = function (day, format) {
            format = format || "short";
            var days = this.culture.calendar.days, text = '';
            switch(format) {
                case "full":
                    text = days.names[day];
                    break;
                case "firstLetter":
                    text = days.names[day].substring(0, 1);
                    break;
                case "abbreviated":
                    text = days.namesAbbr[day];
                    break;
                default:
                    text = days.namesShort[day];
                    break;
            }
            return text;
        };
        wijMonthView.prototype._getRowCount = function () {
            var o = this.calendar.options;
            return o.showWeekDays ? o.dayRows + 1 : o.dayRows;
        };
        wijMonthView.prototype._getColCount = function () {
            var o = this.calendar.options;
            return o.showWeekNumbers ? o.dayCols + 1 : o.dayCols;
        };
        wijMonthView.prototype._getDayType = function (date) {
            var o = this.calendar.options, dayType = wijDayType.general, dow = date.getDay(), weekEnd = dow === 6 || dow === 0, outOfRange = // Saturday or Sunday
            date < o.minDate || date > o.maxDate, otherMonth = date < this._startDateInMonth || date > this._endDateInMonth, isDisabled = outOfRange || this.calendar._getDisabledDates().contains(date), isSelected = this.calendar._getSelectedDates().contains(date), today = new Date(), isToday = wijDateOps.isSameDate(date, today), isCustom = false;
            if(weekEnd) {
                dayType |= wijDayType.weekEnd;
            }
            if(isToday) {
                dayType |= wijDayType.today;
            }
            if(isDisabled) {
                dayType |= wijDayType.disabled;
            }
            if(otherMonth) {
                dayType |= wijDayType.otherMonth;
            }
            if(outOfRange) {
                dayType |= wijDayType.outOfRange;
            }
            if(isSelected) {
                dayType |= wijDayType.selected;
            }
            if(isCustom) {
                dayType |= wijDayType.custom;
            }
            if(otherMonth && !o.showOtherMonthDays) {
                dayType |= wijDayType.gap;
            }
            return dayType;
        };
        wijMonthView.prototype._refreshDate = function (date) {
            if(date < this._startDate || date > this._endDate) {
                return;
            }
            var o = this.calendar.options, dUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), startUTC = Date.UTC(this._startDate.getFullYear(), this._startDate.getMonth(), this._startDate.getDate()), offset = (Math.floor(Math.abs(dUTC - startUTC) / (24 * 60 * 60 * 1000))), row = Math.floor(offset / this.calendar.options.dayCols), col = Math.floor(offset % this.calendar.options.dayCols), tbl, r, dayCell, dayType;
            if(o.showWeekNumbers) {
                col++;
            }
            if(o.showWeekDays) {
                row++;
            }
            tbl = $("#" + this.id, this.calendar.element).get(0);
            if(tbl) {
                if(row < tbl.rows.length) {
                    r = tbl.rows[row];
                    if(col < r.cells.length) {
                        dayCell = r.cells[col];
                        dayType = this._getDayType(date);
                        $(dayCell).attr('daytype', dayType.toString());
                        this.calendar._refreshDayCell(dayCell);
                    }
                }
            }
        };
        wijMonthView.prototype._fillDayCell = function (hw, date, previewMode) {
            var o = this.calendar.options, custom = null, text = date.getDate().toString(), tooltip = this.calendar._formatDate(o.toolTipFormat || "dddd, MMMM dd, yyyy", date), dayType = this._getDayType(date), selectable = this.calendar._isSelectable(dayType), css = this.calendar._getCellClassName(dayType, date, previewMode);
            text = (o.showDayPadding && text.length === 1) ? '0' + text : text;
            hw.writeBeginTag('td');
            hw.writeAttribute('daytype', (dayType).toString());
            if(selectable) {
                hw.writeAttribute('title', tooltip);
                hw.writeAttribute('aria-label', tooltip);
            }
            hw.writeAttribute('date', date.toDateString());
            hw.writeAttribute('class', css.cssCell);
            hw.writeAttribute('role', 'gridcell');
            if(!selectable) {
                hw.writeAttribute('aria-disabled', 'true');
            }
            hw.writeTagRightChar();
            if((dayType & wijDayType.gap)) {
                hw.write('&#160;');
            } else {
                if(custom && custom.content) {
                    hw.write(custom.content);
                } else {
                    hw.writeBeginTag('a');
                    hw.writeAttribute('class', css.cssText);
                    hw.writeAttribute('href', '#');
                    hw.writeAttribute('onclick', 'return false;');
                    hw.writeTagRightChar();
                    hw.write(text);
                    hw.writeEndTag('a');
                }
            }
            hw.writeEndTag('td');
        };
        wijMonthView.prototype.getHtml = function (tableOnly) {
            tableOnly = !!tableOnly;
            var o = this.calendar.options, wijCSS = o.wijCSS, previewMode = !!this.calendar.element.data('preview.wijcalendar'), hw = new htmlTextWriter(), i, j, dayOfWeek, weekStartDate, weekEnd, colIndex, txt, fullTxt, date, wnDate, rowIndex, weekNumber;
            if(!tableOnly && o.showTitle) {
                hw.write(this.calendar._getHeaderHtml(this._startDateInMonth, this.isFirst, this.isLast));
            }
            if(!tableOnly && !previewMode && this.showPreview) {
                hw.writeBeginTag('div');
                hw.writeAttribute('class', 'wijmo-wijcalendar-prevpreview-button');
                hw.writeAttribute('role', 'button');
                hw.writeAttribute('aria-haspopup', 'true');
                hw.writeAttribute('id', 'prevPreview');
                hw.writeTagRightChar();
                hw.writeBeginTag('a');
                hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                hw.writeAttribute('href', '#');
                hw.writeAttribute('title', o.prevPreviewTooltip);
                hw.writeAttribute('aria-label', o.prevPreviewTooltip);
                hw.writeAttribute('onclick', 'return false;');
                hw.writeTagRightChar();
                hw.write('&#160;');
                hw.writeEndTag('a');
                hw.writeEndTag('div');
            }
            hw.writeBeginTag('table');
            hw.writeAttribute('id', this.id);
            hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-table');
            hw.writeAttribute('role', 'grid');
            hw.writeAttribute('summary', this.calendar._getTitleText(this._startDateInMonth));
            hw.writeAttribute('onselectstart', 'return false;');
            hw.writeTagRightChar();
            if(o.showWeekDays) {
                hw.writeFullBeginTag('thead');
                hw.writeBeginTag('tr');
                hw.writeTagRightChar();
                if(o.showWeekNumbers) {
                    hw.writeBeginTag('th');
                    hw.writeAttribute('id', this.id + '_ms');
                    hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-monthselector' + (!!o.selectionMode.month ? ' wijmo-wijcalendar-selectable' : ''));
                    hw.writeAttribute('role', 'columnheader');
                    hw.writeTagRightChar();
                    if(!!o.selectionMode.month && !previewMode && !o.disabledState && !o.disabled) {
                        hw.writeBeginTag('a');
                        hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconTriangle1Se);
                        hw.writeAttribute('style', 'display: block;');
                        hw.writeSelfClosingTagEnd();
                    } else {
                        hw.write('Wk');
                    }
                    hw.writeEndTag('th');
                }
                dayOfWeek = this._startDate.getDay();
                weekStartDate = this._startDate;
                for(i = 0; i < o.dayCols; i++) {
                    weekEnd = dayOfWeek === 6 || dayOfWeek === 0;
                    colIndex = i + ((o.showWeekNumbers) ? 1 : 0);
                    txt = this._getWeekDayText(dayOfWeek, o.weekDayFormat);
                    fullTxt = this._getWeekDayText(dayOfWeek, "full");
                    hw.writeBeginTag('th');
                    hw.writeAttribute('id', this.id + '_cs_' + colIndex);
                    hw.writeAttribute('class', wijCSS.datepickerWeekDay + (weekEnd ? ' ' + wijCSS.datepickerWeekEnd : '') + (!!o.selectionMode.weekDay ? ' wijmo-wijcalendar-selectable' : ''));
                    hw.writeAttribute('role', 'columnheader');
                    hw.writeTagRightChar();
                    hw.writeBeginTag('span');
                    hw.writeAttribute('title', fullTxt);
                    hw.writeAttribute('aria-label', fullTxt);
                    hw.writeTagRightChar();
                    hw.write(txt);
                    hw.writeEndTag('span');
                    hw.writeEndTag('th');
                    dayOfWeek = ((dayOfWeek + 1) % 7);
                    weekStartDate = wijDateOps.addDays(weekStartDate, 1);
                }
                hw.writeEndTag('tr');
                hw.writeEndTag('thead');
            }
            hw.writeFullBeginTag('tbody');
            date = this._startDate;
            wnDate = this._startDateInMonth;
            for(i = 0; i < o.dayRows; i++) {
                hw.writeBeginTag('tr');
                hw.writeTagRightChar();
                if(o.showWeekNumbers) {
                    rowIndex = i + ((o.showWeekDays) ? 1 : 0);
                    hw.writeBeginTag('td');
                    hw.writeAttribute('id', this.id + '_rs_' + rowIndex);
                    hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-week-num' + (!!o.selectionMode.weekNumber ? ' wijmo-wijcalendar-selectable' : ''));
                    hw.writeAttribute('role', 'rowheader');
                    hw.writeTagRightChar();
                    weekNumber = wijDateOps.getWeekOfYear(wnDate, o.calendarWeekRule, this.culture.calendar.firstDay);
                    hw.write(weekNumber);
                    hw.writeEndTag('td');
                    wnDate = wijDateOps.addDays(wnDate, o.dayCols);
                }
                for(j = 0; j < o.dayCols; j++) {
                    this._fillDayCell(hw, date, previewMode);
                    date = wijDateOps.addDays(date, 1);
                }
                hw.writeEndTag('tr');
            }
            hw.writeEndTag('tbody');
            hw.writeEndTag('table');
            if(!tableOnly && !previewMode && this.showPreview) {
                hw.writeBeginTag('div');
                hw.writeAttribute('class', 'wijmo-wijcalendar-nextpreview-button');
                hw.writeAttribute('role', 'button');
                hw.writeAttribute('aria-haspopup', 'true');
                hw.writeAttribute('id', 'nextPreview');
                hw.writeTagRightChar();
                hw.writeBeginTag('a');
                hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                hw.writeAttribute('href', '#');
                hw.writeAttribute('title', o.nextPreviewTooltip);
                hw.writeAttribute('aria-label', o.nextPreviewTooltip);
                hw.writeAttribute('onclick', 'return false;');
                hw.writeTagRightChar();
                hw.write('&#160;');
                hw.writeEndTag('a');
                hw.writeEndTag('div');
            }
            return hw.toString();
        };
        return wijMonthView;
    })();
    wijmo.wijMonthView = wijMonthView;    
    var wijDateCollection = (function () {
        function wijDateCollection(calendar, optionName) {
            this._calendar = calendar;
            this._optionName = optionName ? optionName : 'selectedDates';
            this._normalize();
        }
        wijDateCollection.prototype.getDates = function () {
            if(this._calendar.options[this._optionName] === undefined) {
                this._calendar.options[this._optionName] = [];
            }
            return this._calendar.options[this._optionName];
        };
        wijDateCollection.prototype.setDates = function (dates) {
            this._calendar.options[this._optionName] = dates;
            this._normalize();
        };
        wijDateCollection.prototype.getCount = function () {
            return this.getDates().length;
        };
        wijDateCollection.prototype.clear = function () {
            this.setDates([]);
        };
        wijDateCollection.prototype.add = function (date) {
            this.addRange(date, date);
        };
        wijDateCollection.prototype.remove = function (date) {
            this.removeRange(date, date);
        };
        wijDateCollection.prototype.indexOf = function (date) {
            if(!this.getCount()) {
                return -1;
            }
            return this._findRangeBound(date, true, false);
        };
        wijDateCollection.prototype.contains = function (date) {
            return this.indexOf(date) !== -1;
        };
        wijDateCollection.prototype.removeRange = function (start, end) {
            if(!this.getCount()) {
                return;
            }
            var startIndex = this._findRangeBound(start, false, true), endIndex = this._findRangeBound(end, false, false), dates, startSlice, endSlice;
            if(startIndex < 0 || endIndex < 0) {
                return;
            }
            if(startIndex > endIndex) {
                return;
            }
            dates = this.getDates();
            if(dates[endIndex] > end) {
                return;
            }
            startSlice = (!startIndex) ? [] : dates.slice(0, startIndex);
            endSlice = endIndex >= (dates.length - 1) ? [] : dates.slice(endIndex + 1);
            this.setDates(startSlice.concat(endSlice));
        };
        wijDateCollection.prototype.addRange = function (start, end) {
            this.removeRange(start, end);
            var dates = this.getDates(), insertIndex = this._findRangeBound(start, false, true), startSlice = (!insertIndex) ? [] : dates.slice(0, insertIndex), endSlice = dates.slice(insertIndex), midSlice = [], curDate;
            start = wijDateOps.getDate(start);
            end = wijDateOps.getDate(end);
            for(curDate = start; curDate <= end; curDate = wijDateOps.addDays(curDate, 1)) {
                midSlice[midSlice.length] = curDate;
            }
            this.setDates(startSlice.concat(midSlice.concat(endSlice)));
        };
        wijDateCollection.prototype._findRangeBound = function (date, exact, isStart) {
            var dates = this.getDates(), low = 0, hi = dates.length, index;
            while(low < hi) {
                index = (low + hi) >> 1;
                if(wijDateOps.isSameDate(date, dates[index])) {
                    return index;
                }
                if(date < dates[index]) {
                    hi = index;
                } else {
                    low = index + 1;
                }
            }
            if(exact) {
                return -1;
            }
            return (isStart) ? low : hi;
        };
        wijDateCollection.prototype._parseDate = function (date) {
            var strDate;
            if(!date) {
                date = new Date();
            } else {
                if(typeof date === 'string') {
                    strDate = date;
                }
            }
            if(strDate) {
                strDate = strDate.replace(/-/g, '/');
                try  {
                    date = new Date(strDate);
                    if(isNaN(date)) {
                        date = new Date();
                    }
                } catch (e) {
                    date = new Date();
                }
            }
            return date;
        };
        wijDateCollection.prototype._normalize = function () {
            //Normalize the array
                        var dates = this._calendar.options[this._optionName], self = this, newDates;
            if($.isArray(dates)) {
                newDates = $.map(dates, function (d, i) {
                    return self._parseDate(d);
                });
                this._calendar.options[this._optionName] = newDates.sort(function (a, b) {
                    return a.getTime() - b.getTime();
                });
            }
        };
        return wijDateCollection;
    })();
    wijmo.wijDateCollection = wijDateCollection;    
    var wijMyGrid = (function () {
        function wijMyGrid(calendar) {
            this.gridType = "month";
            this.calendar = calendar;
            if(calendar) {
                this.culture = calendar._getCulture();
            }
        }
        wijMyGrid.prototype.select = function (index, value) {
            var date = this.calendar.getDisplayDate();
            switch(this.gridType) {
                case "month":
                    date.setMonth(value);
                    break;
                case "year":
                    date.setFullYear(value);
                    break;
                case "decade":
                    date.setFullYear(value);
                    break;
            }
            this.calendar.options.displayDate = date;
        };
        wijMyGrid.prototype.getSelectedIndex = function () {
            var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
            switch(this.gridType) {
                case "month":
                    return date.getMonth();
                case "year":
                    return year - startYear;
                case "decade":
                    return Math.floor((year - startDecade) / 10);
            }
            return 0;
        };
        wijMyGrid.prototype.getTitle = function () {
            var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
            switch(this.gridType) {
                case "month":
                    return year.toString();
                case "year":
                    return (startYear + 1) + " - " + (startYear + 10);
                case "decade":
                    return (startDecade + 10) + " - " + (startDecade + 109);
            }
            return '';
        };
        wijMyGrid.prototype.getHtml = function (date, tableOnly) {
            if(date === undefined) {
                date = this.calendar.getDisplayDate();
            } else {
                if(typeof (date) === 'boolean') {
                    tableOnly = date;
                    date = this.calendar.getDisplayDate();
                }
            }
            tableOnly = !!tableOnly;
            var o = this.calendar.options, rows = 3, cols = 4, hw = new htmlTextWriter(), wijCSS = o.wijCSS, height, year, startMonth, startYear, startDecade, ms, i, j, index, selected, outofRange, cellText, v, cls;
            if(o.showTitle && !tableOnly) {
                hw.write(this.calendar._getHeaderHtml(null, true, true));
            }
            height = 100 / rows + '%';
            height = '30%';
            hw.writeBeginTag('table');
            hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-mygrid');
            hw.writeAttribute('role', 'grid');
            hw.writeAttribute('onselectstart', 'return false;');
            hw.writeTagRightChar();
            year = date.getFullYear();
            startMonth = date.getFullYear() * 12;
            startYear = Math.floor(year / 10) * 10 - 1;
            startDecade = Math.floor(year / 100) * 100 - 10;
            ms = this.culture.calendar.months;
            for(i = 0; i < rows; i++) {
                hw.writeBeginTag('tr');
                hw.writeAttribute('height', height);
                hw.writeTagRightChar();
                for(j = 0; j < cols; j++) {
                    index = i * 4 + j;
                    selected = false;
                    outofRange = false;
                    cellText = '';
                    v = null;
                    switch(this.gridType) {
                        case "month":
                            if(date.getMonth() === index) {
                                selected = true;
                            }
                            v = index;
                            cellText = ms.namesAbbr[index];
                            outofRange = ((startMonth + index) < (o.minDate.getFullYear() * 12 + o.minDate.getMonth())) || ((startMonth + index) > (o.maxDate.getFullYear() * 12 + o.maxDate.getMonth()));
                            break;
                        case "year":
                            if(index === 0 || index === 11) {
                                outofRange = true;
                            }
                            v = startYear + index;
                            if(v < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                outofRange = true;
                            } else {
                                selected = (year === v);
                            }
                            cellText = v.toString();
                            break;
                        case "decade":
                            if(index === 0 || index === 11) {
                                outofRange = true;
                            }
                            v = startDecade + index * 10;
                            if(v + 10 < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                outofRange = true;
                            } else {
                                selected = (year >= v && year < (v + 10));
                            }
                            cellText = v.toString() + '-<br/>' + (v + 9).toString();
                            break;
                    }
                    cls = wijCSS.datepickerWeekDay;
                    if(outofRange) {
                        cls = cls + ' ' + wijCSS.datepickerOtherMonth + ' ' + wijCSS.prioritySecondary + ' ' + wijCSS.datepickerUnselectable;
                    } else {
                        if(!o.disabledState && !o.disabled) {
                            cls += " wijmo-wijcalendar-day-selectable";
                        }
                    }
                    cls += " " + wijCSS.stateDefault + (outofRange ? ' ' + wijCSS.stateDisabled : '') + (selected ? ' ' + wijCSS.stateActive + ' ' + wijCSS.stateHighlight : '');
                    hw.writeBeginTag('td');
                    hw.writeAttribute('class', cls);
                    hw.writeAttribute('role', 'gridcell');
                    //hw.writeAttribute('width', width);
                    hw.writeAttribute('index', index.toString());
                    hw.writeAttribute('value', v.toString());
                    hw.writeAttribute('other', outofRange.toString());
                    hw.writeTagRightChar();
                    hw.writeBeginTag('a');
                    hw.writeAttribute('href', '#');
                    hw.writeTagRightChar();
                    hw.write(cellText);
                    hw.writeEndTag('a');
                    hw.writeEndTag('td');
                }
                hw.writeEndTag('tr');
            }
            hw.writeEndTag('table');
            return hw.toString();
        };
        return wijMyGrid;
    })();
    wijmo.wijMyGrid = wijMyGrid;    
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery,$*/
/*jslint white: false */
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.widget.js
*  jquery.wijmo.wijutil.js
*  jquery.wijmo.wijexpander.js
*  Non-default animations requires UI Effects Core
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijexpander";
    var wijexpander = (function (_super) {
        __extends(wijexpander, _super);
        function wijexpander() {
            _super.apply(this, arguments);

        }
        wijexpander.prototype._setOption = // handle option changes:
        function (key, value) {
            switch(key) {
                case "contentUrl":
                    if(value) {
                        this.element.find("> ." + this.options.wijCSS.content).wijContent(value);
                    } else {
                        this.element.find("> ." + this.options.wijCSS.content).html("");
                    }
                    break;
                case "disabled":
                    if(value) {
                        this.element.addClass(this.options.wijCSS.stateDisabled).find("> .ui-expander-header").addClass(this.options.wijCSS.stateDisabled);
                        this.element.find("> ." + this.options.wijCSS.content).addClass(this.options.wijCSS.stateDisabled);
                    } else {
                        this.element.removeClass(this.options.wijCSS.stateDisabled).find("> .ui-expander-header").removeClass(this.options.wijCSS.stateDisabled);
                        this.element.find("> ." + this.options.wijCSS.content).removeClass(this.options.wijCSS.stateDisabled);
                    }
                    break;
                case "expandDirection":
                    this._onDirectionChange(value, true, this.options.expandDirection);
                    break;
                case "expanded":
                    if(value) {
                        this.expand();
                    } else {
                        this.collapse();
                    }
                    // option value already stored inside expand/collapse method
                    // if action is not cancelled, so we need return here.
                    return;
                default:
                    break;
            }
            $.wijmo.widget.prototype._setOption.apply(this, arguments);
        };
        wijexpander.prototype._create = function () {
            var o = this.options, elems = this.element.children(), header, content;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            // do not call base c1headercontentcontrol _create method here since we don't
            // want to place c1headercontentcontrol classes on the widget element
            this.element.addClass("wijmo-wijexpander ui-expander " + o.wijCSS.widget + " ui-helper-reset ui-expander-icons");
            header = $(elems[0]);
            content = $(elems[1]);
            if(o.expandDirection === "left" || o.expandDirection === "top") {
                header.remove();
                header.insertAfter(content);
            }
            header.addClass("ui-expander-header ui-helper-reset");
            // ARIA
            header.attr("role", "tab");
            content.attr("role", "tabpanel");
            if(header.find("> a").length === 0) {
                // fix for 32089:
                header.wrapInner('<a href="javascript:void(null)"></a>');
                //header.wrapInner('<a href="#"></a>');
                            }
            if(header.find("> .ui-icon").length === 0) {
                $('<span class="ui-icon"></span>').insertBefore($("> a", header)[0]);
            }
            content.addClass("ui-expander-content ui-helper-reset " + o.wijCSS.content);
        };
        wijexpander.prototype._init = // widget initialization:
        function () {
            var o = this.options;
            this._onDirectionChange(o.expandDirection, false);
            if(o.contentUrl) {
                $("." + o.wijCSS.content, this.element).wijContent(this.options.contentUrl);
            }
            if(!o.expanded) {
                this.element.find("> .ui-expander-content").hide();
                this.element.find("> .ui-expander-header").addClass(o.wijCSS.stateDefault + " " + o.wijCSS.cornerAll).attr({
                    "aria-expanded": "false",
                    tabIndex: -1
                }).find("> .ui-icon").addClass(this._triangleIconClosed);
            } else {
                this.element.find("> .ui-expander-header").addClass(o.wijCSS.stateActive).attr({
                    "aria-expanded": "true",
                    tabIndex: 0
                }).addClass(this._headerCornerOpened).find("> .ui-icon").addClass(this._triangleIconOpened);
                this.element.find("> .ui-expander-content").addClass("ui-expander-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
            }
            if(o.disabled) {
                this.element.addClass(o.wijCSS.stateDisabled).find("> .ui-expander-header").addClass(o.wijCSS.stateDisabled);
                this.element.find("> .ui-expander-content").addClass(o.wijCSS.stateDisabled);
            }
            this._bindLiveEvents();
        };
        wijexpander.prototype.destroy = function () {
            var o = this.options;
            this._unbindLiveEvents();
            this.element.removeClass("wijmo-wijexpander ui-expander " + o.wijCSS.widget + " ui-helper-reset ui-expander-icons");
            //.removeData('wijexpander');
            $.wijmo.widget.prototype.destroy.apply(this, arguments);
        };
        wijexpander.prototype._bindLiveEvents = function () {
            var o = this.options;
            //"on" was introduced to JQuery in v1.7, Nov 2011. It is not yet in JQuery Mobile!.
            this.element.on("click.wijexpander", ">.ui-expander-header", jQuery.proxy(this._onHeaderClick, this));
            this.element.on("mouseenter.wijexpander", ".ui-expander-header", function () {
                $(this).addClass(o.wijCSS.stateHover);
            });
            this.element.on("mouseleave.wijexpander", ".ui-expander-header", function () {
                $(this).removeClass(o.wijCSS.stateHover);
            });
            this.element.on("focus.wijexpander", ".ui-expander-header", function () {
                $(this).addClass(o.wijCSS.stateFocus);
            });
            this.element.on("blur.wijexpander", ".ui-expander-header", function () {
                $(this).removeClass(o.wijCSS.stateFocus);
            });
        };
        wijexpander.prototype._unbindLiveEvents = function () {
            this.element.off(".wijexpander", ".ui-expander-header");
        };
        wijexpander.prototype._onDirectionChange = function (newDirection, allowDOMChange, prevDirection) {
            if (typeof prevDirection === "undefined") { prevDirection = null; }
            var rightToLeft, openedHeaders, openedContents, openedTriangles, closedTriangles, prevIsRightToLeft, content, header;
            var o = this.options;
            if(prevDirection && prevDirection !== newDirection) {
                this.element.removeClass("ui-expander-" + prevDirection);
            }
            if(allowDOMChange) {
                openedHeaders = this.element.find(".ui-expander-header." + this._headerCornerOpened);
                openedHeaders.removeClass(this._headerCornerOpened);
                openedContents = this.element.find(".ui-expander-content" + "." + this._contentCornerOpened);
                openedContents.removeClass(this._contentCornerOpened);
                openedTriangles = this.element.find("." + this._triangleIconOpened);
                closedTriangles = this.element.find("." + this._triangleIconClosed);
                openedTriangles.removeClass(this._triangleIconOpened);
                closedTriangles.removeClass(this._triangleIconClosed);
            }
            switch(newDirection) {
                case "top":
                    this._headerCornerOpened = "ui-corner-bottom";
                    this._contentCornerOpened = "ui-corner-top";
                    this._triangleIconOpened = o.wijCSS.iconArrowUp;
                    this._triangleIconClosed = o.wijCSS.iconArrowRight;
                    rightToLeft = true;
                    this.element.removeClass("ui-helper-horizontal");
                    this.element.addClass("ui-expander-top");
                    break;
                case "right":
                    this._headerCornerOpened = "ui-corner-left";
                    this._contentCornerOpened = "ui-corner-right";
                    this._triangleIconOpened = o.wijCSS.iconArrowRight;
                    this._triangleIconClosed = o.wijCSS.iconArrowDown;
                    rightToLeft = false;
                    this.element.addClass("ui-helper-horizontal");
                    this.element.addClass("ui-expander-right");
                    break;
                case "left":
                    this._headerCornerOpened = "ui-corner-right";
                    this._contentCornerOpened = "ui-corner-left";
                    this._triangleIconOpened = o.wijCSS.iconArrowLeft;
                    this._triangleIconClosed = o.wijCSS.iconArrowDown;
                    rightToLeft = true;
                    this.element.addClass("ui-helper-horizontal");
                    this.element.addClass("ui-expander-left");
                    break;
                default:
                    //case "bottom":
                    this._headerCornerOpened = "ui-corner-top";
                    this._contentCornerOpened = "ui-corner-bottom";
                    this._triangleIconOpened = o.wijCSS.iconArrowDown;
                    this._triangleIconClosed = o.wijCSS.iconArrowRight;
                    rightToLeft = false;
                    this.element.removeClass("ui-helper-horizontal");
                    this.element.addClass("ui-expander-bottom");
                    break;
            }
            prevIsRightToLeft = this.element.data("rightToLeft");
            this.element.data("rightToLeft", rightToLeft);
            if(allowDOMChange) {
                openedTriangles.addClass(this._triangleIconOpened);
                closedTriangles.addClass(this._triangleIconClosed);
                openedHeaders.addClass(this._headerCornerOpened);
                openedContents.addClass(this._contentCornerOpened);
            }
            if(allowDOMChange && rightToLeft !== prevIsRightToLeft) {
                this.element.children(".ui-expander-header").each(function (index, element) {
                    header = $(this);
                    if(rightToLeft) {
                        content = header.next(".ui-expander-content");
                        header.remove();
                        header.insertAfter(content);
                    } else {
                        content = header.prev(".ui-expander-content");
                        header.remove();
                        header.insertBefore(content);
                    }
                });
            }
        };
        wijexpander.prototype.collapse = /** public methods */
        /// <summary>
        /// Collapse content panel.
        /// Code Example: $("#element").wijexpander("collapse");
        ///</summary>
        function () {
            var o = this.options, animOptions, animations, duration, easing;
            if(!o.allowExpand) {
                return;
            }
            if(this.element.hasClass(o.wijCSS.stateDisabled)) {
                return false;
            }
            if(!this._trigger("beforeCollapse")) {
                return false;
            }
            /*
            newEv = jQuery.Event("beforecollapse");
            this.element.trigger(newEv);
            if (newEv.isDefaultPrevented()) {
            return false;
            }*/
            if(o.animated) {
                animOptions = {
                    expand: false,
                    content: this.element.find("> .ui-expander-content"),
                    complete: jQuery.proxy(function () {
                        this.element.find("> .ui-expander-content").removeClass("ui-expander-content-active");
                        this._trigger("afterCollapse");
                        this.element.find("> .ui-expander-content").css('display', '');
                    }, this),
                    horizontal: this.element.hasClass("ui-helper-horizontal")
                };
                animations = $.wijmo.wijexpander.animations;
                duration = o.duration;
                easing = o.animated;
                if(easing && !animations[easing] && !$.easing[easing]) {
                    easing = 'slide';
                }
                if(!animations[easing]) {
                    animations[easing] = function (options) {
                        this.slide(options, {
                            easing: easing,
                            duration: duration || 700
                        });
                    };
                }
                animations[easing](animOptions);
            } else {
                this.element.find("> .ui-expander-content").hide();
                this._trigger("afterCollapse");
            }
            this.element.find("> .ui-expander-header").removeClass(o.wijCSS.stateActive).removeClass(this._headerCornerOpened).attr({
                "aria-expanded": "false",
                tabIndex: -1
            }).addClass(o.wijCSS.stateDefault + " " + o.wijCSS.cornerAll).find("> .ui-icon").removeClass(this._triangleIconOpened).addClass(this._triangleIconClosed);
            this.options.expanded = false;
            return true;
        };
        wijexpander.prototype.expand = /// <summary>
        /// Expand content panel.
        /// Code Example: $("#element").wijexpander("expand");
        ///</summary>
        function () {
            var o = this.options, animOptions, animations, duration, easing;
            if(!o.allowExpand) {
                return;
            }
            if(this.element.hasClass(o.wijCSS.stateDisabled)) {
                return false;
            }
            if(!this._trigger("beforeExpand")) {
                return false;
            }
            //this.element.addClass("ui-state-expanded");
            if(o.animated) {
                //console.log("$.easing=" + $.easing + "," + $.effects[easing] + ",easing=" + easing);
                animOptions = {
                    expand: true,
                    content: this.element.find("> .ui-expander-content"),
                    complete: jQuery.proxy(function () {
                        this.element.find("> .ui-expander-content").addClass("ui-expander-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
                        this._trigger("afterExpand");
                        this.element.find("> .ui-expander-content").css('display', '');
                    }, this),
                    horizontal: this.element.hasClass("ui-helper-horizontal")
                };
                animations = $.wijmo.wijexpander.animations;
                duration = o.duration;
                easing = o.animated;
                if(easing && !animations[easing] && !$.easing[easing]) {
                    easing = 'slide';
                }
                if(!animations[easing]) {
                    animations[easing] = function (options) {
                        this.slide(options, {
                            easing: easing,
                            duration: duration || 700
                        });
                    };
                }
                animations[easing](animOptions);
            } else {
                this.element.find("> .ui-expander-content").show();
                this._trigger("afterExpand");
            }
            this.element.find("> .ui-expander-header").removeClass(o.wijCSS.stateDefault + " " + o.wijCSS.cornerAll).addClass(o.wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                "aria-expanded": "true",
                tabIndex: 0
            }).find("> .ui-icon").removeClass(this._triangleIconClosed).addClass(this._triangleIconOpened);
            this.options.expanded = true;
            return true;
        };
        wijexpander.prototype._onHeaderClick = /** Private methods */
        function (e) {
            this.option("expanded", !this.options.expanded);
            // commented in order to fix issue 32089:
            //return false;	// fix for 32089
                    };
        return wijexpander;
    })(wijmo.wijmoWidget);
    wijmo.wijexpander = wijexpander;    
    wijexpander.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        wijMobileCSS: {
            header: "ui-header ui-bar-a",
            content: "ui-content ui-body ui-body-c"
        },
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijexpander')",
        allowExpand: /// <summary>
        /// Determines if the widget can expand. Set this option to false if
        /// you want to disable collapse/expand ability.
        /// Default: true
        /// Type: Boolean.
        /// Code example: $("#element").wijexpander({ allowExpand: false });
        /// </summary>
        true,
        animated: /// <summary>
        /// Determines the animation easing effect; set this option to false in
        /// order to disable animation.
        /// Custom easing effects require the UI Effects Core. Additional options
        /// that are available for the animation function include:
        /// expand - value of true indicates that content element must be expanded.
        /// horizontal - value of true indicates that expander is horizontally
        ///	orientated (when expandDirection is left or right).
        /// content - jQuery object that contains content element to be expanded or
        ///				collapsed.
        /// Default: "slide"
        /// Type: string.
        /// Code example:
        ///        $("#expander2").wijexpander({
        ///            animated: "custom1"
        ///        });
        ///        jQuery.wijmo.wijexpander.animations.custom1 = function (options) {
        ///            this.slide(options, {
        ///                easing: "easeInBounce",
        ///                duration: 900
        ///            });
        ///        }
        /// </summary>
        'slide',
        contentUrl: /// <summary>
        /// Determines the URL to the external content. For example,
        /// http://componentone.com/ for the ComponentOne Web site.
        /// Default: ""
        /// Type: string.
        /// Code example:
        ///	$("#element").wijexpander({ contentUrl: "http://componentone.com/" });
        /// </summary>
        "",
        expanded: /// <summary>
        /// Determines the visibility state of the content panel. If true, the
        ///	content element is visible.
        /// Default: true
        /// Type: Boolean
        /// Code example: $("#element").wijexpander({ expanded: false });
        /// </summary>
        true,
        expandDirection: /// <summary>
        /// Determines the content expand direction. Available values are top, right,
        ///	bottom, and left.
        /// Default: "bottom"
        /// Type: string
        /// Code example: $("#element").wijexpander({ expandDirection: "right" });
        /// </summary>
        "bottom"
    });
    /*Available Events:
    /// <summary>
    /// Occurs before the content area collapses.
    /// Return false or call event.preventDefault() in order to cancel event and
    /// prevent the content area from collapsing.
    /// Type: Function
    /// Event type: wijexpanderbeforecollapse
    /// Code example:
    /// Supply a callback function to handle the beforeCollapse event as an option.
    /// $("#expander").wijexpander({ beforeCollapse: function (e) {
    ///		...
    ///    }
    ///	});
    /// Bind to the event by type: wijexpanderbeforecollapse.
    /// $( "#expander" ).bind( "wijexpanderbeforecollapse", function(e) {
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    beforeCollapse(e)
    
    /// <summary>
    /// Occurs before the content area expands.
    /// Return false or call event.preventDefault() in order to cancel event and
    /// prevent the content area from expanding.
    /// Type: Function
    /// Event type: wijexpanderbeforeexpand
    /// Code example:
    /// Supply a callback function to handle the beforeExpand event as an option.
    /// $("#expander").wijexpander({ beforeExpand: function (e) {
    ///		...
    ///    }
    ///	});
    /// Bind to the event by type: wijexpanderbeforeexpand.
    /// $( "#expander" ).bind( "wijexpanderbeforeexpand", function(e) {
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    beforeExpand(e)
    
    /// <summary>
    /// Occurs after the content area collapses.
    /// Event type: wijexpanderaftercollapse
    /// Code example:
    /// Supply a callback function to handle the afterCollapse event as an option.
    /// $("#expander").wijexpander({ afterCollapse: function (e) {
    ///		...
    ///    }
    ///	});
    /// Bind to the event by type: wijexpanderaftercollapse.
    /// $( "#expander" ).bind( "wijexpanderaftercollapse", function(e) {
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    afterCollapse(e)
    
    /// <summary>
    /// Occurs after the content area expands.
    /// Event type: wijexpanderafterexpand
    /// Code example:
    /// Supply a callback function to handle the afterExpand event as an option.
    /// $("#expander").wijexpander({ afterExpand: function (e) {
    ///		...
    ///    }
    ///	});
    /// Bind to the event by type: wijexpanderafterexpand.
    /// $( "#expander" ).bind( "wijexpanderafterexpand", function(e) {
    ///		...
    /// });
    /// </summary>
    /// <param name="e" type="Object">jQuery.Event object.</param>
    afterExpand(e)
    */
    $.wijmo.registerWidget(widgetName, wijexpander.prototype);
    $.extend($.wijmo.wijexpander, {
        animations: {
            slide: function (options, additions) {
                var animOpts;
                options = $.extend({
                    easing: "swing",
                    duration: 300
                }, options, additions);
                if(options.expand) {
                    if(options.horizontal) {
                        animOpts = {
                            width: 'show',
                            opacity: 'show'
                        };
                    } else {
                        animOpts = {
                            height: 'show',
                            opacity: 'show'
                        };
                    }
                    options.content.stop(true, true).animate(animOpts, options);
                } else {
                    if(options.horizontal) {
                        animOpts = {
                            width: 'hide',
                            opacity: 'hide'
                        };
                    } else {
                        animOpts = {
                            height: 'hide',
                            opacity: 'hide'
                        };
                    }
                    options.content.stop(true, true).animate(animOpts, options);
                }
            }
        }
    });
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../external/declarations/globalize.d.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts" />
/*globals window,document,jQuery,clearTimeout,setTimeout*/
/*
* Depends:
*	jquery.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jquery.wijmo.wijutil.js
*	jquery.ui.position.js
*	jquery.ui.effects.core.js
*	jquery.mousewheel.js
*	jquery.bgiframe.js
*	jquery.wijmo.wijsuperpanel.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijmenu";
    var wijmenu = (function (_super) {
        __extends(wijmenu, _super);
        function wijmenu() {
            _super.apply(this, arguments);

        }
        wijmenu._itemWidgetName = "wijmenuitem";
        wijmenu.prototype._preventEvent = function (event) {
            event.preventDefault();
            event.stopImmediatePropagation();
        };
        wijmenu.prototype._initState = function () {
            var self = this;
            if(!self.options.items) {
                self.options.items = [];
            }
        };
        wijmenu.prototype._create = function () {
            // Before crete menu items,hide the menu. To avoid show wild uls
            // in the page before init the menu.
                        var self = this, o = self.options, direction = o.direction, mode = o.mode, parentWidget, ele = self.element, sublist, keycode, disabled = o.disabled;
            if($.mobile != null) {
                keycode = $.mobile.keyCode;
            } else {
                keycode = $.ui.keyCode;
            }
            self._initState();
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if(ele.is(":hidden") && ele.wijAddVisibilityObserver) {
                ele.wijAddVisibilityObserver(function () {
                    self.refresh();
                    if(ele.wijRemoveVisibilityObserver) {
                        ele.wijRemoveVisibilityObserver();
                    }
                }, "wijmenu");
            }
            //Fix for jQuery UI 1.10
            ele.data("wijmomenu", $.camelCase(self.widgetFullName));
            //ele.data("wijmomenu", self.widgetName);
            //fix for issus 20651 by Chandler.Zheng on 2012/03/19
            self.clickNameSpace = "click.wijmenudoc" + self._newId();
            //end comment
            ele.hide();
            self.cssPre = "wijmo-wijmenu";
            self.nowIndex = 9999;
            self.activeItem = null;
            self.refresh();
            ele.attr("tabIndex", 0);
            //Add for support disabled option at 2011/7/8
            if(self._getDisabled()) {
                self.disable();
                if(o.disabledState === true) {
                    o.disabled = disabled;
                }
            }
            //end for disabled option
            ele.bind("keydown.wijmenuEvent", function (event) {
                if(self._getDisabled()) {
                    return;
                }
                if(mode === "sliding") {
                    self._getSublist().stop(true, true);
                }
                var activeItem = self.activeItem, isRoot, link, orientation = o.orientation;
                if(activeItem) {
                    isRoot = activeItem._isRoot();
                    sublist = activeItem._getSublist();
                } else {
                    isRoot = true;
                }
                switch(event.keyCode) {
                    case keycode.PAGE_UP:
                        self.previousPage(event);
                        self._preventEvent(event);
                        break;
                    case keycode.PAGE_DOWN:
                        self.nextPage(event);
                        self._preventEvent(event);
                        break;
                    case keycode.UP:
                        if(orientation === "vertical" || mode === "sliding" || !isRoot) {
                            self.previous(event);
                            self._preventEvent(event);
                        }
                        break;
                    case keycode.DOWN:
                        if(orientation === "vertical" || mode === "sliding" || !isRoot) {
                            self.next(event);
                            self._preventEvent(event);
                        } else {
                            if(activeItem) {
                                if(mode === "flyout" && wijmenu._hasVisibleSubMenus(activeItem)) {
                                    if(sublist.is(":hidden")) {
                                        activeItem._showFlyoutSubmenu(event, function () {
                                            self.activate(event, activeItem._getFirstSelectableSubItem());
                                        });
                                    }
                                }
                            }
                        }
                        break;
                    case keycode.RIGHT:
                        if(orientation === "horizontal" && isRoot && mode === "flyout") {
                            if(direction === "rtl") {
                                self.previous(event);
                            } else {
                                self.next(event);
                            }
                            self._preventEvent(event);
                        } else {
                            if(activeItem) {
                                parentWidget = activeItem.getParent();
                                if(direction === "rtl") {
                                    self._keyDownToCloseSubmenu(mode, event, parentWidget);
                                } else {
                                    self._keyDownToOpenSubmenu(activeItem, mode, event, sublist);
                                }
                            }
                        }
                        break;
                    case keycode.LEFT:
                        if(orientation === "horizontal" && isRoot && mode === "flyout") {
                            if(direction === "rtl") {
                                self.next(event);
                            } else {
                                self.previous(event);
                            }
                            self._preventEvent(event);
                        } else {
                            if(activeItem) {
                                parentWidget = activeItem.getParent();
                            }
                            if(direction === "rtl") {
                                self._keyDownToOpenSubmenu(activeItem, mode, event, sublist);
                            } else {
                                self._keyDownToCloseSubmenu(mode, event, parentWidget);
                            }
                        }
                        break;
                    case keycode.ENTER:
                        if(!activeItem) {
                            return;
                        }
                        link = activeItem._getLink();
                        if(mode === "flyout") {
                            break;
                        } else {
                            self.select();
                            if(link.is("a") && link.attr("href") === "#") {
                                self._preventEvent(event);
                            }
                        }
                        break;
                    case keycode.TAB:
                        self.next(event);
                        self._preventEvent(event);
                        break;
                }
            });
        };
        wijmenu.prototype._keyDownToOpenSubmenu = function (activeItem, mode, event, sublist) {
            var self = this;
            if(mode === "flyout" && wijmenu._hasVisibleSubMenus(activeItem)) {
                if(sublist.is(":hidden")) {
                    activeItem._showFlyoutSubmenu(event, function () {
                        self.activate(event, activeItem._getFirstSelectableSubItem());
                    });
                }
            } else if(mode === "sliding") {
                if(sublist.length > 0) {
                    activeItem._getLink().trigger("click", activeItem._getFirstSelectableSubItem());
                }
            }
        };
        wijmenu.prototype._keyDownToCloseSubmenu = function (mode, event, parentWidget) {
            var self = this, o = self.options, breadcrumb;
            if(mode === "flyout") {
                if(parentWidget) {
                    parentWidget._hideCurrentSubmenu(event);
                    self.activate(event, parentWidget);
                }
            } else {
                if(o.backLink && self._backLink && self._backLink.is(":visible")) {
                    self._backLink.trigger("click", function () {
                        if(parentWidget) {
                            self.activate(event, parentWidget);
                        }
                    });
                }
                breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, self.domObject.menucontainer).find("li a");
                if(breadcrumb.length > 0) {
                    breadcrumb.eq(breadcrumb.length - 2).trigger("click", function () {
                        if(parentWidget) {
                            self.activate(event, parentWidget);
                        }
                    });
                }
            }
        };
        wijmenu.prototype._createMenuItems = function () {
            var self = this, items = [], optionItemsLength = self.options.items.length, childMenuCount = self._getSublist().children('li').length, i, w;
            for(i = 0; i < optionItemsLength - childMenuCount; i++) {
                self._getSublist().append('<li>');
            }
            $(">li", self._getSublist()).each(function (i, n) {
                var $li = $(this), options = wijmenu._getMenuItemOptions(self.options, i);
                w = self._createItemWidget($li, options);
                items.push(w);
                self.options.items[i] = w.options;
                return this;
            });
            return items;
        };
        wijmenu.prototype._createItemWidget = function ($li, options) {
            //var itemWidgetName = $.wijmo.wijmenu._itemWidgetName;
            var itemWidgetName = wijmenu._itemWidgetName;
            if($.fn[itemWidgetName]) {
                $li[itemWidgetName](options);
            }
            return wijmenu._getItemWidget($li);
        };
        wijmenu.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                //fix for tfs issue 21458
                //self.disabledDiv.appendTo("body");
                self.disabledDiv.appendTo(self.domObject.menucontainer);
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
            }
        };
        wijmenu.prototype._getDisabled = function () {
            var self = this, o = self.options;
            return o.disabledState === true || o.disabled === true;
        };
        wijmenu.prototype._createDisabledDiv = function (outerEle) {
            return $("<div></div>").css({
                "z-index": "99999",
                position: "absolute",
                width: "100%",
                height: "100%",
                left: 0,
                top: 0
            });
        };
        wijmenu.prototype._innerDestroy = function () {
            var self = this, o = self.options;
            self.destroying = true;
            self[o.mode === "flyout" ? "_killFlyout" : "_killDrilldown"]();
            self._killMenuItems();
            self._killtrigger();
            self._killElement();
            self.destroying = false;
        };
        wijmenu.prototype.destroy = function () {
            /// <summary>
            /// Removes the wijmenu functionality completely.
            /// This returns the element back to its pre-init state.
            /// </summary>
            var self = this;
            this._innerDestroy();
            //Add for support disabled option at 2011/7/8
            if(self.disabledDiv) {
                self.disabledDiv.remove();
                self.disabledDiv = null;
            }
            //end for disabled option
            _super.prototype.destroy.call(this);
        };
        wijmenu.prototype.activate = function (event, item) {
            /// <summary>Actives an menu item by deactivating the current item,
            /// scrolling the new one into view, if necessary,making it the active item,
            /// and triggering a focus event.
            /// </summary>
            /// <param name="event" type="Event">The javascript event.</param>
            /// <param name="item" type="Object">A type of jQuery Or an item widget
            /// which will be set to active
            /// </param>
            if(!item) {
                return;
            }
            var self = this, o = self.options, scrollContainer = self.domObject.scrollcontainer, active, link, needToScroll = false, isInCurrentSublist = true;
            active = (item.jquery ? item : item.element).eq(0);
            if(self.activeItem && self.activeItem.element.get(0) === active.get(0)) {
                return;
            }
            self.deactivate(event);
            self.activeItem = wijmenu._getItemWidget(active);
            link = active.children(":first");
            self._trigger("focus", event, {
                item: self.activeItem
            });
            if(self.options.mode === "sliding") {
                isInCurrentSublist = active.parent().is('.' + o.wijCSS.wijmenuCurrent);
                needToScroll = isInCurrentSublist && self._hasScroll() && scrollContainer.wijsuperpanel('needToScroll', active);
                if(needToScroll) {
                    self._linkContainer.link = link;
                    self._linkContainer.needToFocus = true;
                    scrollContainer.wijsuperpanel("scrollChildIntoView", active);
                }
            }
            link.addClass(o.wijCSS.stateFocus).end();
            self.element.removeAttr("aria-activedescendant");
            self.element.attr("aria-activedescendant", active.attr("id"));
            //fix for issue 20547
            if(isInCurrentSublist && !needToScroll && link.is('a')) {
                link.focus();
            }
        };
        wijmenu.prototype.deactivate = function (event) {
            /// <summary>
            /// The deactivate() method clears the current selection.
            /// This method is useful when reopening a menu
            /// which previously had an item selected.
            /// </summary>
            /// <param name="event" type="Event">The javascript event.  </param>
                        var self = this, o = self.options, active = self.activeItem;
            if(!active) {
                return;
            }
            //Fix an issue that the class can't be removed sometimes when
            //playing animation in FF/Webkit.
            setTimeout(function () {
                active._getLink().removeClass(o.wijCSS.stateFocus).removeAttr("id");
                self._trigger("blur");
            }, 0);
            self.activeItem = null;
        };
        wijmenu.prototype.next = function (event) {
            /// <summary>Selects the next item based on the active one. Selects the first
            /// item if none is active or if the last one is active.</summary>
            /// <param name="event" type="Event">The javascript event.</param>
            //this._move("next", "." + menuitemCss + ":visible:first", event);
            this._move("next", function (widget) {
                return widget._getFirstSelectableSubItem();
            }, event);
        };
        wijmenu.prototype.previous = function (event) {
            /// <summary>Selects the previous item based on the active one. Selects the
            ///last item if none is active or if the first one is active.</summary>
            /// <param name="event" type="Event">The javascript event.</param>
            //this._move("prev", "." + menuitemCss + ":visible:last", event);
            this._move("previous", function (widget) {
                return widget._getLastSelectableSubItem();
            }, event);
        };
        wijmenu.prototype.first = function () {
            /// <summary>
            /// The first() method defines the active item as the first menu item.
            /// </summary>
            /// <returns type="Boolean" />
                        var self = this, active, parent, firstItem;
            if(!self.activeItem) {
                return false;
            }
            active = self._getActiveItemElement();
            parent = self.activeItem._getParentOrMenu();
            firstItem = parent._getFirstSelectableSubItem();
            return firstItem && active[0] === firstItem.element[0];
        };
        wijmenu.prototype.last = function () {
            /// <summary>
            /// The last() method defines the active item as the last menu item.
            /// </summary>
            /// <returns type="Boolean" />
                        var self = this, active, parent, lastItem;
            if(!self.activeItem) {
                return false;
            }
            active = self._getActiveItemElement();
            parent = self.activeItem._getParentOrMenu();
            lastItem = parent._getLastSelectableSubItem();
            return lastItem && active[0] === lastItem.element[0];
        };
        wijmenu.prototype.nextPage = function (event) {
            /// <summary>This method is similar to the "next" method,
            ///but it jumps a whole page to the next page.</summary>
            /// <param name="event" type="Event">The javascript event.</param>
                        var self = this, activeItem = self._getActiveItemElement(), base, height, result, widget, itemToActivate;
            if(activeItem) {
                widget = self.activeItem._getParentOrMenu();
            } else {
                widget = self;
                activeItem = self._getFirstSelectableSubItem();
            }
            if(self.options.mode === "sliding" && self._hasScroll()) {
                if(!activeItem || self.last()) {
                    self.activate(event, widget._getFirstSelectableSubItem());
                    return;
                }
                base = activeItem.offset().top;
                height = self.options.maxHeight;
                result = wijmenu._getSelectableSubItems(widget, function (n) {
                    var node = $(n.element), close = height - (node.offset().top - base + node.height()), lineheight = node.height();
                    return close < lineheight && close > -lineheight;
                });
                if(!result.length) {
                    result = widget._getLastSelectableSubItem();
                } else {
                    //get the last of the result;
                    result = result[result.length - 1];
                }
                self.activate(event, result);
            } else {
                if(!activeItem || self.last()) {
                    itemToActivate = widget._getFirstSelectableSubItem();
                } else {
                    itemToActivate = widget._getLastSelectableSubItem();
                }
                self.activate(event, itemToActivate);
            }
        };
        wijmenu.prototype.previousPage = function (event) {
            /// <summary>This method is silimlar to the "previous" method,
            ///but it jumps a whole page to the previous page.</summary>
            /// <param name="event" type="Event">The javascript event.</param>
                        var self = this, activeItem = self._getActiveItemElement(), base, height, result, widget, itemToActivate;
            if(activeItem) {
                widget = self.activeItem._getParentOrMenu();
            } else {
                widget = self;
                activeItem = self._getFirstSelectableSubItem();
            }
            if(self.options.mode === "sliding" && self._hasScroll()) {
                if(!activeItem || self.first()) {
                    self.activate(event, widget._getLastSelectableSubItem());
                    return;
                }
                base = activeItem.offset().top;
                height = self.options.maxHeight;
                result = wijmenu._getSelectableSubItems(widget, function (n) {
                    var node = $(n.element), close = node.offset().top - base + height - node.height(), lineheight = node.height();
                    return close < lineheight && close > -lineheight;
                });
                if(!result.length) {
                    result = widget._getFirstSelectableSubItem();
                } else {
                    //get the first of the result;
                    result = result[0];
                }
                self.activate(event, result);
            } else {
                if(!activeItem || self.first()) {
                    itemToActivate = widget._getLastSelectableSubItem();
                } else {
                    itemToActivate = widget._getFirstSelectableSubItem();
                }
                self.activate(event, itemToActivate);
            }
        };
        wijmenu.prototype.select = function (event) {
            /// <summary>Selects the active item,triggering the select event for that
            ///item. This event is useful for custom keyboard handling.</summary>
            /// <param name="event" type="Event">The javascript event.</param>
                        var self = this, activeItem = self.activeItem, selected;
            self._trigger("select", event, {
                item: activeItem
            });
            //if the checkable is true, toggle the selected value of menuitem
            if(self.options.checkable) {
                selected = !activeItem.options.selected;
                activeItem._setOption("selected", selected);
            }
        };
        wijmenu.prototype._getActiveItemElement = function () {
            return this.activeItem ? this.activeItem.element : null;
        };
        wijmenu.prototype.setItemDisabled = function (selector, disabled) {
            /// <summary>
            /// The setItemDisabled(selector, disabled) method allows the user
            /// to disable a specific menu item.
            /// </summary>
            /// <param name="selector" type="jQuery selector">
            ///		Indicates the item to be disabled.</param>
            /// <param name="disabled" type="Boolean">
            ///		If the value is true, the item is disabled;
            ///		Otherwise, the item is enabled.
            /// </param>
                        var items = $(selector, this.element), o = this.options;
            items.find("." + o.wijCSS.wijmenuItem + ">a").attr("disabled", disabled);
            items.find(">a").toggleClass(o.wijCSS.stateDisabled, disabled);
        };
        wijmenu.prototype._setOption = ///set options
        function (key, value) {
            var self = this;
            if(self.destroying) {
                return;
            }
            if(self["_set_" + key]) {
                self["_set_" + key](value);
            }
            self.options[key] = value;
            //Add for support disabled option at 2011/7/8
            if(key === "disabled") {
                self._handleDisabledOption(value, self.domObject.menucontainer);
            }
            //end for disabled option
                    };
        wijmenu.prototype._set_items = function (value) {
            var self = this;
            //when set items by options, clear the old items at first
            self._getSublist().children().remove();
            self.options.items = value;
            self.refresh();
        };
        wijmenu.prototype._set_mode = function (value) {
            var self = this;
            self._innerDestroy();
            self.options.mode = value;
            self.refresh();
        };
        wijmenu.prototype._set_backLink = function (value) {
            var self = this, o = self.options, breadcrumb;
            this.options.backLink = value;
            if(self.options.mode === 'sliding') {
                self._killDrilldown();
                self._drilldown();
                breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, self.domObject.menucontainer);
                self._resetDrilldownMenu(breadcrumb);
            }
        };
        wijmenu.prototype._set_direction = function (value) {
            var self = this;
            self._innerDestroy();
            self.refresh();
        };
        wijmenu.prototype._set_orientation = function (value) {
            var self = this, menuContainer = self.domObject.menucontainer, direction = self.options.direction, cssPre = "ui-icon-triangle-1-", directionClass = direction === "rtl" ? "w" : "e", oldCss = value === "horizontal" ? directionClass : "s", newCss = value === "horizontal" ? "s" : directionClass;
            menuContainer.removeClass(self.cssPre + "-vertical " + self.cssPre + "-horizontal");
            if(self.options.mode === "flyout") {
                menuContainer.addClass(self.cssPre + "-" + value);
                $.each(self.getItems(), function (i, n) {
                    if(n.getItems().length === 0) {
                        return;
                    }
                    n._getLink().find("." + cssPre + oldCss).removeClass(cssPre + oldCss + " " + cssPre + newCss).addClass(cssPre + newCss);
                });
            } else {
                menuContainer.addClass(self.cssPre + "-vertical");
            }
        };
        wijmenu.prototype._getTriggerEle = function () {
            return wijmenu._getOuterElement(this.options.trigger, "." + this.options.wijCSS.wijmenu);
        };
        wijmenu.prototype._set_triggerEvent = function (value) {
            var self = this, o = self.options, triggerEle = self._getTriggerEle();
            self._killtrigger();
            o.triggerEvent = value;
            if(triggerEle.length > 0) {
                self._initTrigger(triggerEle);
            }
            if(o.mode === "flyout") {
                self._killFlyout();
                self._flyout();
            }
        };
        wijmenu.prototype._set_trigger = function (value) {
            var self = this, o = self.options, triggerEle;
            self._killtrigger();
            o.trigger = value;
            triggerEle = self._getTriggerEle();
            if(triggerEle.length > 0) {
                self._initTrigger(triggerEle);
            }
            if(o.mode === "flyout") {
                self._killFlyout();
                self._flyout();
            }
        };
        wijmenu.prototype._initTrigger = function (triggerEle) {
            var o = this.options, event = o.triggerEvent, self = this, menuContainer = self.domObject.menucontainer, namespace = ".wijmenuEvent";
            if(triggerEle.is("iframe")) {
                triggerEle = $(triggerEle.get(0).contentWindow.document);
            }
            switch(event) {
                case "click":
                    triggerEle.bind(event + namespace, function (e) {
                        if(o.mode !== "popup") {
                            self._displayMenu(e);
                        }
                        e.stopPropagation();
                    });
                    break;
                case "mouseenter":
                    triggerEle.bind(event + namespace, function (e) {
                        self._displayMenu(e);
                        e.stopPropagation();
                    });
                    break;
                case "dblclick":
                    triggerEle.bind(event + namespace, function (e) {
                        self._displayMenu(e);
                        e.stopPropagation();
                    });
                    break;
                case "rtclick":
                    triggerEle.bind("contextmenu" + namespace, function (e) {
                        menuContainer.hide();
                        self._displayMenu(e);
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    break;
            }
        };
        wijmenu.prototype._killtrigger = function () {
            var o = this.options, triggerEle;
            if(o.trigger !== "") {
                triggerEle = $(o.trigger);
                if(triggerEle.is("iframe")) {
                    triggerEle = $(triggerEle.get(0).contentWindow.document);
                }
                if(triggerEle && triggerEle.length > 0) {
                    triggerEle.unbind(".wijmenuEvent").unbind("wijmenuEvent");
                }
            }
        };
        wijmenu.prototype._move = function (driection, fnDefault, event) {
            var self = this, active = self._getActiveItemElement(), next, parent, widget;
            if(!active || !active.length) {
                self.activate(event, fnDefault(self));
                return;
            }
            widget = wijmenu._getItemWidget(active);
            next = widget[driection]()//next/previuos
            ;
            parent = widget._getParentOrMenu();
            if(next) {
                self.activate(event, next);
            } else {
                self.activate(event, fnDefault(parent));
            }
        };
        wijmenu.prototype.refresh = function () {
            /// <summary>
            /// The method is used to refresh menu when item in the menu is
            /// added or replaeced by DOM operations,for example,
            /// menu.append("<li><a href='#'>new item</a></li>").wijmenu("refresh")
            /// </summary>
                        var self = this, ele = self.element, o = self.options, direction = o.direction, scrollcontainer, menucontainer, domObject, triggerEle, breadcrumb;
            if(self.domObject) {
                self._innerDestroy();
            }
            if(ele.is("ul")) {
                self._rootMenu = ele;
                scrollcontainer = ele.wrap("<div></div>").parent();
                menucontainer = scrollcontainer.wrap("<div></div>").parent();
            } else if(ele.is("div")) {
                self._rootMenu = $("ul:first", ele);
                scrollcontainer = ele;
                menucontainer = ele.wrap("<div></div>").parent();
            } else {
                return;
            }
            if(direction === "rtl") {
                self._rootMenu.addClass(o.wijCSS.wijmenuRtl);
            }
            scrollcontainer.addClass("scrollcontainer checkablesupport");
            menucontainer.addClass(o.wijCSS.widget).addClass(o.wijCSS.header).addClass(o.wijCSS.wijmenu).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).attr("aria-activedescendant", o.wijCSS.activeMenuitem);
            if(o.orientation === "horizontal" && o.mode === "flyout") {
                menucontainer.addClass(o.wijCSS.wijmenuHorizontal);
            }
            domObject = {
                scrollcontainer: scrollcontainer,
                menucontainer: menucontainer
            };
            self.domObject = domObject;
            self._getSublist().data("topmenu", true);
            if(!self._getSublist().hasClass(o.wijCSS.wijmenuList)) {
                self._getSublist().addClass(o.wijCSS.wijmenuList).addClass(o.wijCSS.helperReset);
            }
            self._items = self._createMenuItems();
            ele.show();
            ele.delegate("li>." + o.wijCSS.wijmenuLink, "mouseenter.wijmenuEvent", function () {
                var itemDisabled = $(this).hasClass(o.wijCSS.stateDisabled);
                if(self._getDisabled() || itemDisabled) {
                    return;
                }
                $(this).addClass(o.wijCSS.stateHover);
            }).delegate("li>." + o.wijCSS.wijmenuLink, "mouseleave.wijmenuEvent", function () {
                var itemDisabled = $(this).hasClass(o.wijCSS.stateDisabled);
                if(self._getDisabled() || itemDisabled) {
                    return;
                }
                $(this).removeClass(o.wijCSS.stateHover);
                if($(this).data("subMenuOpened")) {
                    $(this).addClass(o.wijCSS.stateActive);
                }
            });
            this[o.mode === "flyout" ? "_flyout" : "_drilldown"]();
            if(o.trigger !== "") {
                triggerEle = self._getTriggerEle();
                if(triggerEle.length > 0) {
                    menucontainer.hide();
                    self._initTrigger(triggerEle);
                }
            }
            $(document).bind(self.clickNameSpace, function (e) {
                ///fixed when click the breadcrumb choose item link to show
                /// the root menu in sliding menu.
                var t = o.trigger;
                if($(e.target).parent().is("." + o.wijCSS.wijmenuAllLists)) {
                    return;
                }
                // fix tfs issue 20650  by Chandler.Zheng on 2012-03-19
                if($(e.target).closest(o.trigger).is(o.trigger)) {
                    return;
                }
                //end comments
                var obj = $(e.target).closest("." + o.wijCSS.wijmenu);
                if(obj.length === 0) {
                    if(o.mode === "sliding") {
                        breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, menucontainer);
                        // fixed a bug, when the trigger is not seted.
                        // when click the document, trigger this method!
                        if(o.trigger === "") {
                            return;
                        }
                        self._resetDrilldownMenu(breadcrumb);
                    } else if(o.mode === "flyout" && o.triggerEvent !== "mouseenter") {
                        self._hideAllMenus(e);
                        return;
                    }
                    if(triggerEle && triggerEle.length > 0) {
                        self._hideMenu(e);
                    }
                }
            });
        };
        wijmenu.prototype._flyout = function () {
            var container = this.domObject.menucontainer, o = this.options, items = this.getItems();
            container.attr("role", "menu");
            if(o.orientation === "horizontal") {
                container.attr("role", "menubar");
            }
            $.each(items, function (index, item) {
                item._flyout();
            });
        };
        wijmenu.prototype._hideAllMenus = function (e) {
            var self = this, container, outerTrigger, fnHideSubmenu = function (menuitem) {
                if(menuitem.getItems().length > 0) {
                    $.each(menuitem.getItems(), function (i, n) {
                        fnHideSubmenu(n);
                    });
                    menuitem._hideSubmenu(false, e);
                }
            };
            $.each(self._items, function (i, n) {
                fnHideSubmenu(n);
            });
            if(self.options.trigger !== "") {
                container = self.domObject.menucontainer;
                if(container.data("isAnimated")) {
                    return;
                }
                /*if (container.is(":animated")) {
                return;
                }*/
                // if the trigger is outer of the menu,
                //when hide all menus hide the root menu.
                outerTrigger = self._getTriggerEle();
                if(outerTrigger.length === 0) {
                    return;
                }
                self._hideMenu(e);
            }
        };
        wijmenu.prototype.hideAllMenus = function (e) {
            /// <summary>
            /// Hide all displayed menus.
            /// </summary>
            this._hideAllMenus(e);
        };
        wijmenu.prototype._killFlyout = function () {
            $.each(this.getItems(), function () {
                this._killFlyout();
            });
        };
        wijmenu.prototype._killElement = function () {
            var self = this, o = self.options, ele = self._getSublist();
            ele.removeClass(o.wijCSS.wijmenuList).removeClass(o.wijCSS.helperReset).removeClass(o.wijCSS.wijmenuContent).removeClass(o.wijCSS.helperClearFix);
            //self.domObject.menucontainer.removeClass("");
            $(document).unbind(self.clickNameSpace);
            //remove warping
            if(self.element.is("ul")) {
                self.element.unwrap().unwrap();
            } else {
                self.element.unwrap();
            }
            //For fix the tfs issue id 24830. js error: object is null or undefined
            self.domObject = null;
            self.element.removeData("topmenu").removeData("firstLeftValue").removeData("domObject");
            //self.element.removeData("domObject").removeData("topmenu")
            //.removeData("firstLeftValue");
            ele.undelegate(".wijmenuEvent");
        };
        wijmenu.prototype._killMenuItems = function () {
            var self = this, items = self.getItems(), i;
            //$.each(self.getItems(), function (i, n) {
            //	n.destroy(true);
            //});
            for(i = items.length - 1; i >= 0; i--) {
                items[i].destroy(true);
            }
            self._items.length = 0;
        };
        wijmenu.prototype._sroll = function () {
            var scroll = this.domObject.scrollcontainer, options = $.extend({
                hScroller: {
                    scrollBarVisibility: "hidden"
                }
            }, this.options.superPanelOptions);
            scroll.height(this.options.maxHeight);
            scroll.wijsuperpanel(options);
        };
        wijmenu.prototype._initScrollCallback = function () {
            var self = this, scrollContainer = self.domObject.scrollcontainer;
            self._linkContainer = {
                link: null,
                needToFocus: false
            };
            scrollContainer.wijsuperpanel({
                scrolled: function () {
                    var link = self._linkContainer.link;
                    if(self._linkContainer.needToFocus && link && link.is('a')) {
                        link.focus();
                        self._linkContainer.needToFocus = false;
                    }
                }
            });
        };
        wijmenu.prototype._resetScroll = function (widget) {
            var self = this, mycontainer = self._rootMenu.parent(), fixPadding = 5, scrollcontainer = self.domObject.scrollcontainer, sublist = widget._getSublist();
            mycontainer.height(sublist.height());
            scrollcontainer.wijsuperpanel("option", "hScroller", {
                scrollValue: 0
            });
            scrollcontainer.wijsuperpanel("option", "vScroller", {
                scrollValue: 0
            });
            scrollcontainer.wijsuperpanel("paintPanel");
            if(self._hasScroll()) {
                if(sublist.prev().length > 0) {
                    fixPadding = sublist.prev().css("padding-left").replace(/px/g, "");
                }
                sublist.width(scrollcontainer.find(".wijmo-wijsuperpanel-contentwrapper" + ":first").width() - fixPadding);
                //because the scroll bar has 16px width, there has a possible
                //that the height of ul will modified after appending scrollbar
                //so there should get the height of container again, and repaint panel
                mycontainer.height(sublist.height());
                scrollcontainer.wijsuperpanel("paintPanel");
            }
        };
        wijmenu.prototype._hasScroll = function () {
            var scroll = this.domObject.scrollcontainer;
            //Fix for jQuery UI 1.10
            return scroll.data("wijmoWijsuperpanel").vNeedScrollBar;
            //return scroll.data("wijsuperpanel").vNeedScrollBar;
                    };
        wijmenu.prototype._resetDrillChildMenu = function (el) {
            var o = this.options;
            el.removeClass(o.wijCSS.wijmenuScroll).removeClass(o.wijCSS.wijmenuCurrent).height("auto");
        };
        wijmenu.prototype._resetDrilldownMenu = function (breadcrumb, callback) {
            var self = this, o = self.options, ele = self._getSublist(), container = self.domObject.menucontainer, crumbDefaultHeader = $('<li>' + o.crumbDefaultText + '</li>').addClass(o.wijCSS.wijmenuBreadcrumbText), fnResetSublists = function (items) {
                $.each(items, function (i, n) {
                    var ul = n._getSublist(), childItems = n.getItems();
                    ul.hide();
                    self._resetDrillChildMenu(ul);
                    if(childItems.length > 0) {
                        fnResetSublists(childItems);
                    }
                });
            };
            $('.' + o.wijCSS.wijmenuCurrent, container).removeClass(o.wijCSS.wijmenuCurrent);
            ele.animate({
                left: 0
            }, o.showDuration, null, function () {
                fnResetSublists(self.getItems());
                ele.addClass(o.wijCSS.wijmenuCurrent);
                if(callback) {
                    callback();
                }
            });
            $('.' + o.wijCSS.wijmenuAllLists, container).find('span').remove();
            breadcrumb.empty().append(crumbDefaultHeader);
            $('.' + o.wijCSS.wijmenuFooter, container).empty().hide();
            self._resetScroll(self);
        };
        wijmenu.prototype._drilldown = function () {
            var self = this, ele = self._getSublist(), container = self.domObject.menucontainer.attr("role", "menu"), containerWidth, o = self.options, direction = //fixPadding,
            o.direction, breadcrumb = $('<ul></ul>').addClass(o.wijCSS.wijmenuBreadcrumb).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix), crumbDefaultHeader = $('<li>' + o.crumbDefaultText + '</li>').addClass(o.wijCSS.wijmenuBreadcrumbText), firstCrumb = $('<li><a href="#">' + o.topLinkText + '</a></li>').addClass(o.wijCSS.wijmenuAllLists);
            //wraping mycontainer
            ele.wrap("<div>").parent().css("position", "relative");
            container.addClass(o.wijCSS.wijmenuIpod).addClass(o.wijCSS.wijmenuContainer);
            if(o.backLink) {
                breadcrumb.addClass(o.wijCSS.wijmenuFooter).appendTo(container).hide();
            } else {
                breadcrumb.addClass(o.wijCSS.wijmenuHeader).prependTo(container);
            }
            if(!o.backLink) {
                breadcrumb.append(crumbDefaultHeader);
            }
            containerWidth = container.width();
            ele.addClass(o.wijCSS.wijmenuContent).addClass(o.wijCSS.wijmenuCurrent).addClass(o.wijCSS.content).addClass(o.wijCSS.helperClearFix).css({
                width: containerWidth
            });
            $.each(self.getItems(), function (i, n) {
                n._setDrilldownUlStyle();
            });
            self._sroll();
            self._initScrollCallback();
            self._resetScroll(self);
            self.element.data("firstLeftValue", parseFloat(ele.css('left')));
            ele.delegate("li>." + o.wijCSS.wijmenuLink, "click", function (e, itemWidgetToActive) {
                var li = $(this).parent(), itemDisabled = li.attr("disabled"), nextList, parentUl, parentLeft, crumbText, newCrumb, nextLeftVal, footer, setPrevMenu, hasVisibleSubMenu, itemWidget = wijmenu._getItemWidget(li), backlinkIcon, backlinkText;
                if(self._getDisabled() || itemDisabled) {
                    return;
                }
                if(self._isSliding) {
                    return;
                }
                ele.stop(true, true);
                hasVisibleSubMenu = wijmenu._hasVisibleSubMenus(itemWidget);
                if(!hasVisibleSubMenu) {
                    self._leafNodeClick(e, itemWidget, breadcrumb);
                    return;
                }
                nextList = itemWidget._getSublist();
                //prevent dblclick.
                if(nextList.hasClass(o.wijCSS.wijmenuCurrent)) {
                    return;
                }
                //end comments.
                if(!self._trigger("showing", e, itemWidget)) {
                    return;
                }
                self._isSliding = true;
                parentUl = itemWidget._getParentOrMenu()._getSublist();
                parentLeft = (parentUl.data("topmenu")) ? 0 : parseFloat(ele.css('left'));
                if(direction === "rtl") {
                    nextLeftVal = Math.round(parentLeft + parseFloat(container.width().toString()));
                } else {
                    nextLeftVal = Math.round(parentLeft - parseFloat(container.width().toString()));
                }
                footer = $('.' + o.wijCSS.wijmenuFooter, container);
                setPrevMenu = function (backlink, current) {
                    var b = backlink, c = $('.' + o.wijCSS.wijmenuCurrent, container), prevList, widget;
                    if(c.get(0) === self._getSublist().get(0)) {
                        return;
                    }
                    if(current) {
                        prevList = current._getSublist();
                        widget = current;
                    } else {
                        prevList = c.parents('ul:eq(0)');
                        widget = wijmenu._getItemWidget(c.parent())._getParentOrMenu();
                    }
                    c.hide().attr('aria-expanded', 'false');
                    self._resetDrillChildMenu(c);
                    self._resetScroll(widget);
                    prevList.addClass(o.wijCSS.wijmenuCurrent).attr('aria-expanded', 'true');
                    if(prevList.hasClass(o.wijCSS.wijmenuContent)) {
                        b.remove();
                        footer.hide();
                    }
                };
                // show next menu
                self._resetDrillChildMenu(parentUl);
                self._resetScroll(itemWidget);
                self._slidingAnimation(ele, nextLeftVal, function () {
                    self._trigger("shown", e, itemWidget);
                    self.activate(e, itemWidgetToActive || itemWidget);
                    //add comments for tfs issue 18483
                    self.select(e);
                    //end comments.
                    self._isSliding = false;
                });
                nextList.show().addClass(o.wijCSS.wijmenuCurrent).attr('aria-expanded', 'true');
                // initialize "back" link
                if(o.backLink) {
                    if(footer.find('a').size() === 0) {
                        footer.show();
                        backlinkIcon = $("<span></span>").addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowLeft);
                        backlinkText = $('<span></span>').addClass(o.wijCSS.wijmenuBacklinktext);
                        self._backLink = $('<a href="#"></a>').append(backlinkIcon).append(backlinkText).appendTo(footer).click(function (e, callback) {
                            // ----- show the previous menu
                            if(self._getDisabled()) {
                                return;
                            }
                            var currentItemWidget = self._getCurrentItemInSliding(), b = $(this), prevLeftVal;
                            if(!self._trigger("hidding", e, currentItemWidget)) {
                                return;
                            }
                            ele.stop(true, true);
                            if(direction === "rtl") {
                                prevLeftVal = Math.round(ele.css('left').replace("px", "")) - Math.round(container.width());
                            } else {
                                prevLeftVal = Math.round(ele.css('left').replace("px", "")) + Math.round(container.width());
                                ///to fix click the back button too quickly.
                                ///The menu display wrong.
                                if(prevLeftVal > parentLeft) {
                                    return;
                                }
                            }
                            self._slidingAnimation(ele, prevLeftVal, function () {
                                self._trigger("hidden", e, currentItemWidget);
                                setPrevMenu(b);
                                if(callback) {
                                    callback();
                                }
                            });
                            e.preventDefault();
                        });
                        backlinkText.width(footer.width() - backlinkIcon.width());
                        backlinkText.text(o.backLinkText);
                    }
                } else// or initialize top breadcrumb
                 {
                    if(breadcrumb.find('li').size() === 1) {
                        breadcrumb.empty().append(firstCrumb);
                        firstCrumb.find('a').click(function (e, callback) {
                            var targetCrumb = $(this).parent(), currentItemWidget = self._getCurrentItemInSliding();
                            self._slidingMenu(e, targetCrumb, currentItemWidget, null, function (item) {
                                if(!item) {
                                    self._resetDrilldownMenu(breadcrumb, callback);
                                } else {
                                    setPrevMenu(null, item);
                                    if(callback) {
                                        callback();
                                    }
                                }
                            });
                            e.preventDefault();
                        });
                    }
                    $('.' + o.wijCSS.wijmenuCurrentCrumb, container).removeClass(o.wijCSS.wijmenuCurrentCrumb);
                    crumbText = itemWidget._getLink().text();
                    newCrumb = $("<li></li>").addClass(o.wijCSS.wijmenuCurrentCrumb).append($('<a href="#">' + crumbText + '</a>').addClass(o.wijCSS.wijmenuCrumb));
                    newCrumb.appendTo(breadcrumb).find('a').click(function (e, callback) {
                        if(self._getDisabled()) {
                            return;
                        }
                        var targetCrumb = $(this).parent(), currentItemWidget;
                        if(!targetCrumb.is('.' + o.wijCSS.wijmenuCurrentCrumb)) {
                            currentItemWidget = self._getCurrentItemInSliding();
                            self._slidingMenu(e, targetCrumb, currentItemWidget, itemWidget, function (item) {
                                setPrevMenu(null, item);
                                if(callback) {
                                    callback();
                                }
                            });
                        }
                        e.preventDefault();
                    });
                    newCrumb.prev().append($('<span></span>').addClass(o.wijCSS.icon).addClass(o.wijCSS.iconCaratRight));
                }
                if($(this).attr("href") === "#") {
                    e.preventDefault();
                }
            });
        };
        wijmenu.prototype._slidingMenu = function (e, targetCrumb, currentItem, targetItem, animationCallback) {
            var self = this, ele = self._getSublist(), direction = self.options.direction, container = self.domObject.menucontainer, containerWidth = container.width(), level = targetCrumb.parent().children().length - 1, newLeftVal, _targetItem, crumb, hiddenCallback, fnSlidingAnimation = function (targetItem, level, callback) {
                newLeftVal = (direction === "rtl" ? 1 : -1) * level * containerWidth;
                self._slidingAnimation(ele, newLeftVal, function () {
                    if(callback) {
                        callback(targetItem);
                    }
                });
            }, fnGetTargetItem = function (currentItem, targetItem) {
                var hidding;
                if(currentItem !== targetItem) {
                    hidding = self._trigger("hidding", e, currentItem);
                    if(hidding) {
                        level--;
                        if(hiddenCallback) {
                            hiddenCallback();
                        }
                        hiddenCallback = function () {
                            self._trigger("hidden", e, currentItem);
                        };
                        return fnGetTargetItem(currentItem.getParent(), targetItem);
                    }
                }
                return currentItem;
            };
            _targetItem = fnGetTargetItem(currentItem, targetItem);
            if(_targetItem !== currentItem) {
                fnSlidingAnimation(_targetItem, level, function () {
                    if(hiddenCallback) {
                        hiddenCallback();
                    }
                    if(animationCallback) {
                        animationCallback(_targetItem);
                    }
                });
                crumb = targetCrumb.parent().children().eq(level);
                crumb.addClass('wijmo-wijmenu-current-crumb').find('span').remove();
                crumb.nextAll().remove();
            }
        };
        wijmenu.prototype._getCurrentItemInSliding = function () {
            var self = this, container = self.domObject.menucontainer, c = $('.wijmo-wijmenu-current', container), currentItemWidget = wijmenu._getItemWidget(c.parent());
            return currentItemWidget;
        };
        wijmenu.prototype._leafNodeClick = function (e, itemWidget, breadcrumb) {
            var self = this, o = self.options, triggers;
            self.activate(e, itemWidget);
            self.select(e);
            if(o.trigger) {
                triggers = self._getTriggerEle();
                if(triggers.length) {
                    self._hideMenu(e);
                    self._resetDrilldownMenu(breadcrumb);
                }
            }
            if(itemWidget._getLink().attr("href") === "#") {
                e.preventDefault();
            }
        };
        wijmenu.prototype._slidingAnimation = function (ele, left, callback) {
            var o = this.options.slidingAnimation;
            if(o && !o.disabled) {
                ele.stop(true, true).animate({
                    left: left
                }, o.duration, o.easing, callback);
            } else {
                ele.css("left", left);
                callback.call(this);
            }
        };
        wijmenu.prototype._killDrilldown = function () {
            var ele = this._getSublist(), o = this.options, domObject = this.domObject, style = {
                width: "",
                height: ""
            };
            ele.css(style).removeClass(o.wijCSS.content);
            //fix bug that set mode as 'sliding' at setOptions stage
            // will remove the self.element from the page
            if(domObject.scrollcontainer && domObject.scrollcontainer.parent().length > 0) {
                domObject.scrollcontainer.css(style);
                domObject.scrollcontainer.wijsuperpanel("destroy");
                domObject.scrollcontainer.removeClass("wijmo-wijsuperpanel").append(ele);
            }
            ele.prevAll().remove();
            domObject.menucontainer.removeClass(o.wijCSS.wijmenuIpod).removeClass(o.wijCSS.wijmenuContainer);
            $('.' + o.wijCSS.wijmenuCurrent, domObject.menucontainer).removeClass(o.wijCSS.wijmenuCurrent);
            $("." + o.wijCSS.wijmenuBreadcrumb, domObject.menucontainer).remove();
            ele.undelegate("li>." + o.wijCSS.wijmenuLink, "click");
            $("ul", ele).css({
                left: "",
                width: ""
            });
            ele.css("left", "");
            domObject.scrollcontainer = domObject.menucontainer.children(":first");
        };
        wijmenu.prototype._displayMenu = function (e) {
            var self = this, o = self.options, animationOptions, direction, showAnimation, menucontainer = self.domObject.menucontainer, triggerEle = $(e.target), haveNoVisibleChild = !wijmenu._hasVisibleSubMenus(self);
            if(menucontainer.is(":visible") || haveNoVisibleChild) {
                return;
            }
            if(!self._trigger("showing", e, self)) {
                return;
            }
            //self._trigger("showing", e, self);
            menucontainer.show();
            self._setPosition(triggerEle);
            self.nowIndex++;
            self._setZindex(menucontainer, self.nowIndex);
            menucontainer.hide();
            animationOptions = {
                context: menucontainer,
                show: true
            };
            direction = o.direction === "rtl" ? "right" : "left";
            showAnimation = $.extend({
            }, {
                option: {
                    direction: direction
                }
            }, o.animation, o.showAnimation);
            wijmenu._animateFlyoutMenu(showAnimation, animationOptions, function () {
                //add the event shown
                self._trigger("shown", e, self);
            });
            //$.wijmo.wijmenu._animateFlyoutMenu(showAnimation, animationOptions);
            self._isClickToOpen = o.triggerEvent === "click";
            this.element.data("shown", true);
        };
        wijmenu.prototype._hideMenu = function (e) {
            var self = this, o = self.options, sublist = this.domObject.menucontainer, animations = wijmenu.animations, animationOptions, hideAnimation;
            if(!this.element.data("shown")) {
                return;
            }
            //add event hidding
            if(!self._trigger("hidding", e, self)) {
                return;
            }
            this.element.data("shown", false);
            if($.fn.wijhide) {
                animationOptions = {
                    context: sublist,
                    show: false
                };
                hideAnimation = $.extend({
                }, o.animation, o.hideAnimation);
                sublist.wijhide(hideAnimation, animations, animationOptions, null, function () {
                    self._setZindex(sublist, null);
                    sublist.attr("aria-hidden", true);
                    self._trigger("hidden", e, self);
                });
            } else {
                sublist.hide().attr("aria-hidden", true);
                self._setZindex(sublist, null);
                self._trigger("hidden", e, self);
            }
        };
        wijmenu.prototype._setZindex = function (ele, value) {
            var domObject = this.domObject, menucontainer;
            if(!domObject) {
                return;
            }
            menucontainer = domObject.menucontainer;
            //fixed a bug which menu cannot shows up above other elements
            //when set an outer triggerEle
            if(ele.get(0) === menucontainer.get(0)) {
                if(value) {
                    menucontainer.css("z-index", value);
                } else {
                    menucontainer.css("z-index", "");
                }
                return;
            }
            if(value) {
                ele.parent().css("z-index", 999);
                ele.css("z-index", value);
                if($.browser.msie && parseInt($.browser.version) < 8 && menucontainer.css("z-index") === 0) {
                    menucontainer.css("z-index", 9950);
                }
            } else {
                ele.css("z-index", "");
                ele.parent().css("z-index", "");
                if($.browser.msie && parseInt($.browser.version) < 8 && $("ul:visible", this._getSublist()).length === 0 && menucontainer.css("z-index") === 9950) {
                    menucontainer.css("z-index", "");
                }
            }
        };
        wijmenu.prototype._setPosition = function (triggerEle) {
            var pOption = this._getPosition(), obj = {
                of: triggerEle
            }, menuContainer = this.domObject.menucontainer;
            menuContainer.css({
                left: '0',
                top: '0',
                position: 'absolute'
            });
            //now do not support the equal-height menu.
            /*
            if (tag) {
            var parentUl = item.parent().parent();
            if (!parentUl.is(".wijmo-wijmenu-child")) {
            parentUl = this.element.data("domObject").menucontainer;
            }
            obj = { of: parentUl };
            }
            */
            menuContainer.position($.extend(obj, pOption));
        };
        wijmenu.prototype._getPosition = function () {
            var o = this.options, direction = o.direction, pOption = direction === "rtl" ? {
                my: 'right top',
                at: 'right bottom'
            } : {
                my: 'left top',
                at: 'left bottom'
            };
            pOption = $.extend(pOption, o.position);
            return pOption;
        };
        wijmenu.prototype._getFirstSelectableSubItem = function () {
            return wijmenu._getFirstSelectableSubItem(this);
        };
        wijmenu.prototype._getLastSelectableSubItem = function () {
            return wijmenu._getLastSelectableSubItem(this);
        };
        wijmenu.prototype.add = function (menuItem, position) {
            /// <summary>
            /// Adds a child menuItem to the menuItem.
            /// </summary>
            /// <param name="menuItem" type="String,Object">
            /// which menuItem to be added
            /// 1.markup html.such as "<a>menuItem</a>" as a menuItem.
            /// 2.object options according to the options of wijmenuItem.
            /// </param>
            /// <param name="position" type="Int">
            /// the position to insert at
            /// </param>
            wijmenu._add(this, menuItem, position);
        };
        wijmenu.prototype._getSublist = function () {
            return this._rootMenu;
        };
        wijmenu.prototype.getItems = function () {
            ///<summary>
            /// Gets the collection of child items.
            ///</summary>
            return this._items;
        };
        wijmenu.prototype.remove = /// <summary>
        /// Remove an item from the menu.
        /// </summary>
        /// <param name="index" type="String/Number">
        /// the index of menuitem to be removed
        /// </param>
        function (index) {
            wijmenu._remove(this, index);
        };
        wijmenu.prototype._newId = function () {
            var charArray = [
                'a', 
                'b', 
                'c', 
                'd', 
                'e', 
                'f', 
                'g', 
                'h', 
                'i', 
                'j', 
                'k', 
                'l', 
                'm', 
                'n', 
                'o', 
                'p', 
                'q', 
                'r', 
                's', 
                't', 
                'u', 
                'v', 
                'w', 
                'x', 
                'y', 
                'z'
            ], id = "", i;
            for(i = 0; i < 16; i++) {
                id += charArray[Math.round(Math.random() * 25)];
            }
            return id;
        };
        wijmenu.animations = {
            slide: function (options, addtions) {
                options = $.extend({
                    duration: 400,
                    easing: "swing"
                }, options, addtions);
                if(options.show) {
                    options.context.stop(true, true).animate({
                        height: 'show'
                    }, options, function () {
                        options.context.attr("aria-hidden", false);
                    });
                } else {
                    options.context.stop(true, true).animate({
                        height: 'hide'
                    }, options, function () {
                        options.context.attr("aria-hidden", true);
                    });
                }
            }
        };
        wijmenu._animateFlyoutMenu = function _animateFlyoutMenu(showAnimation, animationOptions, callback) {
            var sublist = animationOptions.context;
            if($.fn.wijshow) {
                sublist.data("isAnimated", true);
                sublist.wijshow(showAnimation, wijmenu.animations, animationOptions, null, function () {
                    sublist.data("isAnimated", false);
                    var browser = $.browser;
                    if(browser.msie && browser.version === "9.0") {
                        sublist.wrap("<div></div>");
                        sublist.unwrap();
                    } else if(browser.msie && browser.version === "6.0") {
                        sublist.css("overflow", "");
                    }
                    sublist.attr("aria-hidden", false);
                    if(callback) {
                        callback();
                    }
                });
            } else {
                sublist.show().attr("aria-hidden", false);
            }
        };
        wijmenu._getMenuItemOptions = function _getMenuItemOptions(options, index) {
            if(!options) {
                return {
                };
            }
            if(!options.items || !$.isArray(options.items)) {
                return {
                };
            }
            if(index >= options.items.length) {
                return {
                };
            }
            return options.items[index];
        };
        wijmenu._getOuterElement = function _getOuterElement(selector, isInnerSelector) {
            return $(selector).filter(function () {
                return $(this).closest(isInnerSelector).length === 0;
            });
        };
        wijmenu._hasVisibleSubMenus = function _hasVisibleSubMenus(widgetElement) {
            var widget, items, i;
            if(widgetElement.jquery) {
                if(widgetElement.data("wijmomenu")) {
                    widget = widgetElement.data(widgetElement.data("wijmomenu"));
                } else if(widgetElement.data("wijmomenuitem")) {
                    widget = widgetElement.data(widgetElement.data("wijmomenuitem"));
                }
            } else {
                widget = widgetElement;
            }
            if(!widget) {
                throw "the arugment 'menuItem' must be an wijmenu or wijmenuitem";
            }
            items = widget.getItems();
            if(!items.length) {
                return false;
            }
            for(i = 0; i < items.length; i++) {
                //if any of item was set displayVisible as true, just return true;
                if(items[i].options.displayVisible) {
                    return true;
                }
            }
            return false;
        };
        wijmenu._getFirstSelectableSubItem = function _getFirstSelectableSubItem(widget) {
            var i, items = widget.getItems(), o;
            for(i = 0; i < items.length; i++) {
                o = items[i].options;
                if(o.displayVisible !== false && !o.header && !o.separator) {
                    return items[i];
                }
            }
            return null;
        };
        wijmenu._getLastSelectableSubItem = function _getLastSelectableSubItem(widget) {
            var i, items = widget.getItems(), o;
            for(i = items.length - 1; i >= 0; i--) {
                o = items[i].options;
                if(o.displayVisible !== false && !o.header && !o.separator) {
                    return items[i];
                }
            }
            return null;
        };
        wijmenu._getSelectableSubItems = function _getSelectableSubItems(widget, filter) {
            return $.grep(widget.getItems(), function (n, i) {
                var o = n.options;
                if(o.header || o.separator || o.displayVisible === false) {
                    return false;
                }
                return filter(n, i);
            }, false);
        };
        wijmenu._add = function _add(self, menuItem, position) {
            /// <summary>
            /// Adds a child menuItem to the menuItem.
            /// </summary>
            /// <param name="menuItem" type="String,Object">
            /// which menuItem to be added
            /// 1.markup html.such as "<a>menuItem</a>" as a menuItem.
            /// 2.object options according to the options of wijmenuItem.
            /// </param>
            /// <param name="position" type="Int">
            /// the position to insert at
            /// </param>
                        //self = this,
            var menuItemWidget = null, //self = this,
            $menuItem = $("<li></li>"), //self = this,
            $ul = self._getSublist(), //self = this,
            items = self.getItems(), //self = this,
            elementToInserBefore, //self = this,
            o, //self = this,
            hasCreatedUl = //self._items,
            false;
            if(typeof menuItem === "string") {
                //if is h1-h5 or an link
                if(/<(h[1-5]|a)[\s\S]*>[\s\S]*<\/\1>/.test(menuItem)) {
                    $menuItem.append(menuItem);
                }
            } else if($.isPlainObject(menuItem)) {
                o = jQuery.extend(true, {
                }, menuItem);
            }
            //if the li has no children before, add an new ul
            if(!$ul || $ul.length <= 0) {
                $ul = $("<ul></ul>");
                self.element.append($ul);
                hasCreatedUl = true;
            }
            //if position is 0, '', undefined, null
            //OR not an number,
            //OR was specifed an out of range value
            if(!position || isNaN(position) || position > items.length) {
                if(position !== 0) {
                    position = items.length;
                }
            }
            //if the posiotn has been specified, insert it to the appropriate position
            if(items.length > 0 && items.length !== position) {
                elementToInserBefore = items[position].element;
                $menuItem.insertBefore(elementToInserBefore);
            } else {
                $ul.append($menuItem);
            }
            menuItemWidget = self._createItemWidget($menuItem, o);
            if(menuItemWidget === null || menuItemWidget === undefined) {
                return;
            }
            wijmenu._changeCollection(position, self.getItems(), self.options.items, menuItemWidget);
            if(self._bindModeEvents) {
                self._bindModeEvents(menuItemWidget, hasCreatedUl);
            } else {
                menuItemWidget._bindModeEvents(menuItemWidget, hasCreatedUl);
            }
            if(hasCreatedUl) {
                self._initUlCssClass();
            }
        };
        wijmenu._changeCollection = function _changeCollection(idx, menuItems, items, menuItemWidget) {
            //var indexOfItem;
            if(!menuItemWidget) {
                menuItems.splice(idx, 1);
                items.splice(idx, 1);
                return;
            }
            //if the menuItemWidget has been in the array, remove it at first
            //			indexOfItem = $.inArray(menuItemWidget, menuItems);
            //			if (indexOfItem !== -1) {
            //				menuItems.splice(indexOfItem, 1);
            //			}
            menuItems.splice(idx, 0, menuItemWidget);
            items.splice(idx, 0, menuItemWidget.options);
        };
        wijmenu._remove = function _remove(self, index) {
            var menuItem = self.getItems()[index];
            if(menuItem && menuItem.element) {
                menuItem.element.remove();
            }
        };
        wijmenu._getItemWidget = function _getItemWidget(li) {
            //return li.data($.wijmo.wijmenu._itemWidgetName);
            return li.data(li.data("wijmomenuitem"));
        };
        return wijmenu;
    })(wijmo.wijmoWidget);
    wijmo.wijmenu = wijmenu;    
    //#region menu options
    wijmenu.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijmenu')",
        wijCSS: /// <summary>
        /// wijmenu css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijmenu: "wijmo-wijmenu",
            wijmenuHorizontal: "wijmo-wijmenu-horizontal",
            wijmenuCurrent: "wijmo-wijmenu-current",
            wijmenuCurrentCrumb: "wijmo-wijmenu-current-crumb",
            wijmenuBreadcrumb: "wijmo-wijmenu-breadcrumb",
            wijmenuBreadcrumbText: "wijmo-wijmenu-breadcrumb-text",
            wijmenuItem: "wijmo-wijmenu-item",
            wijmenuLink: "wijmo-wijmenu-link",
            wijmenuList: "wijmo-wijmenu-list",
            wijmenuScroll: "wijmo-wijmenu-scroll",
            wijmenuContent: "wijmo-wijmenu-content",
            wijmenuFooter: "wijmo-wijmenu-footer",
            wijmenuHeader: "wijmo-wijmenu-header",
            wijmenuContainer: "wijmo-wijmenu-container",
            wijmenuIpod: "wijmo-wijmenu-ipod",
            wijmenuCrumb: "wijmo-wijmenu-crumb",
            wijmenuAllLists: "wijmo-wijmenu-all-lists",
            wijmenuPrevList: "wijmo-wijmenu-prev-list",
            wijmenuRtl: "wijmo-wijmenu-rtl",
            wijmenuBacklinktext: "wijmo-wijmenu-backlinktext"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-c",
            content: "ui-body ui-body-c",
            stateDefault: "ui-btn-up-c",
            stateHover: "ui-btn-down-c",
            stateActive: "ui-btn-down-c"
        },
        trigger: /// <summary>
        /// A jQuery selector which handles to open the menu or submenu.
        /// Default: "".
        /// Type: String.
        /// Remark:  If the trigger is set to a menu item(the <li> element),
        /// then the submenu appears when the item is clicked if the triggerEvent
        /// is set to click. If the trigger is set to an element outside of the menu,
        /// then the menu opens when the element is clicked if the triggerEvent is
        /// set to click as a contextmenu.
        /// Code example: $(".selector").wijmenu("option", "trigger", "#selector")
        /// </summary>
        '',
        triggerEvent: /// <summary>
        /// An option specifies the mouse event used to show the menu or submenu.
        /// Default: "click".
        /// Type: String.
        /// Remark: The value can be seted to 'click', 'mouseenter', 'dbclick',
        /// 'rtclick'
        /// Code example: $(".selector").wijmenu("option", "triggerEvent", "click")
        /// </summary>
        'click',
        position: /// <summary>
        /// Specifies the location and Orientation of the menu relative to the button
        /// or link used to open it. Configuration for the Position Utility,Of option
        /// is excluded, it is always configured by the widget.
        /// Collision also controls collision detection automatically too.
        /// It uses jQuery position plugin, see the following link for more details,
        /// http://jqueryui.com/demos/position/
        /// Default: {}.
        /// Type: Object.
        /// Code example: $(".selector").wijmenu("option", "position",
        ///		{my: "top right", at: "bottom left"});
        /// </summary>
        {
        },
        animation: /// <summary>
        /// The animation option sets the menu animation if the showAnimation
        /// and hideAnimation properties are not individually specified.
        /// Default: { animated: "slide", option: null,
        ///		duration: 400, easing: null }.
        /// Type: Object.
        /// Remark: This option uses the standard animation setting syntax
        /// from jQuery.UI.
        /// Code example: $(".selector").wijmenu("option", "animation", {
        ///		animated: "slide",
        ///		option: { direction: "right" },
        ///		duration: 400,
        ///		easing: null})
        /// </summary>
        {
            animated: "slide",
            duration: 400,
            easing: null
        },
        showAnimation: /// <summary>
        /// Determine the animation used to show submenus.
        /// Default: {}.
        /// Type: Object.
        /// Code example: $(".selector").wijmenu("option", "showAnimation", {
        ///		animated: "slide",
        ///		option: { direction: "right" },
        ///		duration: 400,
        ///		easing: null})
        /// </summary>
        {
        },
        hideAnimation: /// <summary>
        /// Determine the animation used to hide submenus.
        /// Default: { animated: "fade", duration: 400, easing: null }.
        /// Type: Object.
        /// Code example: $(".selector").wijmenu("option", "hideAnimation", {
        ///		animated: "slide",
        ///		option: { direction: "right" },
        ///		duration: 400,
        ///		easing: null})
        /// </summary>
        {
            animated: "fade",
            duration: 400,
            easing: null
        },
        showDelay: /// <summary>
        /// This option determines how many milliseconds to delay
        /// before showing the submenu in a fly-out menu.
        /// Default: 400
        /// Type: Number
        /// Code example: $(".selector").wijmenu("option", "showDelay", 1000);
        /// </summary>
        400,
        hideDelay: /// <summary>
        /// This option determines how many milliseconds to delay
        /// before hiding the submenu in a fly-out menu.
        /// Default: 400
        /// Type: Number
        /// Code exapmle: $(".selector").wijmenu("option", "hideDelay", 1000).
        /// </summary>
        400,
        slidingAnimation: /// <summary>
        /// Determine the animation used to slide submenu in sliding mode.
        /// Default: { duration: 400, easing: null }.
        /// Type: Object.
        /// Code example: $(".selector").wijmenu("option", "slidingAnimation", {
        ///		duration: 1000
        ///	})
        /// </summary>
        {
            duration: 400,
            easing: null
        },
        mode: /// <summary>
        /// The mode option defines the behavior of the menu,
        /// whether it is a pop-up menu or an iPod style navigation list.
        /// Default:"flyout".
        /// Type:String.
        /// Remarks: Possible values are "flyout" or "sliding".
        /// Code example: $(".selector").wijmenu("option", "mode", "sliding")
        /// </summary>
        'flyout',
        superPanelOptions: /// <summary>
        /// This option specifies a hash value that sets to superpanel options
        /// when a superpanel is created.  It is used to set appearances and behaviors
        /// when scrollbar is shown in sliding mode.
        /// Default: null.
        /// Type: Object.
        /// Code example: $(".selector").wijmenu("option", "superPanelOptions", {})
        /// </summary>
        null,
        checkable: /// <summary>
        /// Defines whether the item can be checked.
        /// Default: false.
        /// Type: Boolean.
        /// Code example: $(".selector").wijmenu("option","chackable", true).
        /// </summary>
        false,
        orientation: /// <summary>
        /// Controls the root menu's orientation. All submenus are vertical
        /// regardless of the orientation of the root menu.
        /// Default: "horizontal".
        /// Type: String.
        /// Remark: The value should be "horizontal" or "vertical".
        /// Code example: $(".selector").wijmenu("option", "orientation", "vertical")
        /// </summary>
        'horizontal',
        direction: /// <summary>
        /// A value that indicates menu's direction.
        /// Default: "ltr".
        /// Type: String.
        /// Remark: The value should be "ltr" or "rtl".
        /// Code example: $(".selector").wijmenu("option", "direction", "rtl")
        /// </summary>
        'ltr',
        maxHeight: /// <summary>
        /// This option can only be used in an iPod style menu.
        /// When the menu contains more items than can be displayed
        /// within the allowed height, the menu will show a scrollbar.
        /// Default: 200.
        /// Type: Number.
        /// Remark: This option can only be used in an iPod style menu.
        /// When the menu's heiget is largger than this value,
        /// the menu shows a scroll bar.
        /// Code example: $(".selector").wijmenu("option", "maxHeight", 300)
        /// </summary>
        200,
        backLink: /// <summary>
        /// Determines whether the iPod menu shows a back link or a breadcrumb header
        /// in the menu.
        /// Default: true.
        /// Type: Boolean.
        /// Code example: $(".selector").wijmenu("option", "backLink", false)
        /// </summary>
        true,
        backLinkText: /// <summary>
        /// Sets the text of the back link.
        /// Default: "Back".
        /// Type: String.
        /// Code example: $(".selector").wijmenu("option", "backLinkText", "Previous")
        /// </summary>
        'Back',
        topLinkText: /// <summary>
        /// Sets the text of the top link.
        /// Default: "All".
        /// Type: String.
        /// Code example: $(".selector").wijmenu("option", "topLinkText", "Root")
        /// </summary>
        'All',
        crumbDefaultText: /// <summary>
        /// Sets the top breadcrumb's default text.
        /// Default: "Choose an option".
        /// Type: String.
        /// Code example: $(".selector").wijmenu("option", "crumbDefaultText",
        /// "Choose")
        /// </summary>
        'Choose an option',
        select: /// <summary>
        /// The select event is triggered when a menu item is selected.
        /// Default: null
        /// Type: Function
        /// code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("select", function(e, data){})
        /// Bind to the event by type: wijmenuselect
        /// $(".selector").bind("wijmenuselect", function(e, data) { } );
        /// </summary>
        /// <param name="e" type="EventObj">jQuery.Event object.</param>
        /// <param name="data" type="Object">data.item is the avtive
        /// item of the menu.</param>
        null,
        focus: /// <summary>
        /// The focus event is triggered either on mouse hover or
        /// when the keyboard cursor keys are used for navigation.
        /// Default: null.
        /// Type: Function
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("focus", function(e, data) {})
        /// Bind to the event by type: wijmenufocus
        /// $(".selector").bind("wijmenufocus", function(e, data) { } );
        /// </summary>
        /// <param name="e" type="Object">jQuery.Event object</param>
        /// <param name="data" type="Object">data.item is the item
        /// which is focused.</param>
        null,
        blur: /// <summary>
        /// Triggered when a menu item loses focus.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("blur", function(e, data){})
        /// Bind to the event by type: wijmenublur
        /// $(".selector").bind("wijmenublur", function(e, data) { } );
        /// </summary>
        /// <param name="e" type="Object">jQuery.Event object.</param>
        null,
        showing: /// <summary>
        /// The showing event is triggered before the submenu is shown.
        /// This event can be cancelled with "return false";
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("showing", function(e, item){})
        /// Bind to the event by type:
        /// $("#selector").bind("wijmenushowing", function(e, item){})
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.</param>
        /// <param name="item" type="Object">
        /// The wijmenu widget object when displaying menu,
        /// or an wijmenuitem widget when dispalying submenu.</param>
        /// <returns type="Boolean">
        /// Return false to cancel the showing event.
        /// </returns>
        null,
        shown: /// <summary>
        /// The shown event is triggered after the menu or submenu is shown.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("shown", function(e, item){})
        /// Bind to the event by type:
        /// $("#selector").bind("wijmenushown", function(e, item){})
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.</param>
        /// <param name="item" type="Object">
        /// The wijmenu widget object when have displayed menu,
        /// or an wijmenuitem widget when  have displayed submenu.</param>
        null,
        hidding: /// <summary>
        /// The hidding event is triggered before hidding the menu or submenu.
        /// This event can be cancelled with "return false";
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("hidding", function(e, item){})
        /// Bind to the event by type:
        /// $("#selector").bind("wijmenuhidding", function(e, item){})
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="item" type="Object">
        /// The wijmenu widget object when hidding menu,
        /// or an wijmenuitem widget when hidding submenu.
        /// </param>
        /// <returns type="Boolean">
        /// Return false to cancel the hidding event.
        /// </returns>
        null,
        hidden: /// <summary>
        /// The hidden event is triggered after the menu or submenu is hidden.
        /// Default: null.
        /// Type: Function.
        /// Code example:
        /// Supply a function as an option.
        /// $("#selector").wijmenu("hidden", function(e, item){})
        /// Bind to the event by type:
        /// $("#selector").bind("wijmenuhidden", function(e, item){})
        /// </summary>
        /// <param name="e" type="Object">
        /// jQuery.Event object.
        /// </param>
        /// <param name="item" type="Object">
        /// The wijmenu widget object when have hidden menu,
        /// or an wijmenuitem  when widget have hidden submenu.
        /// </param>
        null,
        items: /// <summary>
        /// The options of child items
        /// Default: null.
        /// Type: Array.
        /// </summary>
        null
    });
    //#endregion
    (function (MarkupType) {
        MarkupType._map = [];
        MarkupType.link = 0;
        MarkupType.separator = 1;
        MarkupType.header = 2;
        MarkupType.other = 3;
    })(wijmo.MarkupType || (wijmo.MarkupType = {}));
    var MarkupType = wijmo.MarkupType;
    var wijmenuitem = (function (_super) {
        __extends(wijmenuitem, _super);
        function wijmenuitem() {
            _super.apply(this, arguments);

        }
        wijmenuitem.prototype._initState = function () {
            this._items = [];
            this._resetMarkupValue();
            if(!this.options.items) {
                this.options.items = [];
            }
        };
        wijmenuitem.prototype._create = function () {
            var self = this;
            if(self._isMobile) {
                $.extend(true, self.options.wijCSS, self.options.wijMobileCSS);
            }
            //update for jQuery UI 1.10
            self.element.data("wijmomenuitem", $.camelCase(self.widgetFullName));
            //self.element.data("wijmomenuitem", self.widgetName);
            self._initState();
            self._getOrSetOptionsValues();
            self._createChildMenuItems();
            self._initCssClass();
            //invoke base create.
            _super.prototype._create.call(this);
        };
        wijmenuitem.prototype._refresh = function () {
            var self = this, o = self.options;
            self._set_navigateUrl(o.navigateUrl);
            self._set_target(o.target);
            self._set_displayVisible(o.displayVisible);
            self._createChildMenuItems();
            self._initCssClass();
            //self._bindEvents();
                    };
        wijmenuitem.prototype._setOption = function (key, value) {
            var self = this, o = self.options, parent;
            if(key === "items") {
                _super.prototype._setOption.call(this, key, value);
                self._set_items(value);
                return;
            }
            if(value === o[key]) {
                return;
            }
            _super.prototype._setOption.call(this, key, value);
            if(!$.isFunction(self["_set_" + key])) {
                return;
            }
            self["_set_" + key](value, true);
            switch(key) {
                case "header":
                case "separator":
                    self._refresh();
                    break;
                case "displayVisible":
                    parent = self.getParent();
                    if(parent) {
                        parent._setSubmenuIcon();
                    }
                    break;
                default:
                    break;
            }
        };
        wijmenuitem.prototype.index = function () {
            /// <summary>
            /// return index of the item.
            /// </summary>
            return this.element.index();
        };
        wijmenuitem.prototype._set_selected = function (value) {
            var self = this, o = self.options, itemType = self._getMenuItemType();
            if(itemType === MarkupType.link) {
                self._getLink().toggleClass(o.wijCSS.stateActive, value);
            } else {
                //if not an link item set selected as false;
                self.options.selected = false;
            }
        };
        wijmenuitem.prototype._set_items = function (value) {
            var self = this;
            self._getSublist().remove();
            self._items = [];
            if(value.length > 0) {
                self._createChildMenuItems();
                self._initUlCssClass();
                //self._initCssClass();
                            }
            self._setSubmenuIcon(value.length > 0);
            self._bindModeEvents(self, true);
            self._resetMarkupValue();
        };
        wijmenuitem.prototype._bindModeEvents = function (widget, createdUl) {
            var self = this, menu = widget._getMenu(), o = menu.options;
            if(createdUl) {
                self._initUlCssClass();
                self._setSubmenuIcon();
                self._resetMarkupValue();
            }
            if(o.mode === "flyout") {
                //if created an ul means the event of the li
                //has been modified from an leaf to an node
                //so there must be kill flyout at first
                if(createdUl) {
                    self._killFlyout();
                    self._flyout();
                } else {
                    widget._flyout();
                }
            } else {
                self._setDrilldownUlStyle();
                //reset scroll only if is add to an visible ul
                if(widget.element.parent().is(':visible')) {
                    menu._resetScroll(widget._getParentOrMenu());
                }
            }
        };
        wijmenuitem.prototype._set_value = function (value, writeOnly) {
            this.options.value = value;
        };
        wijmenuitem.prototype._set_text = function (value, writeOnly) {
            var self = this, o = self.options;
            if(value || writeOnly) {
                self._setText(value);
            } else {
                o.text = self._getText();
            }
        };
        wijmenuitem.prototype._set_navigateUrl = function (value, writeOnly) {
            var self = this, o = self.options, link = self._getLink();
            if(link.is('a')) {
                if(value || writeOnly) {
                    link.attr('href', value);
                } else {
                    o.navigateUrl = link.attr('href');
                }
            }
        };
        wijmenuitem.prototype._set_target = function (value, writeOnly) {
            var self = this, o = self.options, link = self._getLink();
            if(link.is('a')) {
                if(o.target || writeOnly) {
                    link.attr('target', value);
                } else {
                    o.target = link.attr('target') || '';
                }
            }
        };
        wijmenuitem.prototype._set_iconClass = function (value, writeOnly) {
            var self = this, o = self.options, link, iconSpan, textSpan, text;
            //is header or separator, do nothing
            if(o.header === true || o.separator === true) {
                return;
            }
            link = self._getLink();
            iconSpan = link.find('span.' + o.wijCSS.wijmenuitemIcon);
            if(value) {
                //does not have the span, create it
                if(iconSpan.length === 0) {
                    iconSpan = $("<span>");
                    textSpan = link.children("." + o.wijCSS.wijmenuText).wrap("<span>").parent();
                    textSpan.addClass(o.wijCSS.wijmenuText);
                    textSpan.prepend(iconSpan);
                }
                //have specified value, set cssClass as user specified value
                iconSpan.addClass(value).addClass(o.wijCSS.wijmenuIconLeft).addClass(o.wijCSS.wijmenuitemIcon);
                if(writeOnly) {
                    self._set_imagePosition(o.imagePosition);
                }
            } else {
                //else value is not specified
                if(iconSpan.length !== 0) {
                    iconSpan.remove();
                    textSpan = link.children("." + o.wijCSS.wijmenuText);
                    text = textSpan.text();
                    textSpan.html('');
                    textSpan.text(text);
                }
            }
            //add class to link to fix tfs issue 24238
            if(self._getMenuItemType() === MarkupType.other) {
                //if (link && link.is("div")) {
                link.addClass(o.wijCSS.wijmenuLink).addClass(o.wijCSS.cornerAll);
            }
        };
        wijmenuitem.prototype._set_imagePosition = function (value, writeOnly) {
            var self = this, o = self.options, link = self._getLink(), iconSpan = link.find('>span>span.' + o.wijCSS.wijmenuitemIcon), positionCss = value === 'right' ? o.wijCSS.wijmenuIconRight : o.wijCSS.wijmenuIconLeft;
            if(iconSpan.length === 0) {
                return;
            }
            iconSpan.removeClass(o.wijCSS.wijmenuIconRight).removeClass(o.wijCSS.wijmenuIconLeft).addClass(positionCss);
        };
        wijmenuitem.prototype._set_separator = function (value, writeOnly) {
            var self = this, ele = self.element, o = self.options, link = self._getLink();
            if(writeOnly && value === false) {
                ele.html("").removeClass(o.wijCSS.wijmenuSeparator).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerAll);
                self._createMenuItemMarkup(MarkupType.link).appendTo(ele);
            } else if(value === true || link.length === 0) {
                o.separator = true;
                o.header = false;
                //if is separator, modify html markup
                self._createMenuItemMarkup(MarkupType.separator);
            } else {
                o.separator = false;
            }
            self._resetMarkupValue();
        };
        wijmenuitem.prototype._set_header = function (value, writeOnly) {
            var self = this, ele = self.element, o = self.options, link = self._getLink();
            if(writeOnly && value === false) {
                o.header = false;
                ele.html("").removeClass(o.wijCSS.header).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault);
                self._createMenuItemMarkup(MarkupType.link).appendTo(ele);
            } else if(value === true || link.is("h1,h2,h3,h4,h5")) {
                o.header = true;
                o.separator = false;
                //if is header, modify the html markup
                if(!link.is("h1,h2,h3,h4,h5")) {
                    //clear html element and add an h3 as header
                    link.remove();
                    link = self._createMenuItemMarkup(MarkupType.header);
                    ele.append(link);
                }
            } else {
                o.header = false;
            }
            self._resetMarkupValue();
        };
        wijmenuitem.prototype._set_displayVisible = function (value) {
            var self = this, ele = self.element;
            if(value) {
                ele.show();
            } else {
                ele.hide();
            }
        };
        wijmenuitem.prototype._createMenuItemMarkup = function (markupType) {
            var self = this, o = self.options, ele = self.element, result;
            if(markupType === MarkupType.separator) {
                //just clear html markup
                //ele.html('');
                ele.html('<span class="' + o.wijCSS.wijmenuSeparatorContent + '">&nbsp;</span>');
                return null;
            } else if(markupType === MarkupType.header) {
                result = $("<h3></h3>").text(o.text);
            } else {
                result = $('<a>').text(o.text);
            }
            return result;
        };
        wijmenuitem.prototype._getMenuItemType = function (newOptions) {
            var self = this, o = self.options, link = self._getLink();
            if(newOptions) {
                o = $.extend({
                }, o, newOptions);
            }
            if(o.separator === true) {
                return MarkupType.separator;
            }
            if(o.header === true) {
                return MarkupType.header;
            }
            //when neither specified options.separator nor options.header as true
            //if markup is  <li></li>
            if(link.length === 0) {
                if(o.text) {
                    //if text have specified
                    return MarkupType.link;
                }
                //else is separator
                return MarkupType.separator;
            }
            if(link.is('a')) {
                return MarkupType.link;
            }
            if(link.is('h1,h2,h3,h4,h5')) {
                return MarkupType.header;
            }
            return MarkupType.other;
        };
        wijmenuitem.prototype._getOrSetOptionsValues = function () {
            var self = this, ele = self.element, o = self.options, link = self._getLink(), type = self._getMenuItemType();
            if(type === MarkupType.header) {
                self._set_header(o.header);
                self._set_text(o.text);
            } else if(type === MarkupType.separator) {
                self._set_separator(o.separator);
            } else {
                //if the markup is just an <li></li> create markup at first
                if(link.length === 0) {
                    link = self._createMenuItemMarkup(type);
                    ele.append(link);
                } else {
                    self._set_text(o.text);
                }
                self._resetMarkupValue();
                self._set_navigateUrl(o.navigateUrl);
                self._set_target(o.target);
            }
            self._set_displayVisible(o.displayVisible);
            self._set_selected(o.selected);
        };
        wijmenuitem.prototype._getText = function () {
            //get the text of the item
            return this._getLink().text();
        };
        wijmenuitem.prototype._setText = function (text) {
            var ele = this.element, o = this.options, link;
            //have 4 kind of situations
            //1 first time li created as widget, the markup like <li><a>text</a></li>
            //2 the li has been created as widget, html markup like
            //	<li role="menuitem" class="ui-widget wijmo-wijmenu-item">
            //		<a class="wijmo-wijmenu-link ui-corner-all" aria-haspopup="">
            //			<span class="wijmo-wijmenu-text">menu item2</span></a></li>
            //3 is an header mark up like <li><h3>text</h3></li>
            //4 is an separator this situation don't need to set text
            //find first-child a to fix tfs issue 24238
            link = ele.find(":not(ul)a ." + o.wijCSS.wijmenuText + ":first");
            //link = ele.find(".wijmo-wijmenu-text");
            //end comments.
            if(link.length !== 0) {
                link.text(text);
                return;
            }
            link = ele.children('h1,h2,h3,h4,h5').filter(':first');
            if(link.length !== 0) {
                link.text(text);
                return;
            }
            link = ele.children('a:first');
            if(link.length !== 0) {
                link.text(text);
                return;
            }
        };
        wijmenuitem.prototype._createChildMenuItems = function () {
            var self = this, ele = self.element, items = self._items, o = self.options, optionItemsLength, ul, childMenuCount, i, w;
            if(o.header === true || o.separator === true) {
                return;
            }
            optionItemsLength = o.items.length;
            ul = self._getSublist();
            childMenuCount = ul.children('li').length;
            // if the count of items more than li contained in html markup
            if(optionItemsLength > childMenuCount) {
                if(ul.length === 0) {
                    ul = $('<ul>').appendTo(ele);
                    self._resetMarkupValue();
                }
                for(i = 0; i < optionItemsLength - childMenuCount; i++) {
                    ul.append('<li>');
                }
            }
            $.each(self._getChildren(), function (idx, child) {
                var $li = $(child), options;
                options = wijmenu._getMenuItemOptions(self.options, idx);
                w = self._createItemWidget($li, options);
                items.push(w);
                self.options.items[idx] = w.options;
            });
        };
        wijmenuitem.prototype._createItemWidget = function ($li, options) {
            var self = this, itemWidgetName = self.widgetName;
            //itemWidgetName = $.wijmo.wijmenu._itemWidgetName;
            $li[itemWidgetName](options);
            //Fix for jQuery UI 1.10
            return $li.data($.camelCase(self.widgetFullName));
            //return $li.data(self.widgetName);
                    };
        wijmenuitem.prototype._initCssClass = function () {
            var self = this, li = this.element, o = self.options, link = self._getLink(), type = self._getMenuItemType();
            if(type !== MarkupType.separator) {
                li.attr("role", "menuitem");
            }
            if(type === MarkupType.separator) {
                li.addClass(o.wijCSS.wijmenuSeparator).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
            } else if(type === MarkupType.header) {
                li.addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll);
            } else {
                if(type === MarkupType.link) {
                    if(!li.hasClass(o.wijCSS.wijmenuItem)) {
                        li.addClass(o.wijCSS.widget).addClass(o.wijCSS.wijmenuItem).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                        link.addClass(o.wijCSS.wijmenuLink).addClass(o.wijCSS.cornerAll);
                        link.wrapInner("<span>").children("span").addClass(o.wijCSS.wijmenuText);
                    }
                } else {
                    li.addClass(o.wijCSS.widget).addClass(o.wijCSS.wijmenuItem).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                }
                self._setSubmenuIcon();
            }
            self._set_iconClass(o.iconClass);
            self._set_imagePosition(o.imagePosition);
            self._initUlCssClass();
        };
        wijmenuitem.prototype._initUlCssClass = function () {
            var o = this.options;
            this._getSublist().addClass(o.wijCSS.wijmenuList).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.wijmenuChild).addClass(o.wijCSS.helperReset).hide();
        };
        wijmenuitem.prototype._setSubmenuIcon = function (hasSubmenu) {
            var self = this, o = this.options, link = self._getLink(), menu = self._getMenu(), direction = menu.options.direction, submenuIcon = direction === "rtl" ? link.children("span." + o.wijCSS.icon + ":first") : link.children("span." + o.wijCSS.icon + ":last");
            //if the arugment 'hasSubmenu' was not specified
            if(hasSubmenu === undefined) {
                hasSubmenu = wijmenu._hasVisibleSubMenus(self);
            }
            if(hasSubmenu && !link.is(":input")) {
                if(submenuIcon.length === 0) {
                    if(direction === "rtl") {
                        submenuIcon = $("<span>").prependTo(link);
                    } else {
                        submenuIcon = $("<span>").appendTo(link);
                    }
                }
                if(self._isRoot() && menu.options.orientation === "horizontal" && menu.options.mode === 'flyout') {
                    submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowDown);
                } else {
                    if(direction === "rtl") {
                        submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowLeft);
                    } else {
                        submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowRight);
                    }
                }
            } else {
                submenuIcon.remove();
            }
        };
        wijmenuitem.prototype._killFlyout = function () {
            var ele = this.element.attr("role", ""), o = this.options;
            ele.removeClass(o.wijCSS.wijmenuParent).unbind(".wijmenuEvent").unbind(".wijmenuitem").children(":first").unbind(".wijmenuEvent").unbind(".wijmenuitem").attr("aria-haspopup", "");
            //add by chandler for unbinding ul mouseleave event
            this._getSublist().unbind(".wijmenuEvent").unbind(".wijmenuitem");
            $.each(this.getItems(), function () {
                this._killFlyout();
            });
        };
        wijmenuitem.prototype._getItemTriggerEvent = function () {
            var self = this, ele = self.element, menu = self._getMenu(), o = menu.options, triggerEvent = "default";
            if(o.trigger !== "") {
                if(ele.is(o.trigger) || menu.element.is(o.trigger)) {
                    triggerEvent = o.triggerEvent;
                } else {
                    ele.parents("." + o.wijCSS.wijmenuParent).each(function (i, n) {
                        if($(n).is(o.trigger)) {
                            triggerEvent = o.triggerEvent;
                            return false;
                        }
                    });
                    if(triggerEvent === "default" && self._isOuterTirggerEle()) {
                        triggerEvent = o.triggerEvent;
                    }
                }
            }
            ele.data("triggerEvent", triggerEvent);
            return triggerEvent;
        };
        wijmenuitem.prototype._isOuterTirggerEle = function () {
            var menu = this._getMenu();
            return wijmenu._getOuterElement(menu.options.trigger, "." + menu.options.wijCSS.wijmenu).length > 0;
        };
        wijmenuitem.prototype._flyout = function () {
            var self = this, menu = self._getMenu(), o = menu.options, nameSpace = ".wijmenuitem", li = $(self.element).attr("aria-haspopup", true), showTimer, hideTimer, triggerEvent = self._getItemTriggerEvent(), link = li.children('a.' + o.wijCSS.wijmenuLink), subList = self._getSublist(), itemDisabled;
            if(self.getItems().length > 0) {
                subList.bind("mouseleave" + nameSpace, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    hideTimer = setTimeout(function () {
                        self._hideCurrentSubmenu(e);
                    }, o.hideDelay);
                });
                li.addClass(self.options.wijCSS.wijmenuParent);
                if(triggerEvent !== "default" && o.triggerEvent !== "mouseenter") {
                    switch(o.triggerEvent) {
                        case "click":
                            link.bind("click" + nameSpace, function (e) {
                                if(o.disabled || $(this).hasClass(o.wijCSS.stateDisabled)) {
                                    return;
                                }
                                self._showFlyoutSubmenu(e);
                            });
                            break;
                        case "dblclick":
                            link.bind("dblclick" + nameSpace, function (e) {
                                if(o.disabled || $(this).hasClass(o.wijCSS.stateDisabled)) {
                                    return;
                                }
                                self._showFlyoutSubmenu(e);
                            });
                            break;
                        case "rtclick":
                            link.bind("contextmenu" + nameSpace, function (e) {
                                if(o.disabled || $(this).hasClass(o.wijCSS.stateDisabled)) {
                                    return;
                                }
                                self._showFlyoutSubmenu(e);
                                e.preventDefault();
                            });
                            break;
                    }
                    subList.data("notClose", true);
                } else {
                    link.bind("mouseenter.wijmenuEvent", function (e) {
                        if(o.disabled || $(this).hasClass(o.wijCSS.stateDisabled)) {
                            return;
                        }
                        clearTimeout(hideTimer);
                        showTimer = setTimeout(function () {
                            self._displaySubmenu(e, null);
                        }, o.showDelay);
                    }).bind("mouseleave" + nameSpace, function (e) {
                        if(o.disabled || $(this).hasClass(o.wijCSS.stateDisabled)) {
                            return;
                        }
                        clearTimeout(showTimer);
                        if(!subList.is("ul")) {
                            subList = subList.children("ul:first");
                        }
                        hideTimer = setTimeout(function () {
                            self._hideSubmenu(false, e);
                        }, o.hideDelay);
                    });
                    if(self.getItems().length > 0) {
                        self._getSublist().bind("mouseenter" + nameSpace, function (e) {
                            if(o.disabled) {
                                return;
                            }
                            clearTimeout(hideTimer);
                        });
                    }
                }
            }
            ///when click the menu item hide the submenus.
            link.bind("click.wijmenuEvent", function (e) {
                itemDisabled = link.hasClass(o.wijCSS.stateDisabled);
                if(o.disabled || itemDisabled) {
                    return;
                }
                if(link.is("a")) {
                    if(self._getSublist().length === 0) {
                        menu._hideAllMenus(e);
                    } else if(!(o.trigger !== "" && li.data("triggerEvent") !== "default" && o.triggerEvent !== "mouseenter")) {
                        menu._hideAllMenus(e);
                    } else {
                        var curList = menu._currentMenuList, item, j;
                        if(curList !== undefined) {
                            item = li;
                            if(self._getSublist().length === 0) {
                                for(j = curList.length; j > 0; j--) {
                                    if(curList[j - 1] === self) {
                                        break;
                                    } else {
                                        curList[j - 1]._hideSubmenu(false, e);
                                    }
                                }
                            }
                        }
                    }
                    menu.activate(e, self);
                }
                menu.select(e);
                if(link.attr("href") === "#") {
                    e.preventDefault();
                }
            }).bind("focusin.wijmenuEvent", function (e) {
                itemDisabled = link.hasClass(o.wijCSS.stateDisabled);
                if(o.disabled || itemDisabled) {
                    return;
                }
                if(link.is("a")) {
                    menu.activate(e, self);
                }
            });
            $.each(self.getItems(), function () {
                this._flyout();
            });
        };
        wijmenuitem.prototype._hideSubmenu = function (hideImmediately, e) {
            var self = this, menu = self._getMenu(), o = menu.options, animations = wijmenu.animations, animationOptions, hideAnimation, list, sublist = self._getSublist(), link = self._getLink();
            if(!link.data("subMenuOpened")) {
                return;
            }
            if(!menu._trigger("hidding", e, self)) {
                return;
            }
            if(link.is("." + o.wijCSS.wijmenuLink)) {
                link.data("subMenuOpened", false);
                link.removeClass(o.wijCSS.stateActive);
            }
            if($.fn.wijhide && hideImmediately !== true) {
                animationOptions = {
                    context: sublist,
                    show: false
                };
                hideAnimation = $.extend({
                }, o.animation, o.hideAnimation);
                sublist.wijhide(hideAnimation, animations, animationOptions, null, function () {
                    menu._setZindex(sublist, null);
                    sublist.attr("aria-hidden", true);
                    menu._trigger("hidden", e, self);
                });
            } else {
                sublist.hide().attr("aria-hidden", true);
                menu._setZindex(sublist, null);
                menu._trigger("hidden", e, self);
            }
            //menu.element.data("shown", false);
            list = menu._currentMenuList;
            if(list) {
                list = $.makeArray($.map(list, function (n) {
                    return n && (n === self) ? null : n;
                }));
                menu._currentMenuList = $.makeArray(list);
            }
        };
        wijmenuitem.prototype._displaySubmenu = function (e, callback) {
            var self = this, menu = self._getMenu(), o = menu.options, animationOptions, direction, showAnimation, haveNoVisibleChild, link = self._getLink(), sublist = self._getSublist();
            //modified for supporting displayVisible in li
            haveNoVisibleChild = !wijmenu._hasVisibleSubMenus(self);
            if(sublist.is(":visible") || haveNoVisibleChild) {
                return;
            }
            if(!menu._trigger("showing", e, self)) {
                return;
            }
            //menu._trigger("showing", e, self);
            if(link.is("a." + o.wijCSS.wijmenuLink)) {
                link.data("subMenuOpened", true);
            }
            sublist.show();
            this._setMenuItemPosition();
            menu.nowIndex++;
            menu._setZindex(sublist, menu.nowIndex);
            sublist.hide();
            animationOptions = {
                context: sublist,
                show: true
            };
            direction = o.direction === "rtl" ? "right" : "left";
            if(o.orientation === "horizontal") {
                if(self._isRoot()) {
                    direction = "up";
                }
            }
            showAnimation = $.extend({
            }, {
                option: {
                    direction: direction
                }
            }, o.animation, o.showAnimation);
            wijmenu._animateFlyoutMenu(showAnimation, animationOptions, function () {
                //fix for tfs issue 20975
                if(sublist.is(":hidden")) {
                    self._hideSubmenu(true, e);
                }
                //add the event 'shown'
                menu._trigger("shown", e, self);
                if(callback) {
                    callback();
                }
            });
            menu._isClickToOpen = o.triggerEvent === "click";
            if(menu._currentMenuList === undefined) {
                menu._currentMenuList = [];
            }
            menu._currentMenuList.push(self);
        };
        wijmenuitem.prototype._setMenuItemPosition = function () {
            var self = this, sublist = self._getSublist(), pOption = self._getMenuItemPosition(), obj = {
                of: this._getLink()
            };
            sublist.css({
                left: '0',
                top: '0',
                position: 'absolute'
            });
            sublist.position($.extend(obj, pOption));
        };
        wijmenuitem.prototype._getMenuItemPosition = function () {
            var self = this, menu = this._getMenu(), o = menu.options, direction = o.direction, pOption = direction === "rtl" ? {
                my: 'right top',
                at: 'left top'
            } : {
                my: 'left top',
                at: 'right top'
            };
            //If the menu's orientation is horizontal,
            //set the first level submenu's position to horizontal.
            if(o.orientation === "horizontal") {
                if(self._isRoot()) {
                    pOption = direction === "rtl" ? {
                        my: 'right top',
                        at: 'right bottom'
                    } : {
                        my: 'left top',
                        at: 'left bottom'
                    };
                }
            }
            pOption = $.extend(pOption, o.position);
            return pOption;
        };
        wijmenuitem.prototype._getChildren = function () {
            return this._getSublist().children('li');//.filter('li');
            
        };
        wijmenuitem.prototype._setDrilldownUlStyle = function () {
            var self = this, o = self.options, sublist = self._getSublist(), menu = self._getMenu(), width = menu.domObject.menucontainer.width();
            if(menu.options.direction === "rtl") {
                sublist.css({
                    width: width,
                    left: -width
                });
            } else {
                sublist.css({
                    width: width,
                    left: width
                });
            }
            sublist.addClass(o.wijCSS.content);
            $.each(self.getItems(), function (i, n) {
                if(n.getItems().length) {
                    this._setDrilldownUlStyle();
                }
            });
        };
        wijmenuitem.prototype._getMenu = function () {
            var self = this, result = self._menu, parent, tmp;
            //if result is empty, get menu object from parent until body
            if(!result) {
                parent = self.element.parent();
                while(!parent.is('body') && parent.length > 0) {
                    //tmp = parent.data($.wijmo.wijmenu._menuWidgetName);
                    tmp = parent.data("wijmomenu");
                    if(tmp) {
                        //result = tmp;
                        result = parent.data(tmp);
                        self._menu = result;
                        return result;
                    }
                    parent = parent.parent();
                }
                //if cannot find menu, throw an exception
                throw 'An menuitem must be a child of menu';
            }
            return result;
        };
        wijmenuitem.prototype.getParent = function () {
            /// <summary>
            /// Gets the parent of the current item,
            /// the method will return null when current item is a top item
            /// </summary>
                        var self = this, ele = self.element, menu, result, parent;
            result = self._parent;
            if(result !== undefined) {
                return result;
            }
            //find an parent li which contains cache 'wijmenuitem'
            parent = ele.parents('li:first');
            if(parent.length > 0) {
                result = wijmenu._getItemWidget(parent);
                if(result !== undefined) {
                    self._parent = result;
                    return result;
                }
            }
            menu = self._getMenu();
            //the element at the top level
            if(menu._getSublist().get(0) === ele.parent().get(0)) {
                self._parent = null;
                return null;
            }
            throw 'An menuitem must be a child of menu or another menuitem';
        };
        wijmenuitem.prototype._getParentOrMenu = function () {
            return this.getParent() || this._getMenu();
        };
        wijmenuitem.prototype._getField = function (key) {
            return this.element.data(key);
        };
        wijmenuitem.prototype._setField = function (key, value) {
            return this.element.data(key, value);
        };
        wijmenuitem.prototype._innerDestroy = function (invokedByParent) {
            var self = this, o = self.options, item = self.element, link, items = self.getItems(), i = items.length - 1;
            //remove all classses of li
            item.removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.wijmenuParent).removeClass(o.wijCSS.header).removeClass(o.wijCSS.wijmenuSeparator);
            link = item.children("." + o.wijCSS.wijmenuLink);
            link.removeClass(o.wijCSS.wijmenuLink).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.stateFocus).removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateActive).html(link.children("." + o.wijCSS.wijmenuText).html()).unbind(".wijmenuitem").unbind(".wijmenuEvent");
            item.children("ul").removeClass(o.wijCSS.wijmenuList).removeClass(o.wijCSS.content).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.helperClearFix).removeClass(o.wijCSS.wijmenuChild).removeClass(o.wijCSS.helperReset).attr("role", "").attr("aria-activedescendant", "").show().css({
                left: "",
                top: "",
                position: ""
            }).attr("hidden", "");
            //add by chandler
            item.removeAttr("role");
            link.removeAttr("aria-haspopup");
            //if is not invoked recursively from parent,
            //which means there must remove self from parent._items
            if(!invokedByParent) {
                self._removeFromParentCollection();
            }
            item.removeData('menu').removeData('parent');
            //destroy child menus recursively
            //$.each(self.getItems() || [], function (i, n) {
            //	n.destroy(true);
            //});
            for(; i >= 0; i--) {
                items[i].destroy(true);
            }
            self._items.length = 0;
            self._resetMarkupValue();
        };
        wijmenuitem.prototype.destroy = function (invokedByParent) {
            /// <summary>
            /// The destroy() method removes the wijmenu functionality completely
            /// and returns the element back to its pre-init state.
            /// </summary>
            var self = this;
            self._innerDestroy(invokedByParent);
            //end for disabled option
            _super.prototype.destroy.call(this);
        };
        wijmenuitem.prototype._getFirstSelectableSubItem = function () {
            return wijmenu._getFirstSelectableSubItem(this);
        };
        wijmenuitem.prototype._getLastSelectableSubItem = function () {
            return wijmenu._getLastSelectableSubItem(this);
        };
        wijmenuitem.prototype.next = function () {
            ///<summary>
            /// Gets the next selectable item. The first item will be selected
            /// if none is active or the last one is active.
            /// return null if none is selectable in next.
            ///</summary>
                        var self = this, items = self._getParentOrMenu().getItems(), i, o, indexOfItem = $.inArray(self, items);
            if(indexOfItem === -1) {
                throw 'cannot find item from the parent collection';
            }
            for(i = indexOfItem + 1; i < items.length; i++) {
                o = items[i].options;
                if(o.displayVisible !== false && !o.header && !o.separator) {
                    return items[i].element;
                }
            }
            return null;
        };
        wijmenuitem.prototype.previous = function () {
            ///<summary>
            /// Get the previous selectable item.  The last item will be selected
            /// if none is active or the first one is active.
            /// return null if none is selectable in previous.
            ///</summary>
                        var self = this, items = self._getParentOrMenu().getItems(), i, o, indexOfItem = $.inArray(self, items);
            if(indexOfItem === -1) {
                throw 'cannot find item from the parent collection';
            }
            for(i = indexOfItem - 1; i >= 0; i--) {
                o = items[i].options;
                if(o.displayVisible !== false && !o.header && !o.separator) {
                    return items[i].element;
                }
            }
            return null;
        };
        wijmenuitem.prototype._removeFromParentCollection = function () {
            var self = this, parent, deleteFromMenu = false, indexOfSelf;
            parent = self.getParent();
            if(parent === null) {
                parent = self._getMenu();
                deleteFromMenu = true;
            }
            indexOfSelf = $.inArray(self, parent.getItems());
            if(indexOfSelf === -1) {
                return;
            }
            //remove self from parent.getItems()
            wijmenu._changeCollection(indexOfSelf, parent.getItems(), parent.options.items, null);
            if(parent.getItems().length === 0) {
                if(!deleteFromMenu) {
                    parent._setSubmenuIcon(false);
                    parent._resetMarkupValue();
                }
                parent.element.children('ul').remove();
            }
        };
        wijmenuitem.prototype._resetMarkupValue = function () {
            this._sublist = null;
            this._link = null;
        };
        wijmenuitem.prototype._hideCurrentSubmenu = function (e) {
            var self = this, subList = self._getSublist();
            if(subList.length === 0) {
                return;
            }
            if(!subList.data("notClose")) {
                self._hideSubmenu(false, e);
            }
            $.each(self.getItems(), function () {
                this._hideCurrentSubmenu(e);
            });
        };
        wijmenuitem.prototype._showFlyoutSubmenu = function (e, callback) {
            var self = this, menu = this._getMenu(), curList = menu._currentMenuList, i;
            if(curList !== undefined) {
                for(i = curList.length; i > 0; i--) {
                    if(curList[i - 1] === self.getParent()) {
                        break;
                    } else {
                        curList[i - 1]._hideSubmenu(false, e);
                    }
                }
            }
            self._displaySubmenu(e, callback);
        };
        wijmenuitem.prototype.getItems = function () {
            ///<summary>
            /// Gets the collection of child items.
            ///</summary>
            return this._items;
        };
        wijmenuitem.prototype._getSublist = function () {
            var self = this;
            if(!self._sublist) {
                self._sublist = this.element.children('ul:first');
            }
            return self._sublist;
        };
        wijmenuitem.prototype._getLink = function () {
            var self = this;
            if(!self._link) {
                self._link = this.element.children(':first');
            }
            return self._link;
        };
        wijmenuitem.prototype._isRoot = function () {
            return this.getParent() === null;
        };
        wijmenuitem.prototype.add = function (menuItem, position) {
            /// <summary>
            /// Adds a child menuItem to the menuItem.
            /// </summary>
            /// <param name="menuItem" type="String,Object">
            /// which menuItem to be added
            /// 1.markup html.such as "<a>menuItem</a>" as a menuItem.
            /// 2.object options according to the options of wijmenuItem.
            /// </param>
            /// <param name="position" type="Int">
            /// the position to insert at
            /// </param>
            wijmenu._add(this, menuItem, position);
        };
        wijmenuitem.prototype.remove = /// <summary>
        /// Remove an item from the menu.
        /// </summary>
        /// <param name="index" type="String/Number">
        /// the index of menuitem to be removed
        /// </param>
        function (index) {
            wijmenu._remove(this, index);
        };
        return wijmenuitem;
    })(wijmo.wijmoWidget);
    wijmo.wijmenuitem = wijmenuitem;    
    //#region menuitem options
    wijmenuitem.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijmenuitem')",
        wijCSS: /// <summary>
        /// wijmenu css, extend from $.wijmo.wijCSS
        /// </summary>
        {
            wijmenuitemIcon: "wijmenuitem-icon",
            wijmenuParent: "wijmo-wijmenu-parent",
            wijmenuLink: "wijmo-wijmenu-link",
            wijmenuText: "wijmo-wijmenu-text",
            wijmenuList: "wijmo-wijmenu-list",
            wijmenuItem: "wijmo-wijmenu-item",
            wijmenuSeparator: "wijmo-wijmenu-separator",
            wijmenuIconLeft: "wijmo-wijmenu-icon-left",
            wijmenuIconRight: "wijmo-wijmenu-icon-right",
            wijmenuChild: "wijmo-wijmenu-child",
            wijmenuSeparatorContent: "wijmo-wijmenu-separator-content"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-c",
            content: "ui-body ui-body-c",
            stateDefault: "ui-btn-up-c",
            stateHover: "ui-btn-down-c",
            stateActive: "ui-btn-down-c"
        },
        header: ///	<summary>
        ///	A value that determines whether
        /// the menu item is a header item.
        /// </summary>
        false,
        separator: /// <summary>
        /// A value that determines whether
        /// the item is a separator.
        /// </summary>
        false,
        value: ///	<summary>
        ///	Sets the menuItem's value.
        /// Type:String.
        /// Default:"".
        /// Code example:$(".selector").wijmenuitem("value","Hello World!").
        ///	</summary>
        '',
        text: ///	<summary>
        ///	Sets the node's text.
        /// Type:String.
        /// Default:"".
        /// Code example:$(".selector").wijmenuitem("text","Hello World!").
        ///	</summary>
        "",
        navigateUrl: ///	<summary>
        ///	The menuItem's navigate url
        ///	</summary>
        '',
        target: /// <summary>
        /// Gets or sets the target of the link item
        /// </summary>
        '',
        iconClass: /// <summary>
        /// Gets or sets the icon css class to the menuitem
        /// </summary>
        '',
        imagePosition: /// <summary>
        /// Gets or sets which side, left or right, the image will
        // be rendered from the menu item.
        /// </summary>
        '',
        displayVisible: /// <summary>
        /// A value that indicates whether to show the menu.
        /// </summary>
        true,
        selected: /// <summary>
        /// A value that determines whether
        /// the item has beend selected.
        /// </summary>
        false,
        items: /// <summary>
        /// The options of child items
        /// Default: [].
        /// Type: Array.
        /// </summary>
        null
    });
    //#endregion
    $.wijmo.registerWidget(widgetName, wijmenu.prototype);
    $.widget("wijmo.wijmenuitem", $.wijmo.widget, wijmenuitem.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
/*globals $, jQuery, document, window, location, wijmoASPNetParseOptions*/
/*
* Depends:
*	jquery-1.4.2.js
*	jquery.ui.core.js
*	jquery.ui.widget.js
*	jquery.ui.position.js
*	jquery.effects.core.js
*	jquery.cookie.js
*  jquery.wijmo.wijsuperpanel.js
*	jquery.wijmo.wijutil.js
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery;
    var tabId = 0, listId = 0, effects = $.effects ? $.effects : $, effectsSave = effects.save, effectsRestore = effects.restore, effectsCreateWrapper = effects.createWrapper, effectsRemoveWrapper = effects.removeWrapper, getNextTabId = function () {
        return ++tabId;
    }, getNextListId = function () {
        return ++listId;
    };
    var wijtabs = (function (_super) {
        __extends(wijtabs, _super);
        function wijtabs() {
            _super.apply(this, arguments);

        }
        wijtabs.prototype._setOption = function (key, value) {
            _super.prototype._setOption.call(this, key, value);
            switch(key) {
                case 'selected':
                    if(this.options.collapsible && value === this.options.selected) {
                        return;
                    }
                    this.select(value);
                    break;
                case 'alignment':
                    this._innerDestroy();
                    this._tabify(true);
                    break;
                default:
                    this._tabify(false);
                    break;
            }
        };
        wijtabs.prototype._create = function () {
            var _this = this;
            var o = this.options;
            if(this.element.is(":hidden") && this.element.wijAddVisibilityObserver) {
                this.element.wijAddVisibilityObserver(function () {
                    if(_this.element.wijRemoveVisibilityObserver) {
                        _this.element.wijRemoveVisibilityObserver();
                    }
                    var dataObj = _this.element.data("wijtabs"), wijmoDataObj = _this.element.data("wijmoWijtabs");
                    _this.destroy();
                    _this.element.data("wijtabs", dataObj);
                    _this.element.data("wijmoWijtabs", wijmoDataObj);
                    _this._tabify(true);
                }, "wijtabs");
            }
            this._tabify(true);
            if(o.disabledstate || o.disabled) {
                this.disable();
            }
            _super.prototype._create.call(this);
        };
        wijtabs.prototype.destroy = function () {
            this._innerDestroy();
            _super.prototype.destroy.call(this);
        };
        wijtabs.prototype._tabify = function (init) {
            this.list = this.element.children('ol,ul').eq(0);
            this.lis = $('li:has(a)', this.list);
            this.anchors = this.lis.map(function () {
                return $('a', this)[0];
            });
            this.panels = $([]);
            var self = this, o = self.options, fragmentId = /^#.+/, tabsAlign, panelCorner, content, i, li, addState, removeState, showTab, hideTab;
            // Safari 2 reports '#' for an empty hash
            $.each(self.anchors, function (i, a) {
                var href = $(a).attr('href') || "", hrefBase = // For dynamically created HTML that contains a hash as href IE < 8
                // expands such href to the full page url with hash and then
                // misinterprets tab as ajax.
                // Same consideration applies for an added tab with a fragment identifier
                // since a[href=#fragment-identifier] does unexpectedly not match.
                // Thus normalize href attribute...
                href.split('#')[0], baseEl, id, $panel;
                //if (hrefBase && (hrefBase === location.toString().split('#')[0] ||
                if(hrefBase && (hrefBase === location.toString().split('#')[0] || (baseEl = $('base')[0]) && hrefBase === baseEl.href)) {
                    href = a.hash;
                    a.href = href;
                }
                // inline tab
                if(fragmentId.test(href)) {
                    self.panels = self.panels.add(self._sanitizeSelector(href), self.element);
                } else // remote tab
                // prevent loading the page itself if href is just "#"
                if(href !== '#') {
                    $.data(a, 'href.tabs', href)// required for restore on destroy
                    ;
                    $.data(a, 'load.tabs', href.replace(/#.*$/, ''))// mutable data
                    ;
                    id = self._tabId(a);
                    a.href = '#' + id;
                    $panel = $('#' + id);
                    if(!$panel.length) {
                        $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerBottom).insertAfter(self.panels[i - 1] || self.list);
                        $panel.data('destroy.tabs', true);
                    }
                    self.panels = self.panels.add($panel);
                } else// invalid tab href
                 {
                    o.disabledIndexes.push(i);
                }
            });
            tabsAlign = this._getAlignment(true);
            panelCorner = this._getAlignment(false);
            // initialization from scratch
            if(init) {
                // ARIA
                this.list.attr("role", "tablist");
                this.lis.attr("role", "tab");
                this.panels.attr("role", "tabpanel");
                this.element.addClass(o.wijCSS.tabs).addClass(o.wijCSS.wijtabs).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS["tabs" + tabsAlign]);
                this.list.addClass(o.wijCSS.tabsNav).addClass(o.wijCSS.helperReset).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll);
                this.lis.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]);
                this.panels.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner]);
                // attach necessary classes for styling
                switch(tabsAlign) {
                    case 'Bottom':
                        this.list.appendTo(this.element);
                        break;
                    case 'Left':
                        content = $('<div/>').addClass(o.wijCSS.wijtabsContent).appendTo(this.element);
                        this.panels.appendTo(content);
                        break;
                    case 'Right':
                        content = $('<div/>').addClass(o.wijCSS.wijtabsContent).insertBefore(this.list);
                        this.panels.appendTo(content);
                        break;
                    case 'Top':
                        this.list.prependTo(this.element);
                        break;
                }
                if(o.sortable && this.list.sortable) {
                    this.list.sortable({
                        axis: (tabsAlign === 'Top' || tabsAlign === 'Bottom') ? "x" : "y"
                    });
                }
                // Selected tab
                // use "selected" option or try to retrieve:
                // 1. from fragment identifier in url
                // 2. from cookie
                // 3. from selected class attribute on <li>
                if(o.selected === undefined) {
                    if(location.hash) {
                        $.each(this.anchors, function (i, a) {
                            if(a.hash === location.hash) {
                                o.selected = i;
                                return false;// break
                                
                            }
                        });
                    }
                    if(typeof o.selected !== 'number' && o.cookie) {
                        o.selected = parseInt(self._cookie(undefined, undefined), 10);
                    }
                    if(typeof o.selected !== 'number' && this.lis.filter('.' + o.wijCSS.tabsActive).length) {
                        o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
                    }
                    o.selected = o.selected || (this.lis.length ? 0 : -1);
                } else if(o.selected === null) {
                    // usage of null is deprecated, TODO remove in next release
                    o.selected = -1;
                }
                // sanity check - default to first tab...
                o.selected = ((o.selected >= 0 && this.anchors[o.selected]) || o.selected < 0) ? o.selected : 0;
                // Take disabling tabs via class attribute from HTML
                // into account and update option properly.
                // A selected tab cannot become disabled.
                o.disabledIndexes = $.unique(o.disabledIndexes.concat($.map(this.lis.filter('.' + o.wijCSS.stateDisabled), function (n, i) {
                    return self.lis.index(n);
                }))).sort();
                if($.inArray(o.selected, o.disabledIndexes) !== -1) {
                    o.disabledIndexes.splice($.inArray(o.selected, o.disabledIndexes), 1);
                }
                // highlight selected tab
                this.panels.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                this.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                // check for length avoids error when initializing empty list
                if(o.selected >= 0 && this.anchors.length) {
                    this.panels.eq(o.selected).removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    this.lis.eq(o.selected).addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    // seems to be expected behavior that the show callback is fired
                    self.element.queue("tabs", function () {
                        if(self.element.wijTriggerVisibility) {
                            $(self.panels[o.selected]).wijTriggerVisibility();
                        }
                        self._trigger('show', null, self._ui(self.anchors[o.selected], self.panels[o.selected]));
                    });
                    this.load(o.selected);
                }
                // clean up to avoid memory leaks in certain versions of IE 6
                $(window).bind('unload', function () {
                    if(self.lis) {
                        self.lis.add(self.anchors).unbind('.tabs');
                    }
                    self.lis = self.anchors = self.panels = null;
                });
            } else {
                // update selected after add/remove
                o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
            }
            // update collapsible
            this.element[o.collapsible ? 'addClass' : 'removeClass'](o.wijCSS.tabsCollapsible);
            // set or update cookie after init and add/remove respectively
            if(o.cookie) {
                this._cookie(o.selected, o.cookie);
            }
            // disable tabs
            //for (i = 0; (li = this.lis[i]); i++) {
            for(i = 0; i < this.lis.length; i++) {
                li = this.lis[i];
                $(li)[$.inArray(i, o.disabledIndexes) !== -1 && !$(li).hasClass(o.wijCSS.tabsActive) ? 'addClass' : 'removeClass'](o.wijCSS.stateDisabled);
                if($(li).hasClass(o.wijCSS.stateDisabled)) {
                    $(li).attr('aria-disabled', true);
                }
            }
            // reset cache if switching from cached to not cached
            if(o.cache === false) {
                this.anchors.removeData('cache.tabs');
            }
            // remove all handlers before, tabify may run on existing tabs
            // after add or option change
            this.lis.add(this.anchors).unbind('.tabs');
            if(!o.disabledState && !o.disabled && o.event !== 'mouseover') {
                addState = function (state, el) {
                    if(el.is(':not(.' + o.wijCSS.stateDisabled + ')')) {
                        el.addClass(state);
                    }
                };
                removeState = function (state, el) {
                    el.removeClass(state);
                };
                this.lis.bind('mouseover.tabs', function () {
                    addState(o.wijCSS.stateHover, $(this));
                });
                this.lis.bind('mouseout.tabs', function () {
                    removeState(o.wijCSS.stateHover, $(this));
                });
                this.anchors.bind('focus.tabs', function () {
                    addState(o.wijCSS.stateFocus, $(this).closest('li'));
                });
                this.anchors.bind('blur.tabs', function () {
                    removeState(o.wijCSS.stateFocus, $(this).closest('li'));
                });
            }
            if(o.showOption === undefined || o.showOption === null) {
                o.showOption = {
                };
            }
            this._normalizeBlindOption(o.showOption);
            if(o.hideOption === undefined || o.hideOption === null) {
                o.hideOption = {
                };
            }
            this._normalizeBlindOption(o.hideOption);
            // Show a tab...
            showTab = ((o.showOption.blind || o.showOption.fade) && o.showOption.duration > 0) ? function (clicked, $show) {
                $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                self._showContent();
                $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                    var props = {
                        duration: o.showOption.duration,
                        height: 'toggle',
                        opacity: 'toggle'
                    };
                    if(!o.showOption.blind) {
                        delete props.height;
                    }
                    if(!o.showOption.fade) {
                        delete props.opacity;
                    }
                    // avoid flicker that way
                    $show.hide().removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false).animate(props, o.showOption.duration || 'normal', function () {
                        self._resetStyle($show);
                        if($show.wijTriggerVisibility) {
                            $show.wijTriggerVisibility();
                        }
                        self._trigger('show', null, self._ui(clicked, $show[0]));
                    });
                } else {
                    self._showContent();
                    self._blindPanel($show, 'show');
                }
            } : function (clicked, $show) {
                $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                self._showContent();
                $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                if($show.wijTriggerVisibility) {
                    $show.wijTriggerVisibility();
                }
                self._trigger('show', null, self._ui(clicked, $show[0]));
            };
            // Hide a tab, $show is optional...
            hideTab = ((o.hideOption.blind || o.hideOption.fade) && o.hideOption.duration > 0) ? function (clicked, $hide) {
                if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                    var props = {
                        duration: o.hideOption.duration,
                        height: 'toggle',
                        opacity: 'toggle'
                    };
                    if(!o.hideOption.blind) {
                        delete props.height;
                    }
                    if(!o.hideOption.fade) {
                        delete props.opacity;
                    }
                    $hide.animate(props, o.hideOption.duration || 'normal', function () {
                        self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                        $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                        self._resetStyle($hide);
                        self.element.dequeue("tabs");
                    });
                } else {
                    self._saveLayout();
                    self._blindPanel($hide, 'hide');
                }
            } : function (clicked, $hide, $show) {
                self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                self._hideContent();
                $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                self.element.dequeue("tabs");
            };
            // attach tab event handler, unbind to avoid duplicates from former tabifying
            if(!o.disabledState && !o.disabled) {
                this.anchors.bind(o.event + '.tabs', function () {
                    var el = this, $li = $(this).closest('li'), $hide = self.panels.filter(':not(.' + o.wijCSS.wijtabsHide + ')'), $show = $(self._sanitizeSelector(this.hash), self.element);
                    // If tab is already selected and not collapsible or tab disabled or
                    // or is already loading or click callback returns false stop here.
                    // Check if click handler returns false last so that it is not
                    // executed for a disabled or loading tab!
                    if(($li.hasClass(o.wijCSS.tabsActive) && !o.collapsible) || $li.hasClass(o.wijCSS.stateDisabled) || $li.hasClass(o.wijCSS.tabsLoading) || self._trigger('select', null, self._ui(this, $show[0])) === false) {
                        this.blur();
                        return false;
                    }
                    o.selected = self.anchors.index(this);
                    self.abort();
                    // if tab may be closed
                    if(o.collapsible) {
                        if($li.hasClass(o.wijCSS.tabsActive)) {
                            o.selected = -1;
                            if(o.cookie) {
                                self._cookie(o.selected, o.cookie);
                            }
                            self.element.queue("tabs", function () {
                                hideTab(el, $hide);
                            }).dequeue("tabs");
                            this.blur();
                            return false;
                        } else if(!$hide.length) {
                            if(o.cookie) {
                                self._cookie(o.selected, o.cookie);
                            }
                            self.element.queue("tabs", function () {
                                showTab(el, $show);
                            });
                            // TODO make passing in node possible,
                            // see also http://dev.jqueryui.com/ticket/3171
                            self.load(self.anchors.index(this));
                            this.blur();
                            return false;
                        }
                    }
                    if(o.cookie) {
                        self._cookie(o.selected, o.cookie);
                    }
                    // show new tab
                    if($show.length) {
                        if($hide.length) {
                            self.element.queue("tabs", function () {
                                hideTab(el, $hide);
                            });
                        }
                        self.element.queue("tabs", function () {
                            showTab(el, $show);
                        });
                        self.load(self.anchors.index(this));
                    } else {
                        throw 'jQuery UI Tabs: Mismatching fragment identifier.';
                    }
                    // Prevent IE from keeping other link focussed when using
                    // the back button and remove dotted border from clicked link.
                    // This is controlled via CSS in modern browsers;
                    // blur() removes focus from address bar in Firefox which can
                    // become a usability and annoying problem with tabs('rotate').
                    if($.browser.msie) {
                        this.blur();
                    }
                });
            }
            this._initScroller();
            // disable click in any case
            this.anchors.bind('click.tabs', function () {
                return false;
            });
        };
        wijtabs.prototype._blindPanel = function (panel, mode) {
            var self = this, o = self.options, content = panel.parent('.' + o.wijCSS.wijtabsContent), props = [
                'position', 
                'top', 
                'left', 
                'width'
            ], blindOption = mode === 'show' ? o.showOption : o.hideOption, wrapper, a, listWidth;
            if(!content.length) {
                return;
            }
            self.list.width(self.list.width());
            //$.effects.save(panel, props);
            if(effectsSave) {
                effectsSave(panel, props);
            }
            panel.show()// Save & Show
            ;
            if(mode === 'show') {
                // Show
                panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                panel.width(self.element.data('panel.width'));
            } else {
                panel.width(panel.width());
            }
            // Create Wrapper
            //wrapper = $.effects.createWrapper(panel).css({ overflow: 'hidden' });
            if(effectsCreateWrapper) {
                wrapper = effectsCreateWrapper(panel).css({
                    overflow: 'hidden'
                });
            } else {
                wrapper = $('<div></div>');
            }
            if(mode === 'show') {
                // Shift
                wrapper.css($.extend({
                    width: 0
                }, blindOption.fade ? {
                    opacity: 0
                } : {
                }));
            }
            // Animation
            a = $.extend({
                width: mode === 'show' ? self.element.data('panel.outerWidth') : 0
            }, blindOption.fade ? {
                opacity: mode === 'show' ? 1 : 0
            } : {
            });
            listWidth = self.list.outerWidth(true);
            // Animate
            wrapper.animate(a, {
                duration: blindOption.duration,
                step: function () {
                    var ww = wrapper.outerWidth(true);
                    self.element.width(listWidth + ww);
                    content.width(Math.max(0, self.element.innerWidth() - listWidth - 6));
                },
                complete: function () {
                    if(mode === 'hide') {
                        self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                        // Hide
                        panel.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                    } else {
                        panel.css('width', '');
                    }
                    ////$.effects.restore(panel, props);
                    //$.effects.removeWrapper(panel); // Restore
                    if(effectsRemoveWrapper) {
                        effectsRemoveWrapper(panel);
                    }
                    if(mode === 'show') {
                        self._restoreLayout();
                    }
                    self._resetStyle(panel);
                    panel.dequeue();
                    self.element.dequeue("tabs");
                }
            });
        };
        wijtabs.prototype._hideContent = function () {
            var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
            if(content.length) {
                this._saveLayout();
                content.addClass(wijCSS.wijtabsHide).attr('aria-hidden', true);
                this.element.width(this.list.outerWidth(true));
            }
        };
        wijtabs.prototype._showContent = function () {
            var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
            if(content.length) {
                this._restoreLayout();
                content.removeClass(wijCSS.wijtabsHide).attr('aria-hidden', false);
            }
        };
        wijtabs.prototype._saveLayout = function () {
            var wijCSS = this.options.wijCSS, props = [
                'width', 
                'height', 
                'overflow'
            ], $hide = this.panels.filter(':not(.' + wijCSS.wijtabsHide + ')');
            //$.effects.save(self.element, props);
            //$.effects.save(self.list, props);
            //$.effects.save(self.element.find('.' + wijCSS.wijtabsContent), props);
            if(effectsSave) {
                effectsSave(this.element, props);
                effectsSave(this.list, props);
                effectsSave(this.element.find('.' + wijCSS.wijtabsContent), props);
            }
            this.list.width(this.list.width());
            this.element.data('panel.width', $hide.width());
            this.element.data('panel.outerWidth', $hide.outerWidth(true));
        };
        wijtabs.prototype._restoreLayout = function () {
            var wijCSS = this.options.wijCSS, props = [
                'width', 
                'height', 
                'overflow'
            ];
            //$.effects.restore(self.element, props);
            //$.effects.restore(self.list, props);
            //$.effects.restore(self.element.find('.' + wijCSS.wijtabsContent), props);
            if(effectsRestore) {
                effectsRestore(this.element, props);
                effectsRestore(this.list, props);
                effectsRestore(this.element.find('.' + wijCSS.wijtabsContent), props);
            }
        };
        wijtabs.prototype._resetStyle = // Reset certain styles left over from animation
        // and prevent IE's ClearType bug...
        function ($el) {
            $el.css({
                display: ''
            });
            if(!$.support.opacity) {
                $el[0].style.removeAttribute('filter');
            }
        };
        wijtabs.prototype._normalizeBlindOption = function (o) {
            if(o.blind === undefined) {
                o.blind = false;
            }
            if(o.fade === undefined) {
                o.fade = false;
            }
            if(o.duration === undefined) {
                o.duration = 200;
            }
            if(typeof o.duration === 'string') {
                try  {
                    o.duration = parseInt(o.duration, 10);
                } catch (e) {
                    o.duration = 200;
                }
            }
        };
        wijtabs.prototype._initScroller = function () {
            var horz = $.inArray(this._getAlignment(true), [
                'Top', 
                'Bottom'
            ]) !== -1, width = 0;
            if(!horz) {
                return;
            }
            $.each(this.lis, function () {
                width += $(this).outerWidth(true);
            });
            if(!!this.options.scrollable && this.element.innerWidth() < width) {
                if(this.scrollWrap === undefined) {
                    this.list.wrap("<div class='scrollWrap'></div>");
                    this.scrollWrap = this.list.parent();
                    //$.effects.save(this.list, ['width', 'height', 'overflow']);
                    if(effectsSave) {
                        effectsSave(this.list, [
                            'width', 
                            'height', 
                            'overflow'
                        ]);
                    }
                }
                this.list.width(width + 2);
                this.scrollWrap.height(this.list.outerHeight(true));
                this.scrollWrap.wijsuperpanel({
                    allowResize: false,
                    hScroller: {
                        scrollMode: 'edge'
                    },
                    vScroller: {
                        scrollBarVisibility: 'hidden'
                    }
                });
            } else {
                this._removeScroller();
            }
        };
        wijtabs.prototype._ui = function (tab, panel) {
            return {
                tab: tab,
                panel: panel,
                index: this.anchors.index(tab)
            };
        };
        wijtabs.prototype._tabId = function (a) {
            var $a = $(a), tabId, hrefParams;
            if($a.data && $a.data("tabid")) {
                return $a.data("tabid");
            }
            if(a.href && a.href.length) {
                hrefParams = this._getURLParameters(a.href);
                if(hrefParams.tabId) {
                    tabId = hrefParams.tabId;
                    $a.data("tabid", tabId);
                    return tabId;
                }
            }
            tabId = a.title && a.title.replace(/\s/g, '_').replace(/[^A-Za-z0-9\-_:\.]/g, '') || this.options.idPrefix + getNextTabId();
            $a.data("tabid", tabId);
            return tabId;
        };
        wijtabs.prototype._getURLParameters = function (url) {
            var params = {
            }, parametersString, parameters;
            if(url.indexOf('?') > -1) {
                parametersString = url.split('?')[1];
                parameters = parametersString.split('&');
                $.each(parameters, function (i, param) {
                    var p = param.split('=');
                    if(p.length > 1) {
                        params[p[0]] = p[1];
                    }
                });
            }
            return params;
        };
        wijtabs.prototype._getAlignment = function (tabs) {
            var align = this.options.alignment || 'top';
            if(tabs) {
                return align.charAt(0).toUpperCase() + align.substr(1);
            }
            switch(align) {
                case 'top':
                    align = 'Bottom';
                    break;
                case 'bottom':
                    align = 'Top';
                    break;
                case 'left':
                    align = 'Right';
                    break;
                case 'right':
                    align = 'Left';
                    break;
            }
            return align;
        };
        wijtabs.prototype._sanitizeSelector = function (hash) {
            // we need this because an id may contain a ":"
            return hash.replace(/:/g, '\\:');
        };
        wijtabs.prototype._innerDestroy = function () {
            var o = this.options, content = $('.' + o.wijCSS.wijtabsContent);
            this.abort();
            this._removeScroller();
            this.element.unbind('.tabs').removeClass(o.wijCSS.wijtabs).removeClass(o.wijCSS.tabsTop).removeClass(o.wijCSS.tabsBottom).removeClass(o.wijCSS.tabsLeft).removeClass(o.wijCSS.tabsRight).removeClass(o.wijCSS.tabs).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.content).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.tabsCollapsible).removeClass(o.wijCSS.helperClearFix).removeData('tabs').removeAttr('role');
            this.list.removeClass(o.wijCSS.tabsNav).removeClass(o.wijCSS.helperReset).removeClass(o.wijCSS.helperClearFix).removeClass(o.wijCSS.header).removeClass(o.wijCSS.cornerAll).removeAttr('role');
            $.each(this.anchors, function (idx, a) {
                var $a = $(a), href = $a.data('href.tabs');
                if(href) {
                    a.href = href;
                }
                $a.unbind('.tabs');
                $.each([
                    'href', 
                    'load', 
                    'cache'
                ], function (i, prefix) {
                    $a.removeData(prefix + '.tabs');
                });
            });
            this.lis.unbind('.tabs').add(this.panels).each(function (idx, li) {
                var $li = $(li);
                if($li.data('destroy.tabs')) {
                    $li.remove();
                } else {
                    $li.removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerTop).removeClass(o.wijCSS.cornerBottom).removeClass(o.wijCSS.cornerLeft).removeClass(o.wijCSS.cornerRight).removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateFocus).removeClass(o.wijCSS.stateDisabled).removeClass(o.wijCSS.tabsPanel).removeClass(o.wijCSS.content).removeClass(o.wijCSS.wijtabsHide).css({
                        position: '',
                        left: '',
                        top: ''
                    }).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-selected').removeAttr('aria-disabled');
                }
            });
            if(content.length) {
                content.replaceWith(content.contents());
            }
            if(o.cookie) {
                this._cookie(null, o.cookie);
            }
            return this;
        };
        wijtabs.prototype._cleanup = function () {
            // restore all former loading tabs labels
            var wijCSS = this.options.wijCSS;
            this.lis.filter('.' + wijCSS.tabsLoading).removeClass(wijCSS.tabsLoading).find('span:data(label.tabs)').each(function () {
                var el = $(this);
                el.html(el.data('label.tabs')).removeData('label.tabs');
            });
        };
        wijtabs.prototype._removeScroller = function () {
            if(!this.scrollWrap) {
                return;
            }
            this.scrollWrap.wijsuperpanel('destroy').replaceWith(this.scrollWrap.contents());
            this.scrollWrap = undefined;
            if(effectsRestore) {
                effectsRestore(this.list, [
                    'width', 
                    'height', 
                    'overflow'
                ]);
            }
        };
        wijtabs.prototype._cookie = function (index, cookie) {
            var c = this.cookie || (this.cookie = this.options.cookie.name || 'ui-tabs-' + getNextListId());
            return $.cookie.apply(null, [
                c
            ].concat($.makeArray(arguments)));
        };
        wijtabs.prototype.abort = function () {
            /// <summary>
            /// Terminate all running tab ajax requests and animations.
            /// Code example: $("#element").wijtabs('abort');
            /// </summary>
            this.element.queue([]);
            this.panels.stop(false, true);
            // "tabs" queue must not contain more than two elements,
            // which are the callbacks for the latest clicked tab...
            this.element.queue("tabs", this.element.queue("tabs").splice(-2, 2));
            // terminate pending requests from other tabs
            if(this.xhr) {
                this.xhr.abort();
                delete this.xhr;
            }
            // take care of tab labels
            this._cleanup();
            return this;
        };
        wijtabs.prototype.select = function (index) {
            /// <summary>
            /// Select a tab, as if it were clicked.
            /// Code example: $("#element").wijtabs('select', 1);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab to be selected or
            /// the id selector of the panel the tab is associated with.
            /// </param>
            if(typeof index === 'string') {
                index = this.anchors.index(this.anchors.filter('[href$=' + index + ']'));
            } else if(index === null) {
                // usage of null is deprecated, TODO remove in next release
                index = -1;
            }
            if(index === -1 && this.options.collapsible) {
                index = this.options.selected;
            }
            this.anchors.eq(index).trigger(this.options.event + '.tabs');
            return this;
        };
        wijtabs.prototype.load = function (index) {
            /// <summary>
            /// Reload the content of an Ajax tab programmatically.
            /// This method always loads the tab content from the remote location,
            /// even if cache is set to true.
            /// The second argument is the zero-based index of the tab to be reloaded.
            /// Code example: $("#element").wijtabs('load', 1);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab to be loaded
            /// </param>
                        var self = this, o = self.options, a = self.anchors.eq(index)[0], url = $.data(a, 'load.tabs'), span = $('span', a);
            self.abort();
            if(false === self._trigger('beforeShow', null, self._ui(self.anchors[index], self.panels[index]))) {
                self.element.dequeue("tabs");
                return;
            }
            // not remote or from cache
            if(!url || self.element.queue("tabs").length !== 0 && $.data(a, 'cache.tabs')) {
                self.element.dequeue("tabs");
                return;
            }
            // load remote from here on
            self.lis.eq(index).addClass(o.wijCSS.tabsLoading);
            if(o.spinner || self._defaults.spinner) {
                span.data('label.tabs', span.html()).html(o.spinner || self._defaults.spinner);
            }
            self.xhr = $.ajax($.extend({
            }, o.ajaxOptions, {
                url: url,
                success: function (r, s) {
                    $(self._sanitizeSelector(a.hash), self.element).html(r);
                    // take care of tab labels
                    self._cleanup();
                    if(o.cache) {
                        // if loaded once do not load them again
                        $.data(a, 'cache.tabs', true);
                    }
                    // callbacks
                    self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                    try  {
                        o.ajaxOptions.success(r, s);
                    } catch (e1) {
                    }
                },
                error: function (xhr, s, e) {
                    // take care of tab labels
                    self._cleanup();
                    // callbacks
                    self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                    try  {
                        // Passing index avoid a race condition when this method is
                        // called after the user has selected another tab.
                        // Pass the anchor that initiated this request allows
                        // loadError to manipulate the tab content panel via $(a.hash)
                        o.ajaxOptions.error(xhr, s, index, a);
                    } catch (e2) {
                    }
                }
            }));
            // last, so that load event is fired before show...
            self.element.dequeue("tabs");
            return self;
        };
        wijtabs.prototype.add = function (url, label, index) {
            /// <summary>
            /// Add a new tab.
            /// Code example: $("#element").wijtabs('add', url, label, [index]);
            /// </summary>
            /// <param name="url" type="String">A URL consisting of a fragment
            /// identifier only to create an in-page tab or a full url
            /// (relative or absolute, no cross-domain support) to turn the new tab
            /// into an Ajax (remote) tab.</param>
            /// <param name="label" type="String">
            /// The tab label.
            /// </param>
            /// <param name="index" type="Number">
            /// Zero-based position where to insert the new tab.
            ///</param>
            if(index === undefined) {
                index = this.anchors.length// append by default
                ;
            }
            var self = this, o = self.options, $li = $((o.tabTemplate || self._defaults.tabTemplate).replace(/#\{href\}/g, url).replace(/#\{label\}/g, label)), id = !url.indexOf('#') ? url.replace('#', '') : self._tabId($('a', $li)[0]), tabsAlign = self._getAlignment(true), panelCorner = self._getAlignment(false), $panel = $('#' + id), $content;
            $li.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]).data('destroy.tabs', true).attr('role', 'tab').attr('aria-selected', false);
            // try to find an existing element before creating a new one
            if(!$panel.length) {
                $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).data('destroy.tabs', true).attr('role', 'tabpanel');
            }
            $panel.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner] + ' ' + o.wijCSS.wijtabsHide).attr('aria-hidden', true);
            if(index >= self.lis.length) {
                $li.appendTo(self.list);
                if(self.panels.length > 0) {
                    $panel.insertAfter(self.panels[self.panels.length - 1]);
                } else {
                    $content = self.element.find('.' + o.wijCSS.wijtabsContent);
                    if($content.length === 0) {
                        $content = self.element;
                    }
                    $panel.appendTo($content);
                }
            } else {
                $li.insertBefore(self.lis[index]);
                $panel.insertBefore(self.panels[index]);
            }
            o.disabledIndexes = $.map(o.disabledIndexes, function (n, i) {
                return n >= index ? ++n : n;
            });
            self._removeScroller();
            self._tabify(false);
            if(self.anchors.length === 1) {
                // after tabify
                o.selected = 0;
                $li.addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                $panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                self.element.queue("tabs", function () {
                    if(self.element.wijTriggerVisibility) {
                        $(self.panels[0]).wijTriggerVisibility();
                    }
                    self._trigger('show', null, self._ui(self.anchors[0], self.panels[0]));
                });
                self.load(0);
            }
            // callback
            self._trigger('add', null, self._ui(self.anchors[index], self.panels[index]));
            return self;
        };
        wijtabs.prototype.remove = function (index) {
            /// <summary>
            /// Remove a tab.
            /// Code example: $("#element").wijtabs('remove', 1);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab to be removed.
            /// </param>
                        var o = this.options, $li = this.lis.eq(index).remove(), $panel = this.panels.eq(index).remove();
            // If selected tab was removed focus tab to the right or
            // in case the last tab was removed the tab to the left.
            if($li.hasClass(o.wijCSS.tabsActive) && this.anchors.length > 1) {
                this.select(index + (index + 1 < this.anchors.length ? 1 : -1));
            }
            o.disabledIndexes = $.map($.grep(o.disabledIndexes, function (n, i) {
                return n !== index;
            }, false), function (n, i) {
                return n >= index ? --n : n;
            });
            this._removeScroller();
            this._tabify(false);
            // callback
            this._trigger('remove', null, this._ui($li.find('a')[0], $panel[0]));
            return this;
        };
        wijtabs.prototype.enableTab = function (index) {
            /// <summary>
            /// Enable a disabled tab.
            /// Code example: $("#element").wijtabs('enableTab', 1);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab to be enabled.
            /// </param>
            var o = this.options;
            if($.inArray(index, o.disabledIndexes) === -1) {
                return;
            }
            this.lis.eq(index).removeClass(o.wijCSS.stateDisabled).removeAttr('aria-disabled');
            o.disabledIndexes = $.grep(o.disabledIndexes, function (n, i) {
                return n !== index;
            }, false);
            // callback
            this._trigger('enable', null, this._ui(this.anchors[index], this.panels[index]));
            return this;
        };
        wijtabs.prototype.disableTab = function (index) {
            /// <summary>
            /// Disabled a tab.
            /// Code example: $("#element").wijtabs('disableTab', 1);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab to be disabled.
            /// </param>
            var o = this.options;
            if(index !== o.selected) {
                // cannot disable already selected tab
                this.lis.eq(index).addClass(o.wijCSS.stateDisabled).attr('aria-disabled', true);
                o.disabledIndexes.push(index);
                o.disabledIndexes.sort();
                // callback
                this._trigger('disable', null, this._ui(this.anchors[index], this.panels[index]));
            }
            return this;
        };
        wijtabs.prototype.url = function (index, url) {
            /// <summary>
            /// Change the url from which an Ajax (remote) tab will be loaded.
            /// The specified URL will be used for subsequent loads.
            /// Note that you can not only change the URL for an existing remote tab
            /// with this method, but also turn an in-page tab into a remote tab.
            /// The second argument is the zero-based index of the tab of which
            /// its URL is to be updated.
            /// The third is a URL the content of the tab is loaded from.
            /// Code example: $("#element").wijtabs('url', 1, url);
            /// </summary>
            /// <param name="index" type="Number">
            /// The zero-based index of the tab of which its URL is to be updated.
            /// </param>
            /// <param name="url" type="String">
            /// A URL the content of the tab is loaded from.
            /// </param>
            this.anchors.eq(index).removeData('cache.tabs').data('load.tabs', url);
            return this;
        };
        wijtabs.prototype.length = function () {
            /// <summary>
            /// Retrieve the number of tabs of the first matched tab pane.
            /// Code example: $("#element").wijtabs('length');
            /// </summary>
            return this.anchors.length;
        };
        return wijtabs;
    })(wijmo.wijmoWidget);
    wijmo.wijtabs = wijtabs;    
    wijtabs.prototype._defaults = {
        panelTemplate: '<div></div>',
        spinner: '<em>Loading&#8230;</em>',
        tabTemplate: '<li><a href="#{href}"><span>#{label}</span></a></li>'
    };
    wijtabs.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        wijCSS: /// <summary>
        /// All CSS classes used in widgets.
        /// </summary>
        {
            wijtabs: "wijmo-wijtabs",
            wijtabsContent: "wijmo-wijtabs-content",
            wijtabsHide: "wijmo-wijtabs-hide"
        },
        wijMobileCSS: {
            header: "ui-header ui-bar-c",
            content: "ui-content ui-body ui-body-c",
            stateDefault: "ui-btn-up-a",
            stateActive: "ui-btn-down-b"
        },
        alignment: /// <summary>
        /// Determines the tabs' alignment in respect to the content.
        /// Possible values are: 'top', 'bottom', 'left' and 'right'.
        /// Type: String
        /// Default: 'top'
        /// Code Example:
        /// $('.selector').wijtabs({alignment: 'top'});
        /// </summary>
        'top',
        sortable: /// <summary>
        /// Determines whether the tab can be dragged to a new position.
        /// This option only works when jQuery.ui.sortable is available
        /// which means that it doesn't work in mobile mode.
        /// Type: Boolean
        /// Default: false
        /// Code Example:
        /// $('.selector').wijtabs({sortable: false});
        /// </summary>
        false,
        scrollable: /// <summary>
        /// Determines whether to wrap to the next line or scrolling
        ///		is enabled when the tabs exceed the specified width
        /// Type: Boolean
        /// Default: false
        /// Code Example:
        /// $('.selector').wijtabs({scrollable: false});
        /// </summary>
        false,
        ajaxOptions: /// <summary>
        /// Additional Ajax options to consider when loading tab content (see $.ajax).
        /// Type: object
        /// Default: null
        /// Code Example:
        /// $( ".selector" ).wijtabs({ ajaxOptions: { async: false } });
        /// </summary>
        null,
        cache: /// <summary>
        /// Whether or not to cache remote tabs content,
        /// e.g. load only once or with every click.
        /// Cached content is being lazy loaded,
        /// e.g once and only once for the first click.
        /// Note that to prevent the actual Ajax requests from being cached
        /// by the browser you need to provide an extra cache:
        /// false flag to ajaxOptions.
        /// Type: Boolean
        /// Default: false
        /// Code Example:
        /// $('.selector').wijtabs({cache: false});
        /// </summary>
        false,
        cookie: /// <summary>
        /// Store the latest selected tab in a cookie.
        /// The cookie is then used to determine the initially selected tab
        /// if the selected option is not defined.
        /// Requires cookie plugin. The object needs to have key/value pairs
        /// of the form the cookie plugin expects as options.
        /// Type: object
        /// Default: null,
        /// e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
        /// Code Example:
        /// $('.selector').wijtabs({cookie: {
        /// expires: 7, path: '/', domain: 'jquery.com', secure: true }});
        /// </summary>
        null,
        collapsible: /// <summary>
        /// Determines whether a tab can be collapsed by a user.
        /// When this is set to true, an already selected tab
        /// will be collapsed upon reselection.
        /// Type: Boolean
        /// Default: false
        /// Code Example:
        /// $('.selector').wijtabs({collapsible: false});
        /// </summary>
        false,
        hideOption: /// <summary>
        /// This is an animation option for hiding the tabs panel content.
        /// Type: object
        /// Default: null
        /// Code Example:
        /// $('.selector').wijtabs({
        /// hideOption: { blind: true, fade: true, duration: 200}});
        /// </summary>
        null,
        showOption: // e.g. { blind: true, fade: true, duration: 200}
        /// <summary>
        /// This is an animation option for showing the tabs panel content.
        /// Type: object
        /// Default: null
        /// Code Example:
        /// $('.selector').wijtabs({
        /// showOption: { blind: true, fade: true, duration: 200}});
        /// </summary>
        null,
        disabledIndexes: // e.g. { blind: true, fade: true, duration: 200}
        /// <summary>
        /// An array containing the position of the tabs (zero-based index)
        /// that should be disabled on initialization.
        /// Type: Array
        /// Default: []
        /// Code Example:
        /// $( ".selector" ).wijtabs({ disabledIndexes: [1, 2] });
        /// </summary>
        [],
        event: /// <summary>
        /// The type of event to be used for selecting a tab.
        /// </summary>
        'click',
        idPrefix: /// <summary>
        /// If the remote tab, its anchor element that is, has no title attribute
        /// to generate an id from,
        /// an id/fragment identifier is created from this prefix and a unique id
        /// returned by $.data(el), for example "ui-tabs-54".
        /// Type: String
        /// Default: 'ui-tabs-'
        /// </summary>
        'ui-tabs-',
        panelTemplate: /// <summary>
        /// HTML template from which a new tab panel is created in case of
        /// adding a tab with the add method or
        /// when creating a panel for a remote tab on the fly.
        /// Type: String
        /// Default: ''
        /// Code Example:
        /// $('.selector').wijtabs({panelTemplate: '<div></div>'});
        /// </summary>
        '',
        spinner: /// <summary>
        /// The HTML content of this string is shown in a tab title
        /// while remote content is loading.
        /// Pass in empty string to deactivate that behavior.
        /// An span element must be present in the A tag of the title,
        /// for the spinner content to be visible.
        /// Type: String
        /// Default: ''
        /// Code Example:
        /// $('.selector').wijtabs({spinner: 'Connectingâ€?});
        /// </summary>
        '',
        tabTemplate: /// <summary>
        /// HTML template from which a new tab is created and added.
        /// The placeholders #{href} and #{label} are replaced with the url
        /// and tab label that are passed as
        /// arguments to the add method.
        /// Type: String
        /// Default: ''
        /// Code Example:
        /// $('.selector').wijtabs({
        /// tabTemplate: '<div><a href="#{href}"><span>#{label}</span></a></div>'});
        /// </summary>
        '',
        add: /// <summary>
        /// The add event handler. A function called when a tab is added.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ add: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        remove: /// <summary>
        /// The remove event handler. A function called when a tab is removed.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ remove: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        select: /// <summary>
        /// The select event handler. A function called when clicking a tab.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ select: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        beforeShow: /// <summary>
        /// The beforeShow event handler. A function called before a tab is shown.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ beforeShow: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        /// <returns type="Boolean">
        /// False if want to cancel the following operations.
        /// </returns>
        null,
        show: /// <summary>
        /// The show event handler. A function called when a tab is shown.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ show: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        load: /// <summary>
        /// The load event handler.
        /// A function called after the content of a remote tab has been loaded.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ load: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        disable: /// <summary>
        /// The disable event handler. A function called when a tab is disabled.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ disable: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null,
        enable: /// <summary>
        /// The enable event handler. A function called when a tab is enabled.
        /// Default: null.
        /// Type: Function.
        /// Code example: $("#element").wijtabs({ enable: function (e, ui) { } });
        /// </summary>
        ///
        /// <param name="e" type="Object">jQuery.Event object.</param>
        /// <param name="ui" type="Object">
        /// The data that contains the related ui elements.
        /// ui.tab: The tab element.
        /// ui.panel: The panel element.
        /// ui.index: The index of the tab.
        /// </param>
        null
    });
    $.wijmo.registerWidget("wijtabs", wijtabs.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijvideo";
    var wijvideo = (function (_super) {
        __extends(wijvideo, _super);
        function wijvideo() {
            _super.apply(this, arguments);

        }
        wijvideo.prototype._create = function () {
            var self = this, pos, $playbtn, videoIsSupport, wijCSS = self.options.wijCSS, o = self.options, interval;
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            if($(this.element).is("video")) {
                this.$video = $(this.element);
            } else {
                this.$video = $(this.element).find("video");
            }
            //update for fixing bug 18129 by wh at 2011/11/2
            if(!this.$video || this.$video.length === 0 || ($.browser.msie && parseInt($.browser.version, 10) < 9)) {
                return;
            }
            //end for fixing
            //Add for fixing bug 18204 by wh at 2011/11/7
            videoIsSupport = this.$video[0].canPlayType;
            if(!videoIsSupport) {
                return;
            }
            //end for fixing bug 18204
            this.$video.wrap('<div class="wijmo-wijvideo ' + wijCSS.content + ' ' + wijCSS.widget + '" />').after('<div class="wijmo-wijvideo-wrapper">' + '<ul class="wijmo-wijvideo-controls ' + wijCSS.header + ' ' + wijCSS.helperClearFix + ' ' + wijCSS.helperReset + '">' + '<li class="wijmo-wijvideo-play ' + wijCSS.stateDefault + ' ' + wijCSS.cornerAll + '">' + '<span class="' + wijCSS.icon + " " + wijCSS.iconPlay + '"></span>' + '</li>' + '<li class="wijmo-wijvideo-index"><div class="wijmo-wijvideo-index-slider"></div></li>' + '<li class="wijmo-wijvideo-timer">00:00</li>' + '<li class="wijmo-wijvideo-volume ' + wijCSS.stateDefault + ' ' + wijCSS.cornerAll + '">' + '<div class="wijmo-wijvideo-volume-container">' + '<div class="wijmo-wijvideo-volumeslider ' + wijCSS.stateDefault + ' ' + wijCSS.cornerTop + '"></div>' + '</div>' + '<span class="' + wijCSS.icon + " " + wijCSS.iconVolumeOn + '"></span>' + '</li>' + '<li class="wijmo-wijvideo-fullscreen ' + wijCSS.stateDefault + " " + wijCSS.cornerAll + '">' + '<span class="' + wijCSS.icon + " " + wijCSS.iconArrow4Diag + '"></span>' + '</li>' + '</ul>' + '</div>');
            this.$vidParent = this.$video.parent('.wijmo-wijvideo');
            // size the div wrapper to the height and width of the controls
            this.$vidParent.width(this.$video.outerWidth()).height(this.$video.outerHeight());
            this.$seekSlider = this.$vidParent.find('.wijmo-wijvideo-index-slider');
            //Volumn
            self._volumnOn = true;
            this.$volumeBtn = this.$vidParent.find('.wijmo-wijvideo-volume');
            // create the video this.seek slider
            interval = window.setInterval(function () {
                //replace the attr to prop
                //if (this.$video.attr('readyState')) {
                if(self._getVideoAttribute("readyState")) {
                    window.clearInterval(interval);
                    //note: we need to adjust the size of the video in
                    //this time
                    self.$vidParent.width(self.$video.outerWidth()).height(self.$video.outerHeight());
                    //note: if the controls is invisible, it will not
                    //get the position
                    self.$video.parent().find('.wijmo-wijvideo-controls').show();
                    //this.$seekSlider = this.$vidParent.find('.wijmo-wijvideo-index-slider');
                    pos = self.$vidParent.find('.wijmo-wijvideo-timer').position().left;
                    self.$seekSlider.width(pos - self.$seekSlider.position().left - 15);
                    self.$seekSlider.slider({
                        value: 0,
                        step: 0.01,
                        max: self._getVideoAttribute("duration"),
                        range: 'min',
                        stop: function (e, ui) {
                            self.seek = false;
                            self._setVideoAttribute("currentTime", ui.value);
                        },
                        slide: function () {
                            self.seek = true;
                        }
                    });
                    self._updateTime();
                    // wire up the volume
                    self.$volumeSlider = self.$vidParent.find('.wijmo-wijvideo-volumeslider');
                    self.$volumeSlider.slider({
                        min: 0,
                        max: 1,
                        value: self._getVideoAttribute("volume"),
                        step: 0.1,
                        orientation: 'vertical',
                        range: 'min',
                        slide: function (e, ui) {
                            self._setVideoAttribute("volume", ui.value);
                            if(ui.value === 0) {
                                self._volumnOn = false;
                                self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOn).addClass(wijCSS.iconVolumeOff);
                            } else {
                                self._volumnOn = true;
                                self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOff).addClass(wijCSS.iconVolumeOn);
                            }
                        }
                    });
                    self.$video.parent().find('.wijmo-wijvideo-controls').css('display', 'none');
                    self._initialToolTip();
                    if(!o.showControlsOnHover) {
                        $('.wijmo-wijvideo-controls').show();
                        self.$vidParent.height(self.$video.outerHeight() + $('.wijmo-wijvideo-controls').height());
                    }
                }
            }, 200);
            this.$video.bind("click." + self.widgetName, function () {
                self._togglePlay();
            });
            // display the bar on hover
            if(o.showControlsOnHover) {
                $('.wijmo-wijvideo').hover(function () {
                    $('.wijmo-wijvideo-controls').stop(true, true).fadeIn();
                }, function () {
                    $('.wijmo-wijvideo-controls').delay(300).fadeOut();
                });
            }
            $playbtn = this.$vidParent.find('.wijmo-wijvideo-play > span');
            $playbtn.click(function () {
                self._togglePlay();
            }).parent().hover(function () {
                $(this).addClass(wijCSS.stateHover);
            }, function () {
                $(this).removeClass(wijCSS.stateHover);
            });
            this.$vidParent.find('.wijmo-wijvideo-volume').hover(function () {
                $('.wijmo-wijvideo-volume-container').stop(true, true).slideToggle();
            });
            this.$fullScreenBtn = this.$vidParent.find('.wijmo-wijvideo-fullscreen > span');
            this.$fullScreenBtn.click(function () {
                self._toggleFullScreen();
            }).parent().hover(function () {
                $(this).addClass(wijCSS.stateHover);
            }, function () {
                $(this).removeClass(wijCSS.stateHover);
            });
            if(!self.options.fullScreenButtonVisible) {
                this.$vidParent.find('.wijmo-wijvideo-fullscreen').hide();
            }
            this.$volumeBtn.hover(function () {
                $(this).addClass(wijCSS.stateHover);
            }, function () {
                $(this).removeClass(wijCSS.stateHover);
            }).click(function () {
                if(self._getVideoAttribute("readyState")) {
                    self._volumnOn = !self._volumnOn;
                    if(!self._volumnOn) {
                        var currentVolumn = this.$volumeSlider.slider('value');
                        this.$volumeSlider.slider('value', 0);
                        self._setVideoAttribute('volume', 0);
                        this.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOn).addClass(wijCSS.iconVolumeOff);
                    } else {
                        this.$volumeSlider.slider('value', currentVolumn);
                        self._setVideoAttribute('volume', currentVolumn);
                        this.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOff).addClass(wijCSS.iconVolumeOn);
                    }
                }
            });
            //move the init tooltip to interval, when the video's state
            //is ready, then init the tooltip
            //self._initialToolTip();
            this.$video.bind('play.' + self.widgetName, function () {
                $playbtn.removeClass(wijCSS.icon + " " + wijCSS.iconPlay).addClass(wijCSS.icon + " " + wijCSS.iconPause);
            });
            this.$video.bind('pause.' + self.widgetName, function () {
                $playbtn.removeClass(wijCSS.icon + " " + wijCSS.iconPause).addClass(wijCSS.icon + " " + wijCSS.iconPlay);
            });
            this.$video.bind('ended.' + self.widgetName, function () {
                self.pause();
            });
            this.$video.bind('timeupdate.' + self.widgetName, function () {
                self._updateTime();
            });
            self._videoIsControls = false;
            if(self._getVideoAttribute("controls")) {
                self._videoIsControls = true;
            }
            this.$video.removeAttr('controls');
            //update for visibility change
            if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                self.element.wijAddVisibilityObserver(function () {
                    self._refresh();
                    if(self.element.wijRemoveVisibilityObserver) {
                        self.element.wijRemoveVisibilityObserver();
                    }
                }, "wijvideo");
            }
            //update for juice 22288
            if(self.options.disabled) {
                self._handleDisabledOption(true, self.element);
            }
        };
        wijvideo.prototype._setOption = function (key, value) {
            var self = this, o = self.options;
            //$.wijmo.widget.prototype._setOption.apply(self, arguments);
            _super.prototype._setOption.call(this, key, value);
            if(key === "fullScreenButtonVisible") {
                o.fullScreenButtonVisible = value;
                if(value) {
                    this.$vidParent.find('.wijmo-wijvideo-fullscreen').show();
                } else {
                    this.$vidParent.find('.wijmo-wijvideo-fullscreen').hide();
                }
            } else if(key === "disabled") {
                self._handleDisabledOption(value, self.element);
            } else if(key === "showControlsOnHover") {
                if(!value) {
                    $('.wijmo-wijvideo').unbind('mouseenter mouseleave');
                    window.setTimeout(function () {
                        $('.wijmo-wijvideo-controls').show();
                        self.$vidParent.height(self.$video.outerHeight() + $('.wijmo-wijvideo-controls').height());
                    }, 200);
                } else {
                    this.$vidParent.height(this.$video.outerHeight());
                    $('.wijmo-wijvideo-controls').hide();
                    $('.wijmo-wijvideo').hover(function () {
                        $('.wijmo-wijvideo-controls').stop(true, true).fadeIn();
                    }, function () {
                        $('.wijmo-wijvideo-controls').delay(300).fadeOut();
                    });
                }
            }
            //end for disabled option
                    };
        wijvideo.prototype._handleDisabledOption = function (disabled, ele) {
            var self = this;
            if(disabled) {
                if(!self.disabledDiv) {
                    self.disabledDiv = self._createDisabledDiv(ele);
                }
                self.disabledDiv.appendTo("body");
                if($.browser.msie) {
                    $('.wijmo-wijvideo').unbind('mouseenter mouseleave');
                    this.$video.unbind("click." + self.widgetName);
                }
            } else {
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                    if($.browser.msie) {
                        $('.wijmo-wijvideo').hover(function () {
                            $('.wijmo-wijvideo-controls').stop(true, true).fadeIn();
                        }, function () {
                            $('.wijmo-wijvideo-controls').delay(300).fadeOut();
                        });
                        this.$video.bind("click." + self.widgetName, function () {
                            self._togglePlay();
                        });
                    }
                }
            }
        };
        wijvideo.prototype._createDisabledDiv = function (outerEle) {
            var ele = this.$vidParent, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
            return $("<div></div>").addClass("ui-disabled").css({
                "z-index": "99999",
                position: "absolute",
                width: disabledWidth,
                height: disabledHeight,
                left: eleOffset.left,
                top: eleOffset.top
            });
        };
        wijvideo.prototype._getVideoAttribute = function (name) {
            if(name === "") {
                return;
            }
            if(this.$video.attr(name) !== undefined) {
                return this.$video.attr(name);
            } else {
                return this.$video.prop(name);
            }
        };
        wijvideo.prototype._setVideoAttribute = function (name, value) {
            if(name === "") {
                return;
            }
            if(this.$video.attr(name) !== undefined) {
                return this.$video.attr(name, value);
            } else {
                return this.$video.prop(name, value);
            }
        };
        wijvideo.prototype._initialToolTip = function () {
            var self = this;
            //ToolTip-slider
            this.$seekSlider.wijtooltip({
                mouseTrailing: true,
                showCallout: false,
                position: {
                    offset: '-60 -60'
                }
            });
            this.$seekSlider.bind("mousemove", function (e, ui) {
                self._changeToolTipContent(e);
            });
            //ToolTip-button
            this.$volumeBtn.wijtooltip({
                content: self._localizeString("volumeToolTip", "Volume"),
                showCallout: false
            });
            this.$fullScreenBtn.wijtooltip({
                content: self._localizeString("fullScreenToolTip", "Full Screen"),
                showCallout: false
            });
            //add class to prevent from overriding the origin css of tooltip.
            this.$seekSlider.wijtooltip("widget").addClass("wijmo-wijvideo");
            this.$volumeBtn.wijtooltip("widget").addClass("wijmo-wijvideo");
            this.$volumeBtn.wijtooltip("widget").addClass("wijmo-wijvideo");
        };
        wijvideo.prototype._updateTime = function () {
            var self = this, dur = self._getVideoAttribute("duration"), cur = self._getVideoAttribute("currentTime"), mm, ss, mfmt = '', sfmt = '';
            mm = this._truncate((dur - cur) / 60);
            ss = this._truncate((dur - cur) - (mm * 60));
            if(mm < 10) {
                mfmt = '0';
            }
            if(ss < 10) {
                sfmt = '0';
            }
            this.$vidParent.find('.wijmo-wijvideo-timer').html(mfmt + mm + ':' + sfmt + ss);
            if(!this.seek) {
                this.$seekSlider.slider('value', cur);
            }
        };
        wijvideo.prototype._truncate = function (n) {
            return Math[n > 0 ? "floor" : "ceil"](n);
        };
        wijvideo.prototype._togglePlay = function () {
            var self = this;
            if(!self._getVideoAttribute("readyState")) {
                return;
            }
            if(self._getVideoAttribute("paused")) {
                this.play();
            } else {
                this.pause();
            }
        };
        wijvideo.prototype._toggleFullScreen = function () {
            var self = this, isPaused = self._getVideoAttribute("paused"), offsetWidth = 0, fWidth = $(window).width(), fHeight = $(window).height();
            this.fullScreen = !this.fullScreen;
            if(this.fullScreen) {
                self._oriVidParentStyle = this.$vidParent.attr("style");
                self._oriWidth = this.$video.outerWidth();
                self._oriHeight = this.$video.outerHeight();
                self._oriDocOverFlow = $(document.documentElement).css("overflow");
                $(document.documentElement).css({
                    overflow: "hidden"
                });
                if(!self._replacedDiv) {
                    self._replacedDiv = $("<div />");
                }
                this.$vidParent.after(self._replacedDiv);
                this.$vidParent.addClass("wijmo-wijvideo-container-fullscreen").css({
                    width: fWidth,
                    height: fHeight
                }).appendTo($("body"));
                this.$video.attr("width", fWidth).attr("height", fHeight);
                $(window).bind("resize.wijvideo", function () {
                    self._fullscreenOnWindowResize();
                });
                //for reposition the video control
                offsetWidth = fWidth - self._oriWidth;
            } else {
                $(document.documentElement).css({
                    overflow: self._oriDocOverFlow
                });
                //for reposition the video control
                offsetWidth = self._oriWidth - this.$video.width();
                self._replacedDiv.after(this.$vidParent).remove();
                this.$vidParent.removeClass("wijmo-wijvideo-container-fullscreen").attr("style", "").attr("style", self._oriVidParentStyle);
                this.$video.attr("width", self._oriWidth).attr("height", self._oriHeight);
                $(window).unbind("resize.wijvideo");
            }
            self._positionControls(offsetWidth);
            self._hideToolTips();
            if(!isPaused) {
                self.play();
            } else {
                self.pause();
            }
        };
        wijvideo.prototype._fullscreenOnWindowResize = function () {
            var self = this, fWidth = $(window).width(), fHeight = $(window).height(), offsetWidth = fWidth - this.$vidParent.width();
            this.$vidParent.css({
                width: fWidth,
                height: fHeight
            });
            this.$video.attr("width", fWidth).attr("height", fHeight);
            self._positionControls(offsetWidth);
        };
        wijvideo.prototype._positionControls = function (offsetWidth) {
            var seekSlider = this.$vidParent.find('.wijmo-wijvideo-index-slider');
            seekSlider.width(seekSlider.width() + offsetWidth);
        };
        wijvideo.prototype._showToolTip = function (e) {
            var self = this, mousePositionX = e.pageX, mousePositionY = e.pageY, sliderOffset = this.$seekSlider.offset().left, sliderWidth = this.$seekSlider.width(), curWidth = mousePositionX - sliderOffset, dur = self._getVideoAttribute("duration"), currentTime;
            currentTime = dur * (curWidth / sliderWidth);
            this.$seekSlider.wijtooltip("option", "content", self._getToolTipContent(currentTime));
            this.$seekSlider.wijtooltip("showAt", {
                x: mousePositionX,
                y: mousePositionY - 10
            });
        };
        wijvideo.prototype._changeToolTipContent = function (e) {
            var self = this, mousePositionX = e.pageX, sliderOffset = this.$seekSlider.offset().left, sliderWidth = this.$seekSlider.width(), curWidth = mousePositionX - sliderOffset, dur = self._getVideoAttribute("duration"), currentTime;
            currentTime = dur * (curWidth / sliderWidth);
            this.$seekSlider.wijtooltip("option", "content", self._getToolTipContent(currentTime));
        };
        wijvideo.prototype._hideToolTips = function () {
            if(this.$seekSlider.data("wijmoWijtooltip")) {
                this.$seekSlider.wijtooltip("hide");
            }
            if(this.$volumeBtn.data("wijmoWijtooltip")) {
                this.$volumeBtn.wijtooltip("hide");
            }
            if(this.$fullScreenBtn.data("wijmoWijtooltip")) {
                this.$fullScreenBtn.wijtooltip("hide");
            }
        };
        wijvideo.prototype._localizeString = function (key, defaultValue) {
            var o = this.options;
            if(o.localization && o.localization[key]) {
                return o.localization[key];
            }
            return defaultValue;
        };
        wijvideo.prototype._getToolTipContent = function (currentTime) {
            var mm, ss, mfmt = '', sfmt = '';
            mm = parseInt((currentTime / 60).toString(), 10);
            ss = parseInt((currentTime - (mm * 60)).toString(), 10);
            if(mm < 10) {
                mfmt = '0';
            }
            if(ss < 10) {
                sfmt = '0';
            }
            return mfmt + mm + ':' + sfmt + ss;
        };
        wijvideo.prototype._refresh = function () {
            var pos;
            this.$video.parent().find('.wijmo-wijvideo-controls').show();
            pos = this.$vidParent.find('.wijmo-wijvideo-timer').position().left;
            this.$seekSlider.width(pos - this.$seekSlider.position().left - 15);
            this.$video.parent().find('.wijmo-wijvideo-controls').css('display', 'none');
            if(!this.options.showControlsOnHover) {
                $('.wijmo-wijvideo-controls', this.$vidParent).show();
                this.$vidParent.height(this.$video.outerHeight() + $('.wijmo-wijvideo-controls').height());
            }
        };
        wijvideo.prototype.destroy = function () {
            ///	<summary>
            ///	Removes the wijvideo functionality completely.
            /// This returns the element back to its pre-init state.
            /// Code example: $("#element").wijvideo("destroy");
            ///	</summary>
            var self = this;
            //$.wijmo.widget.prototype.destroy.apply(this, arguments);
            _super.prototype.destroy.call(this);
            //remove the controls
            this.$vidParent.after(this.$video).remove();
            this.$video.unbind('.' + self.widgetName);
            if(self._videoIsControls) {
                self._setVideoAttribute("controls", true);
            }
        };
        wijvideo.prototype.play = function () {
            ///	<summary>
            ///	Play the video.
            /// Code example: $("#element").wijvideo("play");
            ///	</summary>
            this.$video[0].play();
        };
        wijvideo.prototype.pause = function () {
            ///	<summary>
            ///	Pause the video.
            /// Code example: $("#element").wijvideo("pause");
            ///	</summary>
            this.$video[0].pause();
        };
        wijvideo.prototype.getWidth = function () {
            ///	<summary>
            ///	Gets the video width in pixel.
            /// Code example: $("#element").wijvideo("getWidth");
            ///	</summary>
            return this.$video.outerWidth();
        };
        wijvideo.prototype.setWidth = function (width) {
            ///	<summary>
            ///	Sets the video width in pixel.
            /// Code example: $("#element").wijvideo("setWidth", 600);
            ///	</summary>
            /// <param name="width" type="Number">Width value in pixel.</param>
            width = width || 600;
            var origWidth = this.getWidth();
            this.$video.attr('width', width);
            this.$vidParent.width(this.$video.outerWidth());
            this._positionControls(this.getWidth() - origWidth);
        };
        wijvideo.prototype.getHeight = function () {
            ///	<summary>
            ///	Gets the video height in pixel.
            /// Code example: $("#element").wijvideo("getHeight");
            ///	</summary>
            return this.$video.outerHeight();
        };
        wijvideo.prototype.setHeight = function (height) {
            ///	<summary>
            ///	Sets the video height in pixel.
            /// Code example: $("#element").wijvideo("setHeight", 400);
            ///	</summary>
            /// <param name="height" type="Number">Height value in pixel.</param>
            height = height || 400;
            this.$video.attr('height', height);
            if(this.options.showControlsOnHover) {
                this.$vidParent.height(this.$video.outerHeight());
            } else {
                this.$vidParent.height(this.$video.outerHeight() + $('.wijmo-wijvideo-controls').height());
            }
        };
        return wijvideo;
    })(wijmo.wijmoWidget);
    wijmo.wijvideo = wijvideo;    
    wijvideo.prototype.options = $.extend(true, {
    }, wijmo.wijmoWidget.prototype.options, {
        initSelector: /// <summary>
        /// Selector option for auto self initialization.
        ///	This option is internal.
        /// </summary>
        ":jqmData(role='wijvideo')",
        wijCSS: //All CSS classes used in widgets that use jQuery UI CSS Framework
        {
            iconVolumeOn: "ui-icon-volume-on",
            iconVolumeOff: "ui-icon-volume-off"
        },
        fullScreenButtonVisible: /// <summary>
        /// A value that indicates whether to show the full screen button.
        /// Type: Boolean.
        /// Default: true.
        /// Code example: $(".video").wijvideo("option",
        /// "fullScreenButtonVisible", false).
        /// </summary>
        true,
        showControlsOnHover: ///	<summary>
        ///	Determines whether to display the controls only
        /// when hovering the mouse to the video.
        /// Default: true
        /// Type: Boolean
        /// Code example:
        ///  $(".video").wijvideo({
        ///      showControlsOnHover: false
        ///  });
        ///	</summary>
        true,
        localization: ///	<summary>
        ///	Use the localization option in order to localize
        ///	text which not depends on culture.
        /// Default: {
        ///	volumeToolTip: "Volume",
        ///	fullScreenToolTip: "Full Screen"
        /// }
        /// Type: Object.
        /// Code example: $("#video").wijvideo(
        ///					{
        ///						localization: {
        ///							volumeToolTip: "volume",
        ///							fullScreenToolTip: "FullScreen"
        ///						}
        ///					});
        ///	</summary>
        null
    });
    $.wijmo.registerWidget("wijvideo", wijvideo.prototype);
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../Base/jquery.wijmo.widget.ts" />
/*globals jQuery*/
/*
* Depends:
*  jquery.mobile.js
*
*/
var wijmo;
(function (wijmo) {
    "use strict";
    var $ = jQuery, widgetName = "wijlistview";
    var wijlistview = (function (_super) {
        __extends(wijlistview, _super);
        function wijlistview() {
            _super.apply(this, arguments);

        }
        wijlistview.prototype._baseWidget = function () {
            return $.mobile.listview;
        };
        return wijlistview;
    })(wijmo.wijmoWidget);
    wijmo.wijlistview = wijlistview;    
    // empty so far
    if($.mobile) {
        wijlistview.prototype.options = $.extend({
        }, $.mobile.listview.prototype.options, wijmo.wijmoWidget.prototype.options, {
            initSelector: ":jqmData(role='wijlistview')"
        });
        $.wijmo.registerWidget(widgetName, $.mobile.listview, wijlistview.prototype);
    }
})(wijmo || (wijmo = {}));
